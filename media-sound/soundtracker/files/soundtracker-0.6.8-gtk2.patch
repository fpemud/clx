diff -Naur soundtracker-0.6.8/app/audio.c soundtracker-0.6.8-gtk2/app/audio.c
--- soundtracker-0.6.8/app/audio.c	2006-02-25 13:30:54.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/audio.c	2010-09-23 11:11:35.000000000 +0200
@@ -19,6 +19,7 @@
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+
 #include <config.h>
 
 #include <pthread.h>
@@ -83,6 +84,8 @@
 event_waiter *audio_tempo_ew;
 event_waiter *audio_bpm_ew;
 
+GMutex *mutex;
+
 static int set_songpos_wait_for = -1;
 static int confirm_tempo = 0, confirm_bpm = 0;
 
@@ -194,7 +197,8 @@
 	    int i;
 
 	    tracer_setnumch(audio_numchannels);
-	    tracer_trace(playback_driver->get_play_rate(playback_driver_object), songpos, patpos);
+            g_assert (playback_driver!=NULL && playback_driver_object!=NULL && playback_driver->get_play_rate != NULL);
+            tracer_trace(playback_driver->get_play_rate(playback_driver_object), songpos, patpos);
 	    xmplayer_init_play_song(songpos, patpos, FALSE);
 	    
 	    for(i = 0; i < audio_numchannels; i++)
@@ -457,6 +461,7 @@
     audio_raise_priority();
 
   loop:
+    
     pfd[0].revents = 0;
 
     for(pl = inputs, npl = 1; pl; pl = pl->next, npl++) {
@@ -472,7 +477,7 @@
 	if(pi->condition & GDK_INPUT_WRITE)
 	    pfd[npl].events |= POLLOUT;
     }
-
+    
     if(poll(pfd, npl, -1) == -1) {
 	if(errno == EINTR)
 	    goto loop;
@@ -484,32 +489,46 @@
 	readpipe(ctlpipe, &c, sizeof(c));
 	switch(c) {
 	case AUDIO_CTLPIPE_INIT_PLAYER:
+            g_mutex_lock(mutex);
 	    audio_ctlpipe_init_player();
+            g_mutex_unlock(mutex);
 	    break;
 	case AUDIO_CTLPIPE_PLAY_SONG:
 	    readpipe(ctlpipe, a, 2 * sizeof(a[0]));
+            g_mutex_lock(mutex);
 	    audio_ctlpipe_play_song(a[0], a[1]);
+            g_mutex_unlock(mutex);
 	    break;
 	case AUDIO_CTLPIPE_PLAY_PATTERN:
 	    readpipe(ctlpipe, a, 3 * sizeof(a[0]));
+            g_mutex_lock(mutex);
 	    audio_ctlpipe_play_pattern(a[0], a[1], a[2]);
+            g_mutex_unlock(mutex);
 	    break;
 	case AUDIO_CTLPIPE_PLAY_NOTE:
 	    readpipe(ctlpipe, a, 3 * sizeof(a[0]));
+            g_mutex_lock(mutex);
 	    audio_ctlpipe_play_note(a[0], a[1], a[2]);
+            g_mutex_unlock(mutex);
 	    break;
 	case AUDIO_CTLPIPE_PLAY_NOTE_FULL:
 	    readpipe(ctlpipe, &a[0], 2 * sizeof(a[0]));
 	    readpipe(ctlpipe, &b, 1 * sizeof(b));
 	    readpipe(ctlpipe, &a[2], 2 * sizeof(a[0]));
+            g_mutex_lock(mutex);
 	    audio_ctlpipe_play_note_full(a[0], a[1], b, a[2], a[3]);
+            g_mutex_unlock(mutex);
 	    break;
 	case AUDIO_CTLPIPE_PLAY_NOTE_KEYOFF:
 	    readpipe(ctlpipe, a, 1 * sizeof(a[0]));
+            g_mutex_lock(mutex);
 	    audio_ctlpipe_play_note_keyoff(a[0]);
+            g_mutex_unlock(mutex);
 	    break;
 	case AUDIO_CTLPIPE_STOP_PLAYING:
+            g_mutex_lock(mutex);
 	    audio_ctlpipe_stop_playing();
+            g_mutex_unlock(mutex);
 	    break;
 	case AUDIO_CTLPIPE_RENDER_SONG_TO_FILE:
 	    readpipe(ctlpipe, a, sizeof(a[0]));
@@ -519,26 +538,36 @@
 		msgbuflen = a[0] + 1;
 	    }
 	    readpipe(ctlpipe, msgbuf, a[0] + 1);
+            g_mutex_lock(mutex);
 	    audio_ctlpipe_render_song_to_file(msgbuf);
+            g_mutex_unlock(mutex);
 	    break;
 	case AUDIO_CTLPIPE_SET_SONGPOS:
 	    read(ctlpipe, a, 1 * sizeof(a[0]));
+            g_mutex_lock(mutex);
 	    audio_ctlpipe_set_songpos(a[0]);
+            g_mutex_unlock(mutex);
 	    break;
 	case AUDIO_CTLPIPE_SET_PATTERN:
 	    read(ctlpipe, a, 1 * sizeof(a[0]));
+            g_mutex_lock(mutex);
 	    audio_ctlpipe_set_pattern(a[0]);
+            g_mutex_unlock(mutex);
 	    break;
 	case AUDIO_CTLPIPE_SET_AMPLIFICATION:
 	    read(ctlpipe, &af, sizeof(af));
+            g_mutex_lock(mutex);
 	    audio_ctlpipe_set_amplification(af);
+            g_mutex_unlock(mutex);
 	    break;
 	case AUDIO_CTLPIPE_SET_PITCHBEND:
 	    read(ctlpipe, &af, sizeof(af));
 	    pitchbend_req = af;
+            g_mutex_unlock(mutex);
 	    break;
 	case AUDIO_CTLPIPE_SET_MIXER:
 	    read(ctlpipe, &b, sizeof(b));
+            g_mutex_lock(mutex);
 	    mixer = b;
 	    if(playing) {
 		mixer->reset();
@@ -546,14 +575,19 @@
 		mixer->setnumch(audio_numchannels);
 	    }
 	    mixer->setampfactor(audio_ampfactor);
+            g_mutex_unlock(mutex);
 	    break;
 	case AUDIO_CTLPIPE_SET_TEMPO:
 	    readpipe(ctlpipe, a, 1 * sizeof(a[0]));
+            g_mutex_lock(mutex);
 	    audio_ctlpipe_set_tempo(a[0]);
+            g_mutex_unlock(mutex);
 	    break;
 	case AUDIO_CTLPIPE_SET_BPM:
 	    readpipe(ctlpipe, a, 1 * sizeof(a[0]));
+            g_mutex_lock(mutex);
 	    audio_ctlpipe_set_bpm(a[0]);
+            g_mutex_unlock(mutex);
 	    break;
 	default:
 	    fprintf(stderr, "\n\n*** audio_thread: unknown ctlpipe id %d\n\n\n", c);
@@ -616,6 +650,8 @@
     if(!(audio_bpm_ew = event_waiter_new()))
 	return FALSE;
 
+    mutex = g_mutex_new();
+
     if(0 == pthread_create(&threadid, NULL, (void*(*)(void*))audio_thread, NULL))
 	return TRUE;
 
@@ -635,6 +671,8 @@
 {
     g_assert(mixer != NULL);
 
+    g_assert(mixer->setmixformat != NULL);
+    
     mixfmt_conv = 0;
     mixfmt = 0;
 
@@ -1044,6 +1082,8 @@
 {
     int nonewtick = FALSE;
 
+    g_mutex_lock(mutex);
+
     // Set mixer parameters
     if(mixfmt_req != mixformat) {
 	mixfmt_req = mixformat;
@@ -1115,5 +1155,8 @@
 		confirm_bpm = 0;
 	    }
 	}
+
     }
+
+    g_mutex_unlock(mutex);
 }
diff -Naur soundtracker-0.6.8/app/audioconfig.c soundtracker-0.6.8-gtk2/app/audioconfig.c
--- soundtracker-0.6.8/app/audioconfig.c	2003-03-02 12:34:22.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/audioconfig.c	2010-09-23 11:11:35.000000000 +0200
@@ -3,6 +3,7 @@
  * The Real SoundTracker - Audio configuration dialog
  *
  * Copyright (C) 1999-2001 Michael Krause
+ * Copyright (C) 2005 Yury Aliaev (GTK+-2 porting)
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -22,6 +23,7 @@
 #include <config.h>
 
 #include <gtk/gtk.h>
+#include <glib/gprintf.h>
 #ifdef USE_GNOME
 #include <gnome.h>
 #endif
@@ -44,10 +46,7 @@
 GList *drivers[2] = { NULL, NULL };
 GList *mixers = NULL;
 
-static GtkWidget *configwindow = NULL;
-static GtkWidget *cw_clist, *cw_hbox, *audioconfig_mixer_clist;
-static int cw_currentobject = -1;
-static GtkWidget *driverwidget = NULL;
+static GtkWidget *audioconfig_mixer_list;
 static st_mixer *audioconfig_current_mixer = NULL;
 static gboolean audioconfig_disable_mixer_selection = FALSE;
 
@@ -57,6 +56,7 @@
     int type;
     void **driver_object;
     void **driver;
+    GtkWidget *drivernbook;
 } audio_object;
 
 static audio_object audio_objects[] = {
@@ -64,24 +64,29 @@
       "playback",
       DRIVER_OUTPUT,
       &playback_driver_object,
-      (void**)&playback_driver
+      (void**)&playback_driver,
+      NULL
     },
     { N_("Editing Output"),
       "editing",
       DRIVER_OUTPUT,
       &editing_driver_object,
-      (void**)&editing_driver
+      (void**)&editing_driver,
+      NULL
     },
     { N_("Sampling"),
       "sampling",
       DRIVER_INPUT,
       &sampling_driver_object,
-      (void**)&sampling_driver
+      (void**)&sampling_driver,
+      NULL
     }
 };
 
 #define NUM_AUDIO_OBJECTS (sizeof(audio_objects) / sizeof(audio_objects[0]))
 
+static void ***audio_driver_objects[NUM_AUDIO_OBJECTS];
+
 static void
 audioconfig_driver_load_config (audio_object *ao)
 {
@@ -90,7 +95,7 @@
     prefs_node *f;
 
     if(d->loadsettings) {
-	sprintf(buf, "audio-object-%s", ao->shorttitle);
+	g_sprintf(buf, "audio-object-%s", ao->shorttitle);
 	f = prefs_open_read(buf);
 	if(f) {
 	    d->loadsettings(*ao->driver_object, f);
@@ -103,30 +108,31 @@
 }
 
 static void
-audioconfig_clist_select (GtkCList *list,
-			  gint row,
-			  gint column)
+audioconfig_list_select (GtkTreeSelection *sel, guint page)
 {
-    if(cw_currentobject != -1) {
-	audio_object *object = &audio_objects[cw_currentobject];
+    GtkTreeModel *mdl;
+    GtkTreeIter iter;
+    gchar *str;
+    
+    if(gtk_tree_selection_get_selected(sel, &mdl, &iter)) {
+
+	guint row = atoi(str = gtk_tree_model_get_string_from_iter(mdl, &iter));
+	audio_object *object = &audio_objects[page];
 	st_driver *old_driver = *object->driver;
-	void *old_driver_object = *object->driver_object;
 	st_driver *new_driver = g_list_nth_data(drivers[object->type], row);
-	GtkWidget *new_driverwidget;
 
-	if(new_driver != old_driver) {
-	    prefs_node *f;
-	    char buf[256];
+	g_free(str);
 
+	if(new_driver != old_driver) {
 	    // stop playing and sampling here
 	    sample_editor_stop_sampling();
 	    gui_play_stop();
 
 	    // get new driver object
-	    *object->driver_object = new_driver->new();
+	    *object->driver_object = audio_driver_objects[page][row];
 	    *object->driver = new_driver;
 
-	    /* Load object settings, if there are saved settings. */
+	    /* Load object settings, if there are saved settings.
 	    f = prefs_open_read("audio-objects");
 	    if(f) {
 		if(prefs_get_string(f, object->shorttitle, buf)) {
@@ -135,92 +141,36 @@
 		    }
 		}
 		prefs_close(f);
-	    }
+	    }*/
 	}
-
-	new_driverwidget = new_driver->getwidget(*object->driver_object);
-
-	if(new_driverwidget != driverwidget) {
-	    if(driverwidget) {
-		gtk_container_remove(GTK_CONTAINER(cw_hbox), driverwidget);
-	    }
-	    driverwidget = new_driverwidget;
-	    gtk_widget_show(driverwidget);
-	    /* we don't want the widget to be destroyed upon removal... */
-	    gtk_object_ref(GTK_OBJECT(driverwidget));
-	    gtk_box_pack_start(GTK_BOX(cw_hbox), driverwidget, TRUE, FALSE, 0);
-	}
-
-	if(new_driver != old_driver) {
-	    // free old driver object
-	    old_driver->destroy(old_driver_object);
-	}
-    } else {
-	// The CList is being updated
+	gtk_notebook_set_current_page(GTK_NOTEBOOK(object->drivernbook), row);
     }
 }
 
 static void
-audioconfig_object_changed (void *a,
-			    void *b)
+audioconfig_close_requested (GtkWidget *window)
 {
-    unsigned n = GPOINTER_TO_INT(b);
-    GList *l;
-    gchar *insertbuf[2] = { NULL };
-    int i, active = -1;
-
-    g_assert(n < NUM_AUDIO_OBJECTS);
-
-    if(n == cw_currentobject)
-	return;
-
-    cw_currentobject = -1; // disable clist select callback
-
-    gtk_clist_freeze(GTK_CLIST(cw_clist));
-    gtk_clist_clear(GTK_CLIST(cw_clist));
-    for(i = 0, l = drivers[audio_objects[n].type]; l; i++, l = l->next) {
-	insertbuf[0] = *((gchar **)l->data);
-	if(l->data == *audio_objects[n].driver)
-	    active = i;
-	gtk_clist_append(GTK_CLIST(cw_clist), insertbuf);
-    }
-    gtk_clist_thaw(GTK_CLIST(cw_clist));
-
-    // Now update the GUI
-    cw_currentobject = n;
-    if(driverwidget) {
-	gtk_container_remove(GTK_CONTAINER(cw_hbox), driverwidget);
-	driverwidget = NULL;
-    }
-
-    if(active != -1) {
-	gtk_clist_select_row(GTK_CLIST(cw_clist), active, 0);
-    }
+    gtk_widget_hide(window);
 }
 
 static void
-audioconfig_close_requested (void)
+audioconfig_mixer_selected (GtkTreeSelection *sel)
 {
-    if(driverwidget) {
-	gtk_container_remove(GTK_CONTAINER(cw_hbox), driverwidget);
-	gtk_widget_hide(driverwidget);
-	driverwidget = NULL;
-    }
-    gtk_widget_destroy(configwindow);
-    configwindow = NULL;
-    cw_currentobject = -1;
-}
+    GtkTreeModel *mdl;
+    GtkTreeIter iter;
+    gchar *str;
+    
+    if(gtk_tree_selection_get_selected(sel, &mdl, &iter)) {
 
-static void
-audioconfig_mixer_selected (GtkCList *list,
-			    gint row,
-			    gint column)
-{
-    st_mixer *new_mixer = g_list_nth_data(mixers, row);
+	guint row = atoi(str = gtk_tree_model_get_string_from_iter(mdl, &iter));
+	st_mixer *new_mixer = g_list_nth_data(mixers, row);
+
+	g_free(str);
 
-    if(!audioconfig_disable_mixer_selection && new_mixer != audioconfig_current_mixer) {
-	audio_set_mixer(new_mixer);
-	audioconfig_current_mixer = new_mixer;
+	if(!audioconfig_disable_mixer_selection && new_mixer != audioconfig_current_mixer) {
+	    audio_set_mixer(new_mixer);
+	    audioconfig_current_mixer = new_mixer;
+	}
     }
 }
 
@@ -230,31 +180,86 @@
     GList *l;
     gchar *insertbuf[2] = { NULL };
     int i, active = -1;
+    GtkListStore *list_store = GUI_GET_LIST_STORE(audioconfig_mixer_list);
+    GtkTreeIter iter;
+    GtkTreeModel *model;
 
     audioconfig_disable_mixer_selection = TRUE;
-    gtk_clist_freeze(GTK_CLIST(audioconfig_mixer_clist));
-    gtk_clist_clear(GTK_CLIST(audioconfig_mixer_clist));
+    model = gui_list_freeze(audioconfig_mixer_list);
+    gui_list_clear_with_model(model);
     for(i = 0, l = mixers; l; i++, l = l->next) {
 	st_mixer *mixer = l->data;
 	if(mixer == audioconfig_current_mixer) {
 	    active = i;
 	}
-	insertbuf[0] = (gchar*)mixer->id;
-	insertbuf[1] = gettext((gchar*)mixer->description);
-	gtk_clist_append(GTK_CLIST(audioconfig_mixer_clist), insertbuf);
+	gtk_list_store_append(list_store, &iter);
+	gtk_list_store_set(list_store, &iter, 0, (gchar*)mixer->id,
+			   1, gettext((gchar*)mixer->description), -1);
     }
-    gtk_clist_thaw(GTK_CLIST(audioconfig_mixer_clist));
+    gui_list_thaw(audioconfig_mixer_list, model);
     audioconfig_disable_mixer_selection = FALSE;
 
-    gtk_clist_select_row(GTK_CLIST(audioconfig_mixer_clist), active, 0);
+    gui_list_select(audioconfig_mixer_list, active);
+}
+
+static void
+audioconfig_notebook_add_page (GtkNotebook *nbook, guint n)
+{
+    GtkWidget	*label, *box1, *list, *widget, *dnbook, *alignment;
+    GList *l;
+    guint i, active = -1;
+    static gchar *listtitles[1];
+    GtkListStore *list_store;
+    GtkTreeIter iter;
+
+    listtitles[0] = gettext("Driver Module");
+
+    box1 = gtk_hbox_new(FALSE, 4);
+    gtk_widget_show(box1);
+
+    // Driver selection list
+    list = gui_stringlist_in_scrolled_window(1, listtitles, box1);
+    gtk_widget_set_size_request(list, 200, -1);
+    list_store = GUI_GET_LIST_STORE(list);
+
+    /* Driver configuration widgets' notebook (with hidden tabs, as multi-layer container) */
+    audio_objects[n].drivernbook = dnbook = gtk_notebook_new();
+    gtk_notebook_set_show_tabs(GTK_NOTEBOOK(dnbook), FALSE);
+    gtk_notebook_set_show_border(GTK_NOTEBOOK(dnbook), FALSE);
+    gtk_widget_show(dnbook);
+    gtk_box_pack_start(GTK_BOX(box1), dnbook, TRUE, TRUE, 0);
+
+    for(i = 0, l = drivers[audio_objects[n].type]; l; i++, l = l->next) {
+	st_out_driver *driver = l->data;
+	gtk_list_store_append(list_store, &iter);
+	gtk_list_store_set(list_store, &iter, 0, *((gchar **)l->data), -1);
+
+	if(driver == *audio_objects[n].driver)
+	    active = i;
+	widget = driver->common.getwidget(audio_driver_objects[n][i]);
+	alignment = gtk_alignment_new(0.4, 0.5, 0.0, 0.0);
+	gtk_container_add(GTK_CONTAINER(alignment), widget);
+	gtk_notebook_append_page(GTK_NOTEBOOK(dnbook), alignment, NULL);
+	gtk_widget_show_all(alignment);
+    }
+    
+    gui_list_handle_selection(list, G_CALLBACK(audioconfig_list_select), (gpointer)n);
+    if(active != -1) {
+	gui_list_select(list, active);
+    }
+
+    label = gtk_label_new(gettext(audio_objects[n].title));
+    gtk_widget_show(label);
+
+    gtk_notebook_append_page(nbook, box1, label);
 }
 
 void
 audioconfig_dialog (void)
 {
-    GtkWidget *mainbox, *thing, *box1, *hbox, *frame, *box2;
-    OptionMenuItem menu1[NUM_AUDIO_OBJECTS];
-    static gchar *listtitles[1];
+    static GtkWidget *configwindow = NULL;
+    GtkWidget *mainbox, *thing, *hbox, *nbook, *box2, *frame;
+	static gchar *listtitles[1];
     static gchar *listtitles2[2];
     int i;
 
@@ -263,6 +268,8 @@
     listtitles2[1] = gettext("Description");
 
     if(configwindow != NULL) {
+	if(!GTK_WIDGET_VISIBLE(configwindow))
+	    gtk_widget_show(configwindow);
 	gdk_window_raise(configwindow->window);
 	return;
     }
@@ -273,8 +280,8 @@
     configwindow = gtk_window_new(GTK_WINDOW_TOPLEVEL);
     gtk_window_set_title(GTK_WINDOW(configwindow), _("Audio Configuration"));
 #endif
-    gtk_signal_connect (GTK_OBJECT (configwindow), "delete_event",
-			GTK_SIGNAL_FUNC (audioconfig_close_requested), NULL);
+    g_signal_connect_swapped (configwindow, "delete_event",
+			G_CALLBACK (audioconfig_close_requested), configwindow);
 
     mainbox = gtk_vbox_new(FALSE, 2);
     gtk_container_border_width(GTK_CONTAINER(mainbox), 4);
@@ -285,41 +292,13 @@
 #endif
     gtk_widget_show(mainbox);
 
-    frame = gtk_frame_new(NULL);
-    gtk_frame_set_label(GTK_FRAME(frame), _("Drivers"));
-    gtk_box_pack_start(GTK_BOX(mainbox), frame, FALSE, TRUE, 0);
-    gtk_widget_show(frame);
-
-    box2 = gtk_vbox_new(FALSE, 2);
-    gtk_widget_show(box2);
-    gtk_container_add (GTK_CONTAINER(frame), box2);
-    gtk_container_border_width(GTK_CONTAINER(box2), 4);
-
-    // Driver type selector
+    // Each driver (playback,capture,editing,etc...) occupies the notebook page
+    nbook = gtk_notebook_new();
+    gtk_box_pack_start(GTK_BOX(mainbox), nbook, FALSE, TRUE, 0);
     for(i = 0; i < NUM_AUDIO_OBJECTS; i++) {
-	menu1[i].name = gettext(audio_objects[i].title);
-	menu1[i].func = audioconfig_object_changed;
+	audioconfig_notebook_add_page(GTK_NOTEBOOK(nbook), i);
     }
-    thing = gui_build_option_menu(menu1, NUM_AUDIO_OBJECTS, 0);
-    gtk_widget_show(thing);
-    gtk_box_pack_start(GTK_BOX(box2), thing, FALSE, FALSE, 0);
-
-    cw_hbox = box1 = gtk_hbox_new(FALSE, 4);
-    gtk_widget_show(box1);
-    gtk_box_pack_start(GTK_BOX(box2), box1, TRUE, TRUE, 0);
-
-    // Driver selection list
-    thing = gui_clist_in_scrolled_window(1, listtitles, box1);
-    gtk_clist_set_selection_mode(GTK_CLIST(thing), GTK_SELECTION_BROWSE);
-    gtk_clist_column_titles_passive(GTK_CLIST(thing));
-    gtk_clist_set_column_justification(GTK_CLIST(thing), 0, GTK_JUSTIFY_LEFT);
-    gtk_widget_set_usize(thing, 200, 50);
-    gtk_signal_connect_after(GTK_OBJECT(thing), "select_row",
-			     GTK_SIGNAL_FUNC(audioconfig_clist_select), NULL);
-    cw_clist = thing;
-
-    audioconfig_object_changed(NULL, (void*)0);
-
+    gtk_widget_show(nbook);
 
     // Mixer selection
     frame = gtk_frame_new(NULL);
@@ -332,13 +311,9 @@
     gtk_container_add (GTK_CONTAINER(frame), box2);
     gtk_container_border_width(GTK_CONTAINER(box2), 4);
 
-    thing = gui_clist_in_scrolled_window(2, listtitles2, box2);
-    gtk_clist_set_selection_mode(GTK_CLIST(thing), GTK_SELECTION_BROWSE);
-    gtk_clist_column_titles_passive(GTK_CLIST(thing));
-    gtk_clist_set_column_justification(GTK_CLIST(thing), 0, GTK_JUSTIFY_LEFT);
-    gtk_signal_connect_after(GTK_OBJECT(thing), "select_row",
-			     GTK_SIGNAL_FUNC(audioconfig_mixer_selected), NULL);
-    audioconfig_mixer_clist = thing;
+    thing = gui_stringlist_in_scrolled_window(2, listtitles2, box2);
+    gui_list_handle_selection(thing, G_CALLBACK(audioconfig_mixer_selected), NULL);
+    audioconfig_mixer_list = thing;
     audioconfig_initialize_mixer_list();
 
     /* The button area */
@@ -346,27 +321,23 @@
     gtk_widget_show(thing);
     gtk_box_pack_start(GTK_BOX(mainbox), thing, FALSE, TRUE, 0);
 
-    hbox = gtk_hbutton_box_new ();
-    gtk_button_box_set_spacing (GTK_BUTTON_BOX (hbox), 4);
-    gtk_button_box_set_layout (GTK_BUTTON_BOX (hbox), GTK_BUTTONBOX_END);
-    gtk_box_pack_start (GTK_BOX (mainbox), hbox,
+    hbox = gtk_hbutton_box_new();
+    gtk_button_box_set_spacing(GTK_BUTTON_BOX (hbox), 4);
+    gtk_button_box_set_layout(GTK_BUTTON_BOX (hbox), GTK_BUTTONBOX_END);
+    gtk_box_pack_start(GTK_BOX (mainbox), hbox,
 			FALSE, FALSE, 0);
-    gtk_widget_show (hbox);
+    gtk_widget_show(hbox);
 
-#ifdef USE_GNOME
-    thing = gnome_stock_button (GNOME_STOCK_BUTTON_CLOSE);
-#else
-    thing = gtk_button_new_with_label (_ ("Close"));
-#endif
+    thing = gtk_button_new_from_stock(GTK_STOCK_CLOSE);
     GTK_WIDGET_SET_FLAGS(thing, GTK_CAN_DEFAULT);
     gtk_window_set_default(GTK_WINDOW(configwindow), thing);
-    gtk_signal_connect (GTK_OBJECT (thing), "clicked",
-			GTK_SIGNAL_FUNC (audioconfig_close_requested), NULL);
-    gtk_box_pack_start (GTK_BOX (hbox), thing, FALSE, FALSE, 0);
-    gtk_widget_show (thing);
+    g_signal_connect_swapped(thing, "clicked",
+			G_CALLBACK(audioconfig_close_requested), configwindow);
+    gtk_box_pack_start(GTK_BOX (hbox), thing, FALSE, FALSE, 0);
+    gtk_widget_show(thing);
 
 
-    gtk_widget_show (configwindow);
+    gtk_widget_show(configwindow);
 }
 
 void
@@ -375,13 +346,15 @@
     char buf[256];
     prefs_node *f;
     GList *l;
-    int i;
+    guint i, n = 0;
 
     f = prefs_open_read("audio-objects");
     if(f) {
 	for(i = 0; i < NUM_AUDIO_OBJECTS; i++) {
+	    guint j;
+
 	    if(prefs_get_string(f, audio_objects[i].shorttitle, buf)) {
-		for(l = drivers[audio_objects[i].type]; l; l = l->next) {
+		for(j = 0, l = drivers[audio_objects[i].type]; l; l = l->next, j++) {
 		    if(!strcmp(*((gchar **)l->data), buf)) {
 			*audio_objects[i].driver = l->data;
 			break;
@@ -393,20 +366,30 @@
     }
 
     for(i = 0; i < NUM_AUDIO_OBJECTS; i++) {
-	st_driver *d = *audio_objects[i].driver;
-
-	if(!d) {
-	    // set default driver if none has been configured
-	    if(drivers[audio_objects[i].type] != NULL) {
-		d = *audio_objects[i].driver = drivers[audio_objects[i].type]->data;
-	    }
-	}
-
-	if(d) {
-	    // create driver instance
-	    *audio_objects[i].driver_object = d->new();
-	    audioconfig_driver_load_config(&audio_objects[i]);
-	}
+        guint j;
+        st_driver *d = *audio_objects[i].driver;
+        
+        audio_driver_objects[i] = g_new(void**,
+                                          g_list_length(drivers[audio_objects[i].type]));
+        for(j = 0, l = drivers[audio_objects[i].type]; l; j++, l = l->next) {
+            st_driver *driver = l->data;
+            audio_driver_objects[i][j] = driver->new();
+            if (*audio_objects[i].driver == l->data)
+                n = j;
+        }
+        
+        if(!d) {
+            // set default driver if none has been configured
+            if(drivers[audio_objects[i].type] != NULL) {
+                d = *audio_objects[i].driver = drivers[audio_objects[i].type]->data;
+            }
+        }
+        
+        if(d) {
+            // create driver instance
+            *audio_objects[i].driver_object = audio_driver_objects[i][n];
+            audioconfig_driver_load_config(&audio_objects[i]);
+        }
     }
 }
 
@@ -461,7 +444,7 @@
 	gboolean (*savesettings)(void *, prefs_node *) = ((st_driver*)*(audio_objects[i].driver))->savesettings;
 
 	if(savesettings) {
-	    sprintf(buf, "audio-object-%s", audio_objects[i].shorttitle);
+	    g_sprintf(buf, "audio-object-%s", audio_objects[i].shorttitle);
 	    f = prefs_open_write(buf);
 	    if(f) {
 		savesettings(*audio_objects[i].driver_object, f);
diff -Naur soundtracker-0.6.8/app/audioconfig.h soundtracker-0.6.8-gtk2/app/audioconfig.h
--- soundtracker-0.6.8/app/audioconfig.h	2001-01-03 14:24:07.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/audioconfig.h	2010-09-23 11:11:35.000000000 +0200
@@ -29,6 +29,7 @@
 void        audioconfig_load_config              (void);
 void        audioconfig_load_mixer_config        (void);
 void        audioconfig_save_config              (void);
+void	    audioconfig_shutdown		 (void);
 
 // Currently initialized in main.c
 extern GList *drivers[2];
diff -Naur soundtracker-0.6.8/app/cheat-sheet.c soundtracker-0.6.8-gtk2/app/cheat-sheet.c
--- soundtracker-0.6.8/app/cheat-sheet.c	2004-01-04 16:57:21.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/cheat-sheet.c	2010-09-23 11:11:35.000000000 +0200
@@ -19,8 +19,10 @@
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+#define GTK_ENABLE_BROKEN
 #include <config.h>
 
+#include <gtk/gtktext.h>
 #include <gtk/gtk.h>
 #ifdef USE_GNOME
 #include <gnome.h>
@@ -88,7 +90,10 @@
 cheat_sheet_dialog (void)
 {
     GtkWidget *mainbox, *scrolled_window, *text, *hbox, *thing;
-    GdkFont *font;
+    PangoFontDescription *font;
+    GtkTextBuffer * textbuffer;
+    GtkTextIter   iter;
+
 
     if(cheat_sheet_window != NULL) {
 	gdk_window_raise(cheat_sheet_window->window);
@@ -101,7 +106,7 @@
     cheat_sheet_window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
     gtk_window_set_title(GTK_WINDOW(cheat_sheet_window), _("XM Effects Cheat Sheet"));
 #endif
-    gtk_signal_connect (GTK_OBJECT (cheat_sheet_window), "delete_event",
+    g_signal_connect (GTK_OBJECT (cheat_sheet_window), "delete_event",
 			GTK_SIGNAL_FUNC (cheat_sheet_close_requested), NULL);
 
     mainbox = gtk_vbox_new(FALSE, 2);
@@ -132,34 +137,31 @@
 			FALSE, FALSE, 0);
     gtk_widget_show (hbox);
 
-#ifdef USE_GNOME
-    thing = gnome_stock_button (GNOME_STOCK_BUTTON_CLOSE);
-#else
-    thing = gtk_button_new_with_label (_ ("Close"));
-#endif
+    thing = gtk_button_new_from_stock (GTK_STOCK_CLOSE);
     GTK_WIDGET_SET_FLAGS(thing, GTK_CAN_DEFAULT);
     gtk_window_set_default(GTK_WINDOW(cheat_sheet_window), thing);
-    gtk_signal_connect (GTK_OBJECT (thing), "clicked",
+    g_signal_connect (GTK_OBJECT (thing), "clicked",
 			GTK_SIGNAL_FUNC (cheat_sheet_close_requested), NULL);
     gtk_box_pack_start (GTK_BOX (hbox), thing, FALSE, FALSE, 0);
     gtk_widget_show (thing);
 
-    text = gtk_text_new (NULL, NULL);
-    gtk_text_set_editable (GTK_TEXT (text), FALSE);
-    gtk_text_set_word_wrap (GTK_TEXT (text), FALSE);
-    gtk_container_add (GTK_CONTAINER (scrolled_window), text);
-    gtk_widget_grab_focus (text);
-    gtk_widget_show (text);
-    gtk_widget_set_usize(text, 42 * 12, 46 * 12);
+    text = gtk_text_view_new();
+
+    font = pango_font_description_from_string("monospace");
 
-    font = gdk_font_load ("-adobe-courier-medium-r-normal--*-120-*-*-*-*-*-*");
+    gtk_widget_modify_font(GTK_WIDGET(text), font);
 
-    gtk_text_insert(GTK_TEXT(text), font, NULL, NULL, cheat_sheet_string, -1);
+    textbuffer = gtk_text_view_get_buffer (GTK_TEXT_VIEW (text));
+    gtk_text_buffer_get_iter_at_offset (textbuffer, &iter, 0);  
 
-    /* The Text widget will reference count the font, so we
-     * unreference it here
-     */
-    gdk_font_unref (font);
+    gtk_text_view_set_editable (GTK_TEXT_VIEW (text), FALSE);
+    gtk_text_view_set_wrap_mode (GTK_TEXT_VIEW (text), FALSE);
+    gtk_container_add (GTK_CONTAINER (scrolled_window), text);
+    gtk_widget_grab_focus (text);
+    gtk_widget_show (text);
+    gtk_widget_set_usize(text, 42 * 16, 46 * 16);
 
+    gtk_text_buffer_insert (textbuffer, &iter, cheat_sheet_string, -1); 
+    
     gtk_widget_show (cheat_sheet_window);
 }
diff -Naur soundtracker-0.6.8/app/clavier.c soundtracker-0.6.8-gtk2/app/clavier.c
--- soundtracker-0.6.8/app/clavier.c	2001-08-12 11:38:35.000000000 +0200
+++ soundtracker-0.6.8-gtk2/app/clavier.c	2010-09-23 11:11:35.000000000 +0200
@@ -59,7 +59,7 @@
   LAST_SIGNAL
 };
 
-static gint clavier_signals[LAST_SIGNAL] = {0};
+static guint clavier_signals[LAST_SIGNAL] = {0};
 
 typedef void (*ClavierSignal1) (GtkObject *object,
 				gint arg1,
@@ -90,18 +90,20 @@
 
   if (!clavier_type)
     {
-      GtkTypeInfo clavier_info = {
-	"Clavier",
-	sizeof (Clavier),
+      GTypeInfo clavier_info = {
 	sizeof (ClavierClass),
-	(GtkClassInitFunc) clavier_class_init,
-	(GtkObjectInitFunc) clavier_init,
-	(GtkArgSetFunc) NULL,
-	(GtkArgGetFunc) NULL,
+	(GBaseInitFunc) NULL,
+	(GBaseFinalizeFunc) NULL,
+	(GClassInitFunc) clavier_class_init,
+	(GClassFinalizeFunc) NULL,
+	NULL,
+	sizeof (Clavier),
+	0,
+	(GInstanceInitFunc) clavier_init,	
       };
 
-      clavier_type = gtk_type_unique (gtk_drawing_area_get_type (), 
-				      &clavier_info);
+      clavier_type = g_type_register_static(gtk_drawing_area_get_type (), 
+			 "Clavier", &clavier_info, (GTypeFlags)0);
     }
 
   return clavier_type;
@@ -110,41 +112,49 @@
 static void
 clavier_class_init (ClavierClass *class)
 {
-  GtkObjectClass *object_class;
+  GObjectClass *object_class;
+  GtkObjectClass *gtkobject_class;
   GtkWidgetClass *widget_class;
 
-  object_class = (GtkObjectClass *) class;
+  object_class = (GObjectClass *) class;
+  gtkobject_class = (GtkObjectClass *) class;
   widget_class = (GtkWidgetClass *) class;
 
   parent_class = gtk_type_class (gtk_drawing_area_get_type ());
 
   clavier_signals[CLAVIERKEY_PRESS] = 
-    gtk_signal_new ("clavierkey_press", GTK_RUN_FIRST, object_class->type,
-		    GTK_SIGNAL_OFFSET (ClavierClass, clavierkey_press),
-		    gtk_marshal_NONE__INT, GTK_TYPE_NONE, 1, 
-		    GTK_TYPE_INT);
+    g_signal_new ("clavierkey_press", G_TYPE_FROM_CLASS (object_class),
+		   (GSignalFlags) G_SIGNAL_RUN_FIRST,
+		    G_STRUCT_OFFSET (ClavierClass, clavierkey_press),
+		    NULL, NULL,
+		    gtk_marshal_NONE__INT, G_TYPE_NONE, 1, 
+		    G_TYPE_INT);
 
   clavier_signals[CLAVIERKEY_RELEASE] = 
-    gtk_signal_new ("clavierkey_release", GTK_RUN_FIRST, object_class->type,
-		    GTK_SIGNAL_OFFSET (ClavierClass, clavierkey_release),
-		    gtk_marshal_NONE__INT, GTK_TYPE_NONE, 1,
-		    GTK_TYPE_INT);
+    g_signal_new ("clavierkey_release", G_TYPE_FROM_CLASS (object_class),
+		   (GSignalFlags) G_SIGNAL_RUN_FIRST,
+		    G_STRUCT_OFFSET (ClavierClass, clavierkey_release),
+		    NULL, NULL,
+		    gtk_marshal_NONE__INT, G_TYPE_NONE, 1,
+		    G_TYPE_INT);
 
   clavier_signals[CLAVIERKEY_ENTER] = 
-    gtk_signal_new ("clavierkey_enter", GTK_RUN_FIRST, object_class->type,
-		    GTK_SIGNAL_OFFSET (ClavierClass, clavierkey_enter),
-		    gtk_marshal_NONE__INT, GTK_TYPE_NONE, 1,
-		    GTK_TYPE_INT);
+    g_signal_new ("clavierkey_enter", G_TYPE_FROM_CLASS (object_class),
+		   (GSignalFlags) G_SIGNAL_RUN_FIRST,
+		    G_STRUCT_OFFSET (ClavierClass, clavierkey_enter),
+		    NULL, NULL,
+		    gtk_marshal_NONE__INT, G_TYPE_NONE, 1,
+		    G_TYPE_INT);
 
   clavier_signals[CLAVIERKEY_LEAVE] = 
-    gtk_signal_new ("clavierkey_leave", GTK_RUN_FIRST, object_class->type,
-		    GTK_SIGNAL_OFFSET (ClavierClass, clavierkey_leave),
-		    gtk_marshal_NONE__INT, GTK_TYPE_NONE, 1,
-		    GTK_TYPE_INT);
-
-  gtk_object_class_add_signals (object_class, clavier_signals, LAST_SIGNAL);
+    g_signal_new ("clavierkey_leave", G_TYPE_FROM_CLASS (object_class),
+		   (GSignalFlags) G_SIGNAL_RUN_FIRST,
+		    G_STRUCT_OFFSET (ClavierClass, clavierkey_leave),
+		    NULL, NULL,
+		    gtk_marshal_NONE__INT, G_TYPE_NONE, 1,
+		    G_TYPE_INT);
 
-  object_class->destroy = clavier_destroy;
+  gtkobject_class->destroy = clavier_destroy;
 
   widget_class->realize = clavier_realize;
   widget_class->expose_event = clavier_expose;
@@ -196,7 +206,7 @@
   clavier = CLAVIER (object);
 
   /* eventually free memory allocated for key info
-   */
+    FIXME: something is wrong here
 
   if (clavier->key_info)
     {
@@ -205,6 +215,7 @@
 
   if (GTK_OBJECT_CLASS (parent_class)->destroy)
     (*GTK_OBJECT_CLASS (parent_class)->destroy) (object);
+   */
 }
 
 /* checks if the given key is a black one
@@ -923,7 +934,7 @@
 {
   Clavier *clavier;
 
-  clavier = gtk_type_new (clavier_get_type ());
+  clavier = g_object_new (clavier_get_type (), NULL);
 
   /*  old_mask = gtk_widget_get_events (GTK_WIDGET (clavier)); */
   /*  gtk_widget_set_events (GTK_WIDGET (clavier), old_mask |  */
diff -Naur soundtracker-0.6.8/app/drivers/alsa2-input.c soundtracker-0.6.8-gtk2/app/drivers/alsa2-input.c
--- soundtracker-0.6.8/app/drivers/alsa2-input.c	2001-01-03 14:24:11.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/drivers/alsa2-input.c	2010-09-23 11:11:35.000000000 +0200
@@ -37,6 +37,7 @@
 #include <sys/time.h>
 
 #include <glib.h>
+#include <glib/gprintf.h>
 #include <gtk/gtk.h>
 
 #include "i18n.h"
@@ -120,12 +121,12 @@
 static void
 prefs_update_estimate (alsa_driver *d)
 {
-    char buf[64];
+    char buf[128];
 
-    sprintf(buf, _("(%d bytes)"), d->p_fragsize * d->p_channels * d->p_resolution / 8);
+    g_sprintf(buf, _("(%d bytes)"), d->p_fragsize * d->p_channels * d->p_resolution / 8);
     gtk_label_set_text(GTK_LABEL(d->bufsizelabel_w), buf);
     
-    sprintf(buf, _("Estimated audio delay: %f microseconds"), (double)(1000 * d->p_fragsize / d->p_mixfreq));
+    g_sprintf(buf, _("Estimated audio delay: %f microseconds"), (double)(1000 * d->p_fragsize / d->p_mixfreq));
     gtk_label_set_text(GTK_LABEL(d->estimatelabel_w), buf);
 }
 
@@ -244,8 +245,8 @@
     d->bufsizespin_w = thing = gtk_spin_button_new(GTK_ADJUSTMENT(gtk_adjustment_new(d->fragsize, 64.0, 16384.0, 64.0, 0.0, 0.0)), 0, 0);
     gtk_box_pack_start(GTK_BOX(box3), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect (GTK_OBJECT(thing), "changed",
-			GTK_SIGNAL_FUNC(prefs_fragsize_changed), d);
+    g_signal_connect(thing, "value-changed",
+			G_CALLBACK(prefs_fragsize_changed), d);
 
     d->bufsizelabel_w = thing = gtk_label_new("");
     gtk_box_pack_start(GTK_BOX(box3), thing, FALSE, TRUE, 0);
@@ -273,8 +274,8 @@
     d->alsacardspin_w = alsa_card = gtk_spin_button_new(GTK_ADJUSTMENT(gtk_adjustment_new(d->card_number, 0.0, 256.0, 1.0, 1.0, 0.0)), 0, 0);
     gtk_box_pack_start(GTK_BOX(box2), alsa_card, FALSE, TRUE, 0);
     gtk_widget_show(alsa_card);
-    gtk_signal_connect (GTK_OBJECT(alsa_card), "changed",
-			GTK_SIGNAL_FUNC(prefs_alsacard_changed), d);
+    g_signal_connect(alsa_card, "value-changed",
+			G_CALLBACK(prefs_alsacard_changed), d);
 
     box2 = gtk_hbox_new(FALSE, 4);
     gtk_widget_show(box2);
@@ -288,8 +289,8 @@
     d->alsadevicespin_w = alsa_device = gtk_spin_button_new(GTK_ADJUSTMENT(gtk_adjustment_new(d->device_number, 0.0, 256.0, 1.0, 1.0, 0.0)), 0, 0);
     gtk_box_pack_start(GTK_BOX(box2), alsa_device, FALSE, TRUE, 0);
     gtk_widget_show(alsa_device);
-    gtk_signal_connect (GTK_OBJECT(alsa_device), "changed",
-			GTK_SIGNAL_FUNC(prefs_alsadevice_changed), d);
+    g_signal_connect(alsa_device, "value-changed",
+			G_CALLBACK(prefs_alsadevice_changed), d);
 
     prefs_init_from_structure(d);
 }
@@ -372,7 +373,7 @@
     err = snd_pcm_open(&(d->soundfd), d->card_number, d->device_number, SND_PCM_OPEN_CAPTURE);
     if (err != 0) {
 	char buf[256];
-	sprintf(buf, _("Couldn't open ALSA device for sound output (card:%d, device:%d):\n%s"), 
+	g_sprintf(buf, _("Couldn't open ALSA device for sound output (card:%d, device:%d):\n%s"), 
 		d->card_number, d->device_number, snd_strerror(err));
 	error_error(buf);
 	goto out;
diff -Naur soundtracker-0.6.8/app/drivers/alsa2-output.c soundtracker-0.6.8-gtk2/app/drivers/alsa2-output.c
--- soundtracker-0.6.8/app/drivers/alsa2-output.c	2006-02-25 13:30:54.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/drivers/alsa2-output.c	2010-09-23 11:11:35.000000000 +0200
@@ -36,6 +36,7 @@
 #include <sys/time.h>
 
 #include <glib.h>
+#include <glib/gprintf.h>
 #include <gtk/gtk.h>
 
 #include "i18n.h"
@@ -130,12 +131,12 @@
 static void
 prefs_update_estimate (alsa_driver *d)
 {
-    char buf[64];
+    char buf[128];
 
-    sprintf(buf, _("(%d bytes)"), d->p_fragsize * d->p_channels * d->p_resolution / 8);
+    g_sprintf(buf, _("(%d bytes)"), d->p_fragsize * d->p_channels * d->p_resolution / 8);
     gtk_label_set_text(GTK_LABEL(d->bufsizelabel_w), buf);
     
-    sprintf(buf, _("Estimated audio delay: %f milliseconds"), (1000.0 * (double)(d->p_fragsize) / d->p_mixfreq));
+    g_sprintf(buf, _("Estimated audio delay: %f milliseconds"), (1000.0 * (double)(d->p_fragsize) / d->p_mixfreq));
     gtk_label_set_text(GTK_LABEL(d->estimatelabel_w), buf);
 }
 
@@ -249,8 +250,8 @@
     d->bufsizespin_w = thing = gtk_spin_button_new(GTK_ADJUSTMENT(gtk_adjustment_new(d->fragsize, 64.0, 16384.0, 64.0, 0.0, 0.0)), 0, 0);
     gtk_box_pack_start(GTK_BOX(box3), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect (GTK_OBJECT(thing), "changed",
-			GTK_SIGNAL_FUNC(prefs_fragsize_changed), d);
+    g_signal_connect(thing, "value-changed",
+			G_CALLBACK(prefs_fragsize_changed), d);
 
     d->bufsizelabel_w = thing = gtk_label_new("");
     gtk_box_pack_start(GTK_BOX(box3), thing, FALSE, TRUE, 0);
@@ -278,8 +279,8 @@
     d->alsacardspin_w = alsa_card = gtk_spin_button_new(GTK_ADJUSTMENT(gtk_adjustment_new(d->card_number, 0.0, 256.0, 1.0, 1.0, 0.0)), 0, 0);
     gtk_box_pack_start(GTK_BOX(box2), alsa_card, FALSE, TRUE, 0);
     gtk_widget_show(alsa_card);
-    gtk_signal_connect (GTK_OBJECT(alsa_card), "changed",
-			GTK_SIGNAL_FUNC(prefs_alsacard_changed), d);
+    g_signal_connect(alsa_card, "value-changed",
+			G_CALLBACK(prefs_alsacard_changed), d);
 
     box2 = gtk_hbox_new(FALSE, 4);
     gtk_widget_show(box2);
@@ -293,8 +294,8 @@
     d->alsadevicespin_w = alsa_device = gtk_spin_button_new(GTK_ADJUSTMENT(gtk_adjustment_new(d->device_number, 0.0, 256.0, 1.0, 1.0, 0.0)), 0, 0);
     gtk_box_pack_start(GTK_BOX(box2), alsa_device, FALSE, TRUE, 0);
     gtk_widget_show(alsa_device);
-    gtk_signal_connect (GTK_OBJECT(alsa_device), "changed",
-			GTK_SIGNAL_FUNC(prefs_alsadevice_changed), d);
+    g_signal_connect(alsa_device, "value-changed",
+			G_CALLBACK(prefs_alsadevice_changed), d);
 
     prefs_init_from_structure(d);
 }
@@ -376,7 +377,7 @@
     err = snd_pcm_open(&(d->soundfd), d->card_number, d->device_number, SND_PCM_OPEN_PLAYBACK);
     if (err != 0) {
 	char buf[256];
-	sprintf(buf, _("Couldn't open ALSA device for sound output (card:%d, device:%d):\n%s"), 
+	g_sprintf(buf, _("Couldn't open ALSA device for sound output (card:%d, device:%d):\n%s"), 
 		d->card_number, d->device_number, snd_strerror(err));
 	error_error(buf);
 	goto out;
diff -Naur soundtracker-0.6.8/app/drivers/alsa-input.c soundtracker-0.6.8-gtk2/app/drivers/alsa-input.c
--- soundtracker-0.6.8/app/drivers/alsa-input.c	2001-01-03 14:24:11.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/drivers/alsa-input.c	2010-09-23 11:11:35.000000000 +0200
@@ -37,6 +37,7 @@
 #include <sys/time.h>
 
 #include <glib.h>
+#include <glib/gprintf.h>
 #include <gtk/gtk.h>
 
 #include "i18n.h"
@@ -120,12 +121,12 @@
 static void
 prefs_update_estimate (alsa_driver *d)
 {
-    char buf[64];
+    char buf[128];
 
-    sprintf(buf, _("(%d bytes)"), d->p_fragsize * d->p_channels * d->p_resolution / 8);
+    g_sprintf(buf, _("(%d bytes)"), d->p_fragsize * d->p_channels * d->p_resolution / 8);
     gtk_label_set_text(GTK_LABEL(d->bufsizelabel_w), buf);
     
-    sprintf(buf, _("Estimated audio delay: %f microseconds"), (double)(1000 * d->p_fragsize / d->p_mixfreq));
+    g_sprintf(buf, _("Estimated audio delay: %f microseconds"), (double)(1000 * d->p_fragsize / d->p_mixfreq));
     gtk_label_set_text(GTK_LABEL(d->estimatelabel_w), buf);
 }
 
@@ -244,8 +245,8 @@
     d->bufsizespin_w = thing = gtk_spin_button_new(GTK_ADJUSTMENT(gtk_adjustment_new(d->fragsize, 64.0, 16384.0, 64.0, 0.0, 0.0)), 0, 0);
     gtk_box_pack_start(GTK_BOX(box3), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect (GTK_OBJECT(thing), "changed",
-			GTK_SIGNAL_FUNC(prefs_fragsize_changed), d);
+    g_signal_connect(thing, "value-changed",
+			G_CALLBACK(prefs_fragsize_changed), d);
 
     d->bufsizelabel_w = thing = gtk_label_new("");
     gtk_box_pack_start(GTK_BOX(box3), thing, FALSE, TRUE, 0);
@@ -273,8 +274,8 @@
     d->alsacardspin_w = alsa_card = gtk_spin_button_new(GTK_ADJUSTMENT(gtk_adjustment_new(d->card_number, 0.0, 256.0, 1.0, 1.0, 0.0)), 0, 0);
     gtk_box_pack_start(GTK_BOX(box2), alsa_card, FALSE, TRUE, 0);
     gtk_widget_show(alsa_card);
-    gtk_signal_connect (GTK_OBJECT(alsa_card), "changed",
-			GTK_SIGNAL_FUNC(prefs_alsacard_changed), d);
+    g_signal_connect(alsa_card, "value-changed",
+			G_CALLBACK(prefs_alsacard_changed), d);
 
     box2 = gtk_hbox_new(FALSE, 4);
     gtk_widget_show(box2);
@@ -288,8 +289,8 @@
     d->alsadevicespin_w = alsa_device = gtk_spin_button_new(GTK_ADJUSTMENT(gtk_adjustment_new(d->device_number, 0.0, 256.0, 1.0, 1.0, 0.0)), 0, 0);
     gtk_box_pack_start(GTK_BOX(box2), alsa_device, FALSE, TRUE, 0);
     gtk_widget_show(alsa_device);
-    gtk_signal_connect (GTK_OBJECT(alsa_device), "changed",
-			GTK_SIGNAL_FUNC(prefs_alsadevice_changed), d);
+    g_signal_connect(alsa_device, "value-changed",
+			G_CALLBACK(prefs_alsadevice_changed), d);
 
     prefs_init_from_structure(d);
 }
@@ -371,7 +372,7 @@
 
     if (err != 0) {
 	char buf[256];
-	sprintf(buf, _("Couldn't open ALSA device for sound input (card:%d, device:%d):\n%s"), 
+	g_sprintf(buf, _("Couldn't open ALSA device for sound input (card:%d, device:%d):\n%s"), 
 		d->card_number, d->device_number, snd_strerror(err));
 	error_error(buf);
 	goto out;
diff -Naur soundtracker-0.6.8/app/drivers/alsa-output.c soundtracker-0.6.8-gtk2/app/drivers/alsa-output.c
--- soundtracker-0.6.8/app/drivers/alsa-output.c	2006-02-25 13:30:54.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/drivers/alsa-output.c	2010-09-23 11:11:35.000000000 +0200
@@ -36,6 +36,7 @@
 #include <sys/time.h>
 
 #include <glib.h>
+#include <glib/gprintf.h>
 #include <gtk/gtk.h>
 
 #include "i18n.h"
@@ -129,12 +130,12 @@
 static void
 prefs_update_estimate (alsa_driver *d)
 {
-    char buf[64];
+    char buf[128];
 
-    sprintf(buf, _("(%d bytes)"), d->p_fragsize * d->p_channels * d->p_resolution / 8);
+    g_sprintf(buf, _("(%d bytes)"), d->p_fragsize * d->p_channels * d->p_resolution / 8);
     gtk_label_set_text(GTK_LABEL(d->bufsizelabel_w), buf);
     
-    sprintf(buf, _("Estimated audio delay: %f milliseconds"), (double)(1000 * (d->p_fragsize) / d->p_mixfreq));
+    g_sprintf(buf, _("Estimated audio delay: %f milliseconds"), (double)(1000 * (d->p_fragsize) / d->p_mixfreq));
     gtk_label_set_text(GTK_LABEL(d->estimatelabel_w), buf);
 }
 
@@ -250,8 +251,8 @@
     d->bufsizespin_w = thing = gtk_spin_button_new(GTK_ADJUSTMENT(gtk_adjustment_new(d->fragsize, 64.0, 16384.0, 64.0, 0.0, 0.0)), 0, 0);
     gtk_box_pack_start(GTK_BOX(box3), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect (GTK_OBJECT(thing), "changed",
-			GTK_SIGNAL_FUNC(prefs_fragsize_changed), d);
+    g_signal_connect(thing, "value-changed",
+			G_CALLBACK(prefs_fragsize_changed), d);
 
     d->bufsizelabel_w = thing = gtk_label_new("");
     gtk_box_pack_start(GTK_BOX(box3), thing, FALSE, TRUE, 0);
@@ -279,8 +280,8 @@
     d->alsacardspin_w = alsa_card = gtk_spin_button_new(GTK_ADJUSTMENT(gtk_adjustment_new(d->card_number, 0.0, 256.0, 1.0, 1.0, 0.0)), 0, 0);
     gtk_box_pack_start(GTK_BOX(box2), alsa_card, FALSE, TRUE, 0);
     gtk_widget_show(alsa_card);
-    gtk_signal_connect (GTK_OBJECT(alsa_card), "changed",
-			GTK_SIGNAL_FUNC(prefs_alsacard_changed), d);
+    g_signal_connect(alsa_card, "value-changed",
+			G_CALLBACK(prefs_alsacard_changed), d);
 
     box2 = gtk_hbox_new(FALSE, 4);
     gtk_widget_show(box2);
@@ -294,8 +295,8 @@
     d->alsadevicespin_w = alsa_device = gtk_spin_button_new(GTK_ADJUSTMENT(gtk_adjustment_new(d->device_number, 0.0, 256.0, 1.0, 1.0, 0.0)), 0, 0);
     gtk_box_pack_start(GTK_BOX(box2), alsa_device, FALSE, TRUE, 0);
     gtk_widget_show(alsa_device);
-    gtk_signal_connect (GTK_OBJECT(alsa_device), "changed",
-			GTK_SIGNAL_FUNC(prefs_alsadevice_changed), d);
+    g_signal_connect(alsa_device, "value-changed",
+			G_CALLBACK(prefs_alsadevice_changed), d);
 
     prefs_init_from_structure(d);
 }
@@ -374,7 +375,7 @@
          		 	  SND_PCM_OPEN_PLAYBACK);
     if (err != 0) {
 	char buf[256];
-	sprintf(buf, _("Couldn't open ALSA device for sound output (card:%d, device:%d):\n%s"), 
+	g_sprintf(buf, _("Couldn't open ALSA device for sound output (card:%d, device:%d):\n%s"), 
 		d->card_number, d->device_number, snd_strerror(err));
 	error_error(buf);
 	goto out;
diff -Naur soundtracker-0.6.8/app/drivers/esd-output.c soundtracker-0.6.8-gtk2/app/drivers/esd-output.c
--- soundtracker-0.6.8/app/drivers/esd-output.c	2006-02-25 13:30:54.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/drivers/esd-output.c	2010-09-23 11:11:35.000000000 +0200
@@ -32,6 +32,7 @@
 #include <sys/time.h>
 
 #include <glib.h>
+#include <glib/gprintf.h>
 #include <gtk/gtk.h>
 #include <esd.h>
 
@@ -158,7 +159,7 @@
     d->out_sock = esd_play_stream_fallback(out_format, d->out_rate, NULL, "SoundTracker ESD Output");
     if(d->out_sock <= 0) {
 	char buf[256];
-	sprintf(buf, _("Couldn't connect to ESD for sound output:\n%s"), strerror(errno));
+	g_sprintf(buf, _("Couldn't connect to ESD for sound output:\n%s"), strerror(errno));
 	error_error(buf);
 	return FALSE;
     }
diff -Naur soundtracker-0.6.8/app/drivers/jack-output.c soundtracker-0.6.8-gtk2/app/drivers/jack-output.c
--- soundtracker-0.6.8/app/drivers/jack-output.c	2006-02-25 13:30:54.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/drivers/jack-output.c	2010-09-23 11:11:35.000000000 +0200
@@ -49,6 +49,7 @@
 #include <jack/jack.h>
 
 #include <glib.h>
+#include <glib/gprintf.h>
 #include <gtk/gtk.h>
 
 #include "i18n.h"
@@ -253,12 +254,12 @@
 
  	thing = d->transport_check = gtk_check_button_new_with_label (_("transport master"));
 	gtk_box_pack_start (GTK_BOX(mainbox), thing, FALSE, TRUE, 0);
-	d->transport_check_id = gtk_signal_connect(GTK_OBJECT(thing), "clicked", GTK_SIGNAL_FUNC(jack_driver_prefs_transport_callback),d);
+	d->transport_check_id = g_signal_connect(thing, "clicked", G_CALLBACK(jack_driver_prefs_transport_callback),d);
 	gtk_widget_show (thing);
 
 	thing = d->declick_check = gtk_check_button_new_with_label (_("declick"));
 	gtk_box_pack_start (GTK_BOX(mainbox), thing, FALSE, TRUE, 0);
-	gtk_signal_connect(GTK_OBJECT(thing), "clicked", GTK_SIGNAL_FUNC(jack_driver_prefs_declick_callback),d);
+	g_signal_connect(thing, "clicked", G_CALLBACK(jack_driver_prefs_declick_callback),d);
 	gtk_widget_show (thing);
 }
 
@@ -273,14 +274,14 @@
 static void
 jack_driver_prefs_update (jack_driver *d)
 {
-	char status_buf[64];
+	char status_buf[128];
 
 	if (d->is_active) {
-		sprintf (status_buf, _("Running at %d Hz with %d frames"), (int)d->sample_rate, (int)d->buffer_size);
+		g_sprintf (status_buf, _("Running at %d Hz with %d frames"), (int)d->sample_rate, (int)d->buffer_size);
 		gtk_label_set_text (GTK_LABEL (d->client_name_label), d->client_name);
 	}
 	else 
-		sprintf (status_buf, _("Jack server not running?"));
+		g_sprintf (status_buf, _("Jack server not running?"));
 	gtk_label_set_text (GTK_LABEL (d->status_label), status_buf);
        
 }
@@ -314,7 +315,7 @@
 	d->position = 0;
 	d->is_active = FALSE;
 	d->process_mx = (pthread_mutex_t*)malloc(sizeof (pthread_mutex_t));
-	d->state_cv = (pthread_cond_t *)malloc(sizeof (pthread_mutex_t));
+        d->state_cv = (pthread_cond_t *)malloc(sizeof (pthread_cond_t));
 	d->do_declick = TRUE;
 	pthread_mutex_init (d->process_mx, NULL);
 	pthread_cond_init (d->state_cv, NULL);
@@ -324,7 +325,7 @@
 
 	// TODO: this should be improved, both error handling and saving the string
 	// I'm probably not taking advantage of libjack
-	sprintf (d->client_name, _("soundtracker"));
+	g_sprintf (d->client_name, _("soundtracker"));
 	d->client_name[12] = '_';
 	d->client_name[14] = 0;
 	for (i = 0; i < 9; i++) {
diff -Naur soundtracker-0.6.8/app/drivers/oss-input.c soundtracker-0.6.8-gtk2/app/drivers/oss-input.c
--- soundtracker-0.6.8/app/drivers/oss-input.c	2003-04-03 23:34:15.000000000 +0200
+++ soundtracker-0.6.8-gtk2/app/drivers/oss-input.c	2010-09-23 11:11:35.000000000 +0200
@@ -128,8 +128,8 @@
     gtk_widget_show(thing);
     gtk_box_pack_start(GTK_BOX(box2), thing, FALSE, TRUE, 0);
     gtk_entry_set_text(GTK_ENTRY(thing), d->p_devdsp);
-    gtk_signal_connect_after(GTK_OBJECT(thing), "changed",
-			     GTK_SIGNAL_FUNC(oss_devdsp_changed), d);
+    g_signal_connect_after(thing, "changed",
+			     G_CALLBACK(oss_devdsp_changed), d);
     d->prefs_devdsp_w = thing;
 
     prefs_init_from_structure(d);
@@ -231,7 +231,7 @@
        OSS-conformant (though Thomas Sailer says it's okay). */
     if((d->soundfd = open(d->p_devdsp, O_RDONLY | O_NONBLOCK)) < 0) {
 	char buf[256];
-	sprintf(buf, _("Couldn't open %s for sampling:\n%s"), d->p_devdsp, strerror(errno));
+	g_sprintf(buf, _("Couldn't open %s for sampling:\n%s"), d->p_devdsp, strerror(errno));
 	error_error(buf);
 	goto out;
     }
diff -Naur soundtracker-0.6.8/app/drivers/oss-output.c soundtracker-0.6.8-gtk2/app/drivers/oss-output.c
--- soundtracker-0.6.8/app/drivers/oss-output.c	2006-02-25 13:30:54.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/drivers/oss-output.c	2010-09-23 11:11:35.000000000 +0200
@@ -42,6 +42,7 @@
 #include <sys/time.h>
 
 #include <glib.h>
+#include <glib/gprintf.h>
 #include <gtk/gtk.h>
 
 #include "i18n.h"
@@ -144,9 +145,9 @@
 static void
 prefs_update_estimate (oss_driver *d)
 {
-    char buf[64];
+    char buf[128];
     
-    sprintf(buf, _("Estimated audio delay: %f milliseconds"), (double)(1000 * (1 << d->p_fragsize)) / d->p_mixfreq);
+    g_sprintf(buf, _("Estimated audio delay: %f milliseconds"), (double)(1000 * (1 << d->p_fragsize)) / d->p_mixfreq);
     gtk_label_set_text(GTK_LABEL(d->estimatelabel_w), buf);
 }
 
@@ -176,11 +177,11 @@
 prefs_fragsize_changed (GtkSpinButton *w,
 			oss_driver *d)
 {
-    char buf[30];
+    char buf[64];
 
     d->p_fragsize = gtk_spin_button_get_value_as_int(w);
 
-    sprintf(buf, _("(%d samples)"), 1 << d->p_fragsize);
+    g_sprintf(buf, _("(%d samples)"), 1 << d->p_fragsize);
     gtk_label_set_text(GTK_LABEL(d->bufsizelabel_w), buf);
     prefs_update_estimate(d);
 }
@@ -222,8 +223,8 @@
     gtk_widget_show(thing);
     gtk_box_pack_start(GTK_BOX(box2), thing, FALSE, TRUE, 0);
     gtk_entry_set_text(GTK_ENTRY(thing), d->p_devdsp);
-    gtk_signal_connect_after(GTK_OBJECT(thing), "changed",
-			     GTK_SIGNAL_FUNC(oss_devdsp_changed), d);
+    g_signal_connect_after(thing, "changed",
+			     G_CALLBACK(oss_devdsp_changed), d);
     d->prefs_devdsp_w = thing;
 
     box2 = gtk_hbox_new(FALSE, 4);
@@ -272,8 +273,8 @@
     d->bufsizespin_w = thing = gtk_spin_button_new(GTK_ADJUSTMENT(gtk_adjustment_new(5.0, 5.0, 15.0, 1.0, 1.0, 0.0)), 0, 0);
     gtk_box_pack_start(GTK_BOX(box3), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect (GTK_OBJECT(thing), "changed",
-			GTK_SIGNAL_FUNC(prefs_fragsize_changed), d);
+    g_signal_connect(thing, "value-changed",
+			G_CALLBACK(prefs_fragsize_changed), d);
 
     d->bufsizelabel_w = thing = gtk_label_new("");
     gtk_box_pack_start(GTK_BOX(box3), thing, FALSE, TRUE, 0);
@@ -388,7 +389,7 @@
        OSS-conformant (though Thomas Sailer says it's okay). */
     if((d->soundfd = open(d->p_devdsp, O_WRONLY | O_NONBLOCK)) < 0) {
 	char buf[256];
-	sprintf(buf, _("Couldn't open %s for sound output:\n%s"), d->p_devdsp, strerror(errno));
+	g_sprintf(buf, _("Couldn't open %s for sound output:\n%s"), d->p_devdsp, strerror(errno));
 	error_error(buf);
 	goto out;
     }
diff -Naur soundtracker-0.6.8/app/drivers/sdl-output.c soundtracker-0.6.8-gtk2/app/drivers/sdl-output.c
--- soundtracker-0.6.8/app/drivers/sdl-output.c	2006-02-25 13:51:14.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/drivers/sdl-output.c	2010-09-23 11:11:35.000000000 +0200
@@ -45,6 +45,7 @@
     int out_bits, out_channels, out_rate;
     int played;
     int mf;
+    int last_played;
     SDL_AudioSpec spec;
 
     gpointer polltag;
@@ -54,8 +55,10 @@
 {
     sdl_driver * const d = udata;
 
+
     audio_mix(stream, len/4, d->out_rate, d->mf);
-    d->played+=len/4;
+    d->played+=d->last_played;
+    d->last_played = len/4;
 }
 
 static void
@@ -147,6 +150,7 @@
 
     d->polltag = audio_poll_add(0, GDK_INPUT_WRITE, sdl_poll_ready_playing, d);
     d->played = 0;
+    d->last_played = 0;
 
     SDL_PauseAudio(0);
     return TRUE;
@@ -160,6 +164,13 @@
     return((double)d->played/44100.0);
 }
 
+static inline int
+sdl_get_play_rate (void *dp)
+{
+    sdl_driver * const d = dp;
+    return d->out_rate;
+}
+
 static gboolean
 sdl_loadsettings (void *dp,
 		  prefs_node *f)
@@ -189,6 +200,7 @@
     },
 
     sdl_get_play_time,
+    sdl_get_play_rate
 };
 
 #endif /* DRIVER_SDL */
diff -Naur soundtracker-0.6.8/app/drivers/sun-input.c soundtracker-0.6.8-gtk2/app/drivers/sun-input.c
--- soundtracker-0.6.8/app/drivers/sun-input.c	2003-05-18 16:53:53.000000000 +0200
+++ soundtracker-0.6.8-gtk2/app/drivers/sun-input.c	2010-09-23 11:11:35.000000000 +0200
@@ -35,6 +35,7 @@
 #include <sys/time.h>
 
 #include <glib.h>
+#include <glib/gprintf.h>
 #include <gtk/gtk.h>
 
 #include "i18n.h"
@@ -122,8 +123,8 @@
     gtk_widget_show(thing);
     gtk_box_pack_start(GTK_BOX(box2), thing, FALSE, TRUE, 0);
     gtk_entry_set_text(GTK_ENTRY(thing), d->p_devaudio);
-    gtk_signal_connect_after(GTK_OBJECT(thing), "changed",
-			     GTK_SIGNAL_FUNC(sun_devaudio_changed), d);
+    g_signal_connect_after(thing, "changed",
+			     G_CALLBACK(sun_devaudio_changed), d);
     d->prefs_devaudio_w = thing;
 
     prefs_init_from_structure(d);
@@ -226,7 +227,7 @@
 
     d->soundfd = open(d->p_devaudio, O_RDONLY|O_NONBLOCK);
     if(d->soundfd < 0) {
-	sprintf(buf, _("%s: %s"), d->p_devaudio, strerror(errno));
+	g_sprintf(buf, _("%s: %s"), d->p_devaudio, strerror(errno));
 	goto out;
     }
    
@@ -239,7 +240,7 @@
    
     d->info.mode = AUMODE_RECORD;
     if(ioctl(d->soundfd, AUDIO_SETINFO, &d->info) != 0) {
-	sprintf(buf, _("%s: Cannot record (%s)"), d->p_devaudio,
+	g_sprintf(buf, _("%s: Cannot record (%s)"), d->p_devaudio,
 	    strerror(errno));
 	goto out;
     }
@@ -247,7 +248,7 @@
     d->playrate = d->p_mixfreq;
     d->info.record.sample_rate = d->playrate;
     if(ioctl(d->soundfd, AUDIO_SETINFO, &d->info) != 0) {
-	sprintf(buf, _("%s: Cannot handle %dHz (%s)"), d->p_devaudio,
+	g_sprintf(buf, _("%s: Cannot handle %dHz (%s)"), d->p_devaudio,
 	    d->playrate, strerror(errno));
 	goto out;
     }  
@@ -277,7 +278,7 @@
 	    d->bits = 8;
 	    mf = ST_MIXER_FORMAT_U8;
 	} else {
-	    sprintf(buf, _("%s: Required sound encoding not supported.\n"),
+	    g_sprintf(buf, _("%s: Required sound encoding not supported.\n"),
 	        d->p_devaudio);
 	    goto out;
 	}
@@ -302,13 +303,13 @@
     	d->info.hiwat = 65536;
     }
     if (ioctl(d->soundfd, AUDIO_SETINFO, &d->info) != 0) {
-	sprintf(buf, _("%s: Cannot set block size (%s)"), d->p_devaudio,
+	g_sprintf(buf, _("%s: Cannot set block size (%s)"), d->p_devaudio,
 	    strerror(errno));
         goto out;
     }
   
   if (ioctl(d->soundfd, AUDIO_GETINFO, &d->info) != 0) {
-	sprintf(buf, _("%s: %s"), d->p_devaudio, strerror(errno));
+	g_sprintf(buf, _("%s: %s"), d->p_devaudio, strerror(errno));
 	goto out;
     }
     d->bufsize = d->info.blocksize;
diff -Naur soundtracker-0.6.8/app/drivers/sun-output.c soundtracker-0.6.8-gtk2/app/drivers/sun-output.c
--- soundtracker-0.6.8/app/drivers/sun-output.c	2006-02-25 13:30:54.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/drivers/sun-output.c	2010-09-23 11:11:35.000000000 +0200
@@ -35,6 +35,7 @@
 #include <sys/time.h>
 
 #include <glib.h>
+#include <glib/gprintf.h>
 #include <gtk/gtk.h>
 
 #include "i18n.h"
@@ -132,9 +133,9 @@
 static void
 prefs_update_estimate (sun_driver *d)
 {
-    char buf[64];
+    char buf[128];
     
-    sprintf(buf, _("Estimated audio delay: %f milliseconds"),
+    g_sprintf(buf, _("Estimated audio delay: %f milliseconds"),
         (double)(1000 * (1 << d->p_bufsize)) / d->p_mixfreq);
     gtk_label_set_text(GTK_LABEL(d->estimatelabel_w), buf);
 }
@@ -169,7 +170,7 @@
 
     d->p_bufsize = gtk_spin_button_get_value_as_int(w);
 
-    sprintf(buf, _("(%d samples)"), 1 << d->p_bufsize);
+    g_sprintf(buf, _("(%d samples)"), 1 << d->p_bufsize);
     gtk_label_set_text(GTK_LABEL(d->bufsizelabel_w), buf);
     prefs_update_estimate(d);
 }
@@ -214,8 +215,8 @@
     gtk_widget_show(thing);
     gtk_box_pack_start(GTK_BOX(box2), thing, FALSE, TRUE, 0);
     gtk_entry_set_text(GTK_ENTRY(thing), d->p_devaudio);
-    gtk_signal_connect_after(GTK_OBJECT(thing), "changed",
-			     GTK_SIGNAL_FUNC(sun_devaudio_changed), d);
+    g_signal_connect_after(thing, "changed",
+			     G_CALLBACK(sun_devaudio_changed), d);
     d->prefs_devaudio_w = thing;
 
     box2 = gtk_hbox_new(FALSE, 4);
@@ -268,8 +269,8 @@
         gtk_adjustment_new(5.0, 5.0, 15.0, 1.0, 1.0, 0.0)), 0, 0);
     gtk_box_pack_start(GTK_BOX(box3), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect (GTK_OBJECT(thing), "changed",
-			GTK_SIGNAL_FUNC(prefs_bufsize_changed), d);
+    g_signal_connect(thing, "value-changed",
+			G_CALLBACK(prefs_bufsize_changed), d);
 
     d->bufsizelabel_w = thing = gtk_label_new("");
     gtk_box_pack_start(GTK_BOX(box3), thing, FALSE, TRUE, 0);
@@ -386,20 +387,20 @@
 
     d->soundfd = open(d->p_devaudio, O_WRONLY);
     if(d->soundfd < 0) {
-	sprintf(buf, _("%s: %s"), d->p_devaudio, strerror(errno));
+	g_sprintf(buf, _("%s: %s"), d->p_devaudio, strerror(errno));
 	goto out;
     }
     
     d->info.mode = AUMODE_PLAY;
     if(ioctl(d->soundfd, AUDIO_SETINFO, &d->info) != 0) {
-	sprintf(buf, _("%s: Cannot play (%s)"), d->p_devaudio, strerror(errno));
+	g_sprintf(buf, _("%s: Cannot play (%s)"), d->p_devaudio, strerror(errno));
 	goto out;
     }
     
     d->playrate = d->p_mixfreq;
     d->info.play.sample_rate = d->playrate;
     if(ioctl(d->soundfd, AUDIO_SETINFO, &d->info) != 0) {
-	sprintf(buf, _("%s: Cannot handle %dHz (%s)"), d->p_devaudio,
+	g_sprintf(buf, _("%s: Cannot handle %dHz (%s)"), d->p_devaudio,
 	    d->playrate, strerror(errno));
 	goto out;
     }  
@@ -428,7 +429,7 @@
 	    d->bits = 8;
 	    mf = ST_MIXER_FORMAT_U8;
 	} else {
-	    sprintf(buf, _("%s: Required sound encoding not supported.\n"),
+	    g_sprintf(buf, _("%s: Required sound encoding not supported.\n"),
 	        d->p_devaudio);
 	    goto out;
 	}
@@ -451,13 +452,13 @@
     	d->info.hiwat = 65536;
     }
     if (ioctl(d->soundfd, AUDIO_SETINFO, &d->info) != 0) {
-	sprintf(buf, _("%s: Cannot set block size (%s)"), d->p_devaudio,
+	g_sprintf(buf, _("%s: Cannot set block size (%s)"), d->p_devaudio,
 	    strerror(errno));
         goto out;
     }
    
     if (ioctl(d->soundfd, AUDIO_GETINFO, &d->info) != 0) {
-	sprintf(buf, _("%s: %s"), d->p_devaudio, strerror(errno));
+	g_sprintf(buf, _("%s: %s"), d->p_devaudio, strerror(errno));
 	goto out;
     }
     d->bufsize = d->info.blocksize;
diff -Naur soundtracker-0.6.8/app/envelope-box.c soundtracker-0.6.8-gtk2/app/envelope-box.c
--- soundtracker-0.6.8/app/envelope-box.c	2002-05-16 15:52:25.000000000 +0200
+++ soundtracker-0.6.8-gtk2/app/envelope-box.c	2010-09-23 11:11:35.000000000 +0200
@@ -3,6 +3,7 @@
  * The Real SoundTracker - GTK+ envelope editor box
  *
  * Copyright (C) 1998-2001 Michael Krause
+ * Copytight (C) 2006 Yury Aliaev (Gtk+-2 porting)
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -195,8 +196,8 @@
 					  "outline_color", "#ff0000",
 					  "width_pixels", 0,
 					  NULL);
-    gtk_signal_connect (GTK_OBJECT (e->points[n]), "event",
-			(GtkSignalFunc) envelope_box_point_event,
+    g_signal_connect (e->points[n], "event",
+			G_CALLBACK(envelope_box_point_event),
 			e);
 
     // Adjust / Create line connecting to the previous point
@@ -254,17 +255,30 @@
 envelope_box_block_loop_spins (EnvelopeBox *e,
 			       int block)
 {
-    void (*func) (GtkObject*, gpointer);
-
-    func = block ? gtk_signal_handler_block_by_data : gtk_signal_handler_unblock_by_data;
-
-    func(GTK_OBJECT(e->spin_length), e);
-    func(GTK_OBJECT(e->spin_pos), e);
-    func(GTK_OBJECT(e->spin_offset), e);
-    func(GTK_OBJECT(e->spin_value), e);
-    func(GTK_OBJECT(e->spin_sustain), e);
-    func(GTK_OBJECT(e->spin_loop_start), e);
-    func(GTK_OBJECT(e->spin_loop_end), e);
+    guint (*func) (gpointer,
+           GSignalMatchType    mask,
+		 guint          signal_id,
+		 GQuark         detail,
+		 GClosure           *closure,
+		 gpointer            func,
+		 gpointer            data);
+
+    func = block ? g_signal_handlers_block_matched : g_signal_handlers_unblock_matched;
+
+    func(G_OBJECT(e->spin_length), 
+	    (GSignalMatchType) G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, e);
+    func(G_OBJECT(e->spin_pos),
+	    (GSignalMatchType) G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, e);
+    func(G_OBJECT(e->spin_offset),
+	    (GSignalMatchType) G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, e);
+    func(G_OBJECT(e->spin_value),
+	    (GSignalMatchType) G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, e);
+    func(G_OBJECT(e->spin_sustain),
+	    (GSignalMatchType) G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, e);
+    func(G_OBJECT(e->spin_loop_start),
+	    (GSignalMatchType) G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, e);
+    func(G_OBJECT(e->spin_loop_end),
+	    (GSignalMatchType) G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, e);
 }
 
 static int
@@ -848,7 +862,7 @@
     GtkWidget *table, *canvas;
 #endif
 
-    e = gtk_type_new(envelope_box_get_type());
+    e = g_object_new(envelope_box_get_type(), NULL);
     GTK_BOX(e)->spacing = 2;
     GTK_BOX(e)->homogeneous = FALSE;
 
@@ -860,8 +874,8 @@
     gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(thing), 0);
     gtk_box_pack_start(GTK_BOX(box2), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "toggled",
-		       GTK_SIGNAL_FUNC(handle_toggle_button), e);
+    g_signal_connect(thing, "toggled",
+		      G_CALLBACK(handle_toggle_button), e);
     e->enable = GTK_TOGGLE_BUTTON(thing);
 
     add_empty_hbox(box2);
@@ -887,14 +901,14 @@
     thing = gtk_button_new_with_label(_("Insert"));
     gtk_box_pack_start(GTK_BOX(box4), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(insert_clicked), e);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(insert_clicked), e);
     
     thing = gtk_button_new_with_label(_("Delete"));
     gtk_box_pack_start(GTK_BOX(box4), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(delete_clicked), e);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(delete_clicked), e);
 
     thing = gtk_vseparator_new();
     gtk_box_pack_start(GTK_BOX(box2), thing, FALSE, TRUE, 0);
@@ -910,8 +924,8 @@
 //	gtk_widget_push_colormap (gdk_rgb_get_cmap ());
 //	canvas = gnome_canvas_new_aa ();
 //    } else {
-	gtk_widget_push_visual (gdk_imlib_get_visual ());
-	gtk_widget_push_colormap (gdk_imlib_get_colormap ());
+	gtk_widget_push_visual (gdk_rgb_get_visual ());
+	gtk_widget_push_colormap (gdk_rgb_get_colormap ());
 	canvas = gnome_canvas_new ();
 //    }
     e->canvas = GNOME_CANVAS(canvas);
@@ -932,12 +946,12 @@
 							  "y", 0.0,
 							  NULL));
 
-    gtk_signal_connect_after (GTK_OBJECT (canvas), "event",
-			      (GtkSignalFunc) envelope_box_canvas_event,
+    g_signal_connect_after(canvas, "event",
+			      G_CALLBACK(envelope_box_canvas_event),
 			      e);
 
-    gtk_signal_connect_after(GTK_OBJECT(canvas), "size_allocate",
-			     GTK_SIGNAL_FUNC(envelope_box_canvas_size_allocate), e);
+    g_signal_connect_after(canvas, "size_allocate",
+			     G_CALLBACK(envelope_box_canvas_size_allocate), e);
 
     table = gtk_table_new (2, 2, FALSE);
     gtk_table_set_row_spacings (GTK_TABLE (table), 4);
@@ -1001,8 +1015,8 @@
     gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(thing), 0);
     gtk_box_pack_start(GTK_BOX(box3), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "toggled",
-		       GTK_SIGNAL_FUNC(handle_toggle_button), e);
+    g_signal_connect(thing, "toggled",
+		       G_CALLBACK(handle_toggle_button), e);
     e->sustain = GTK_TOGGLE_BUTTON(thing);
 
     gui_put_labelled_spin_button(box3, _("Point"), 0, 11, (GtkWidget**)&e->spin_sustain, handle_spin_button, e);
@@ -1011,8 +1025,8 @@
     gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(thing), 0);
     gtk_box_pack_start(GTK_BOX(box3), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "toggled",
-		       GTK_SIGNAL_FUNC(handle_toggle_button), e);
+    g_signal_connect(thing, "toggled",
+		       G_CALLBACK(handle_toggle_button), e);
     e->loop = GTK_TOGGLE_BUTTON(thing);
 
     gui_put_labelled_spin_button(box3, _("Start"), 0, 11, (GtkWidget**)&e->spin_loop_start, handle_spin_button, e);
@@ -1026,18 +1040,21 @@
     static guint envelope_box_type = 0;
     
     if (!envelope_box_type) {
-	GtkTypeInfo envelope_box_info =
+	GTypeInfo envelope_box_info =
 	{
-	    "EnvelopeBox",
-	    sizeof(EnvelopeBox),
 	    sizeof(EnvelopeBoxClass),
-	    (GtkClassInitFunc) NULL,
-	    (GtkObjectInitFunc) NULL,
-	    (GtkArgSetFunc) NULL,
-	    (GtkArgGetFunc) NULL,
+		(GBaseInitFunc) NULL,
+		(GBaseFinalizeFunc) NULL,
+	    (GClassInitFunc) NULL,
+	    (GClassFinalizeFunc) NULL,
+	    NULL,
+	    sizeof(EnvelopeBox),
+	    0,
+	    (GInstanceInitFunc) NULL,
 	};
 	
-	envelope_box_type = gtk_type_unique(gtk_vbox_get_type (), &envelope_box_info);
+	envelope_box_type = g_type_register_static(gtk_vbox_get_type (),"EnvelopeBox",
+			&envelope_box_info, (GTypeFlags)0);
     }
     
     return envelope_box_type;
diff -Naur soundtracker-0.6.8/app/extspinbutton.c soundtracker-0.6.8-gtk2/app/extspinbutton.c
--- soundtracker-0.6.8/app/extspinbutton.c	2001-01-03 14:35:01.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/extspinbutton.c	2010-09-23 11:11:35.000000000 +0200
@@ -3,6 +3,7 @@
  * The Real SoundTracker - GTK+ Spinbutton extensions
  *
  * Copyright (C) 1999-2001 Michael Krause
+ * Copytight (C) 2006 Yury Aliaev (Gtk+-2 porting)
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -56,20 +57,20 @@
     if(EXTSPINBUTTON(widget)->size_hack) {
 	requisition->width = MAX (MIN_SPIN_BUTTON_WIDTH,
 				  extspinbutton_find_display_digits(GTK_SPIN_BUTTON(widget)->adjustment)
-				  * gdk_string_width(widget->style->font, "X"))
+				  * gdk_string_width(gdk_font_from_description(widget->style->font_desc), "X"))
 	    + ARROW_SIZE
-	    + 2 * widget->style->klass->xthickness;
+	    + 2 * widget->style->xthickness;
     } else {
 	// This is the normal size_request() from gtk+-1.2.8
 	requisition->width = MIN_SPIN_BUTTON_WIDTH + ARROW_SIZE 
-	    + 2 * widget->style->klass->xthickness;
+	    + 2 * widget->style->xthickness;
     }
 }
 
 static void
 extspinbutton_value_changed (GtkSpinButton *spin)
 {
-    if(spin->button != 0) {
+    if(gtk_window_get_focus(GTK_WINDOW(mainwindow))) {
 	// Should only do this if this widget is really in the main window.
 	gtk_window_set_focus(GTK_WINDOW(mainwindow), NULL);
     }
@@ -82,12 +83,12 @@
 {
     ExtSpinButton *s;
 
-    s = gtk_type_new(extspinbutton_get_type());
+    s = g_object_new(extspinbutton_get_type(), NULL);
     s->size_hack = TRUE;
     gtk_spin_button_configure(GTK_SPIN_BUTTON(s), adjustment, climb_rate, digits);
 
-    gtk_signal_connect(GTK_OBJECT(s), "changed",
-		       GTK_SIGNAL_FUNC(extspinbutton_value_changed), NULL);
+    g_signal_connect(s, "value-changed",
+		     G_CALLBACK(extspinbutton_value_changed), NULL);
 
     return GTK_WIDGET(s);
 }
@@ -121,18 +122,20 @@
     static guint extspinbutton_type = 0;
     
     if (!extspinbutton_type) {
-	GtkTypeInfo extspinbutton_info =
+	GTypeInfo extspinbutton_info =
 	{
-	    "ExtSpinButton",
-	    sizeof(ExtSpinButton),
 	    sizeof(ExtSpinButtonClass),
-	    (GtkClassInitFunc) extspinbutton_class_init,
-	    (GtkObjectInitFunc) extspinbutton_init,
-	    (GtkArgSetFunc) NULL,
-	    (GtkArgGetFunc) NULL,
+	    (GBaseInitFunc) NULL,
+		(GBaseFinalizeFunc) NULL,
+	    (GClassInitFunc) extspinbutton_class_init,
+		(GClassFinalizeFunc) NULL,
+		NULL,
+	    sizeof(ExtSpinButton),
+	    0,
+	    (GInstanceInitFunc) extspinbutton_init,
 	};
 	
-	extspinbutton_type = gtk_type_unique(gtk_spin_button_get_type (), &extspinbutton_info);
+	extspinbutton_type = g_type_register_static(gtk_spin_button_get_type (),"ExtSpinButton", &extspinbutton_info,  (GTypeFlags)0);
     }
     
     return extspinbutton_type;
diff -Naur soundtracker-0.6.8/app/file-operations.c soundtracker-0.6.8-gtk2/app/file-operations.c
--- soundtracker-0.6.8/app/file-operations.c	2003-08-04 12:07:59.000000000 +0200
+++ soundtracker-0.6.8-gtk2/app/file-operations.c	2010-09-23 11:11:35.000000000 +0200
@@ -102,24 +102,29 @@
 static void
 fileops_filesel_pre_insertion (GtkFileSelection *fs)
 {
+/* Maybe these 2 functions responsible for single-clicking...
     gtk_widget_hide(fs->button_area);
+	printf("file list type: %s\n", G_OBJECT_TYPE_NAME(G_OBJECT(fs->file_list)));
 
     if(is_single_click_dialog(fs)) {
 	gtk_widget_hide(fileops_filesel_get_confirm_area(fs));
 
-	handler_id_f = gtk_signal_connect_after (GTK_OBJECT (fs->file_list), "select_row",
-						 (GtkSignalFunc) file_selection_file_button,
+
+	handler_id_f = g_signal_connect_after (G_OBJECT (fs->file_list), "select-cursor-row",
+						 (GCallback) file_selection_file_button,
 						 (gpointer) fs);
     }
 
-    handler_id_d = gtk_signal_connect_after (GTK_OBJECT (fs->dir_list), "select_row",
-					   (GtkSignalFunc) file_selection_dir_button,
+    handler_id_d = g_signal_connect_after (G_OBJECT (fs->dir_list), "select-cursor-row",
+					   (GCallback) file_selection_dir_button,
 					   (gpointer) fs);
+*/
 }
 
 static void
 fileops_filesel_post_removal (GtkFileSelection *fs)
 {
+/*
     gtk_signal_disconnect(GTK_OBJECT(fs->dir_list), handler_id_d);
 
     if(is_single_click_dialog(fs)) {
@@ -129,6 +134,7 @@
     }
 
     gtk_widget_show(fs->button_area);
+*/
 }
 
 static void
diff -Naur soundtracker-0.6.8/app/gui.c soundtracker-0.6.8-gtk2/app/gui.c
--- soundtracker-0.6.8/app/gui.c	2006-02-25 13:34:40.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/gui.c	2010-09-23 11:11:35.000000000 +0200
@@ -35,6 +35,7 @@
 #include <glib.h>
 #ifdef USE_GNOME
 #include <gnome.h>
+#include <bonobo.h>
 #endif
 #ifndef NO_GDK_PIXBUF
 #include <gdk-pixbuf/gdk-pixbuf.h>
@@ -94,7 +95,6 @@
 
 guint statusbar_context_id;
 GtkWidget *status_bar;
-GtkWidget *st_clock;
 
 struct f_n_l
 {
@@ -246,12 +246,12 @@
 			GNOME_STOCK_BUTTON_CLOSE, NULL);
     gnome_dialog_close_hides(GNOME_DIALOG(measurewindow), TRUE);
     gnome_dialog_set_close(GNOME_DIALOG(measurewindow), TRUE);
-    gtk_signal_connect(GTK_OBJECT(measurewindow), "clicked",
-			GTK_SIGNAL_FUNC (measure_close_requested), NULL);
+    g_signal_connect(measurewindow, "clicked",
+			G_CALLBACK(measure_close_requested), NULL);
     vbox = GNOME_DIALOG(measurewindow)->vbox;
 #else
 /* stolen from Gnome UI code. With Gnome life seemed so easy... (yaliaev) */
-    measurewindow = gtk_window_new(GTK_WINDOW_DIALOG);
+    measurewindow = gtk_window_new(GTK_WINDOW_TOPLEVEL);
     gtk_window_set_title(GTK_WINDOW(measurewindow), _("Row highlighting configuration"));
     gtk_container_border_width(GTK_CONTAINER(measurewindow), 4);
     
@@ -274,8 +274,8 @@
     button = gtk_button_new_with_label(_("Close"));
     GTK_WIDGET_SET_FLAGS (GTK_WIDGET (button), GTK_CAN_DEFAULT);
     gtk_box_pack_start (GTK_BOX (thing), button, TRUE, TRUE, 0);
-    gtk_signal_connect(GTK_OBJECT(button), "clicked",
-			GTK_SIGNAL_FUNC (measure_close_requested), NULL);
+    g_signal_connect(button, "clicked",
+			G_CALLBACK(measure_close_requested), NULL);
 
     gtk_widget_grab_default (button);
     gtk_widget_show (button);
@@ -291,8 +291,8 @@
 		      
 #endif
 
-    gtk_signal_connect(GTK_OBJECT (measurewindow), "delete_event",
-			GTK_SIGNAL_FUNC (measure_close_requested), NULL);
+    g_signal_connect(measurewindow, "delete_event",
+			G_CALLBACK(measure_close_requested), NULL);
 
     mainbox = gtk_hbox_new(FALSE, 2);
     
@@ -307,15 +307,15 @@
     gtk_box_pack_start(GTK_BOX(mainbox), majspin, FALSE, TRUE, 0);
     gtk_widget_show(majspin);
     gtk_spin_button_set_digits(GTK_SPIN_BUTTON(majspin), 0);
-    gtk_signal_connect(GTK_OBJECT(majspin), "changed",
-		       GTK_SIGNAL_FUNC(gui_settings_highlight_rows_changed), NULL);
+    g_signal_connect(majspin, "value-changed",
+		       G_CALLBACK(gui_settings_highlight_rows_changed), NULL);
     adj = gtk_adjustment_new((double)gui_settings.highlight_rows_minor_n, 1, 16, 1, 2, 0.0);
     thing = extspinbutton_new(GTK_ADJUSTMENT(adj), 0, 0);
     gtk_box_pack_start(GTK_BOX(mainbox), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
     gtk_spin_button_set_digits(GTK_SPIN_BUTTON(thing), 0);
-    gtk_signal_connect(GTK_OBJECT(thing), "changed",
-		       GTK_SIGNAL_FUNC(gui_settings_highlight_rows_minor_changed), NULL);
+    g_signal_connect(thing, "value-changed",
+		       G_CALLBACK(gui_settings_highlight_rows_minor_changed), NULL);
     gtk_widget_set_uposition(measurewindow, x, y);
     
     gtk_box_pack_start(GTK_BOX(vbox), mainbox, TRUE, TRUE, 0);
@@ -659,13 +659,15 @@
 static void
 current_instrument_changed (GtkSpinButton *spin)
 {
+    int ins;
+    
     int m = xm_get_modified();
-    STInstrument *i = &xm->instruments[gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(curins_spin))-1];
+    STInstrument *i = &xm->instruments[ins = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(curins_spin))-1];
     STSample *s = &i->samples[gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(cursmpl_spin))];
 
     instrument_editor_set_instrument(i);
     sample_editor_set_sample(s);
-    modinfo_set_current_instrument(gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(curins_spin)) - 1);
+    modinfo_set_current_instrument(ins);
     xm_set_modified(m);
 }
 
@@ -683,13 +685,15 @@
 static void
 current_sample_changed (GtkSpinButton *spin)
 {
+    int smpl;
+
     int m = xm_get_modified();
     STInstrument *i = &xm->instruments[gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(curins_spin))-1];
-    STSample *s = &i->samples[gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(cursmpl_spin))];
+    STSample *s = &i->samples[smpl = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(cursmpl_spin))];
 
     gtk_entry_set_text(GTK_ENTRY(gui_cursmpl_name), s->name);
     sample_editor_set_sample(s);
-    modinfo_set_current_sample(gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(cursmpl_spin)));
+    modinfo_set_current_sample(smpl);
     xm_set_modified(m);
 }
 
@@ -824,6 +828,11 @@
 	    if(b) {
 		/* toggle editing mode (only if we haven't been in playing mode) */
 		gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(editing_toggle), !GUI_EDITING);
+ 		tracker_redraw(tracker);
+    	        if (GTK_TOGGLE_BUTTON(editing_toggle)->active)
+		    show_editmode_status();
+		else
+		    statusbar_update(STATUS_IDLE, FALSE);
 	    }
 	}
 	handled = TRUE;
@@ -833,6 +842,11 @@
             break;
 	/* toggle editing mode, even if we're in playing mode */
 		gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(editing_toggle), !GUI_EDITING);
+	    tracker_redraw(tracker);
+        if (GTK_TOGGLE_BUTTON(editing_toggle)->active)
+	    show_editmode_status();
+        else
+	    statusbar_update(STATUS_IDLE, FALSE);
 	handled = TRUE;
 	break;
     }
@@ -883,9 +897,9 @@
 
 	if(handled) {
 	    if(pressed) {
-		gtk_signal_emit_stop_by_name(GTK_OBJECT(widget), "key_press_event");
+		gtk_signal_emit_stop_by_name(GTK_OBJECT(widget), "key-press-event");
 	    } else {
-		gtk_signal_emit_stop_by_name(GTK_OBJECT(widget), "key_release_event");
+		gtk_signal_emit_stop_by_name(GTK_OBJECT(widget), "key-release-event");
 	    }
 	}
     } else {
@@ -893,14 +907,14 @@
 	    switch(event->keyval) {
 	    case GDK_Tab:
 	    case GDK_Return:
-		gtk_signal_emit_stop_by_name(GTK_OBJECT(widget), "key_press_event");
+		gtk_signal_emit_stop_by_name(GTK_OBJECT(widget), "key-press-event");
 		gtk_window_set_focus(GTK_WINDOW(mainwindow), NULL);
 		break;
 	    }
 	}
     }
 
-    return TRUE;
+    return handled;
 }
 
 static void
@@ -938,7 +952,7 @@
 	xm->pattern_order_table[pos] = pat;
 	if(pos == playlist_get_position(p)
 	    && !gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(toggle_lock_editpat))) {
-	    gui_set_current_pattern(pat);
+	    gui_set_current_pattern(pat, TRUE);
 	}
     } else {
 	for(i = 0; i < xm->song_length; i++) {
@@ -963,7 +977,7 @@
     int n = gtk_spin_button_get_value_as_int(spin);
 
     if(n != editing_pat) {
-	gui_set_current_pattern(n);
+	gui_set_current_pattern(n, FALSE);
 
 	/* If we are in 'playing pattern' mode and asynchronous
 	 * editing is disabled, make the audio thread jump to the new
@@ -1004,7 +1018,7 @@
 	gui_play_stop();
 	tracker_set_pattern(tracker, NULL);
 	st_set_num_channels(xm, n);
-	gui_init_xm(0);
+	gui_init_xm(0, FALSE);
 	xm_set_modified(1);
     }
 }
@@ -1101,7 +1115,7 @@
 	}
 	if(!ASYNCEDIT) {
 	    /* The following is a no-op if we're already in the right pattern */
-	    gui_set_current_pattern(xm->pattern_order_table[p->songpos]);
+	    gui_set_current_pattern(xm->pattern_order_table[p->songpos], TRUE);
 	}
     }
 
@@ -1165,9 +1179,6 @@
     switch(a) {
     case AUDIO_BACKPIPE_PLAYING_STOPPED:
         statusbar_update(STATUS_IDLE, FALSE);
-#ifdef USE_GNOME
-        gtk_clock_stop(GTK_CLOCK(st_clock));
-#endif
 
         if(gui_ewc_startstop > 0) {
 	    /* can be equal to zero when the audio subsystem decides to stop playing on its own. */
@@ -1187,10 +1198,6 @@
     case AUDIO_BACKPIPE_PLAYING_PATTERN_STARTED:
         if(a == AUDIO_BACKPIPE_PLAYING_PATTERN_STARTED)
 	    statusbar_update(STATUS_PLAYING_PATTERN, FALSE);
-#ifdef USE_GNOME
-        gtk_clock_set_seconds(GTK_CLOCK(st_clock), 0);
-        gtk_clock_start(GTK_CLOCK(st_clock));
-#endif
 
         gui_ewc_startstop--;
 	gui_playing_mode = (a == AUDIO_BACKPIPE_PLAYING_STARTED) ? PLAYING_SONG : PLAYING_PATTERN;
@@ -1295,7 +1302,7 @@
 }
 
 void
-gui_init_xm (int new_xm)
+gui_init_xm (int new_xm, gboolean updatechspin)
 {
     int m = xm_get_modified();
     audio_ctlpipe_id i;
@@ -1306,7 +1313,7 @@
     if(new_xm) {
 	gui_playlist_initialize();
 	editing_pat = -1;
-	gui_set_current_pattern(xm->pattern_order_table[0]);
+	gui_set_current_pattern(xm->pattern_order_table[0], TRUE);
 	gtk_spin_button_set_value(GTK_SPIN_BUTTON(curins_spin), 1);
 	current_instrument_changed(GTK_SPIN_BUTTON(curins_spin));
 	modinfo_set_current_instrument(0);
@@ -1315,12 +1322,13 @@
     } else {
 	i = editing_pat;
 	editing_pat = -1;
-	gui_set_current_pattern(i);
+	gui_set_current_pattern(i, TRUE);
     }
     gui_subs_set_slider_value(&tempo_slider, xm->tempo);
     gui_subs_set_slider_value(&bpm_slider, xm->bpm);
     track_editor_set_num_channels(xm->num_channels);
-    gtk_spin_button_set_value(GTK_SPIN_BUTTON(spin_numchans), xm->num_channels);
+    if(updatechspin)
+	gtk_spin_button_set_value(GTK_SPIN_BUTTON(spin_numchans), xm->num_channels);
     scope_group_set_num_channels(scopegroup, xm->num_channels);
     xm_set_modified(m);
 }
@@ -1345,7 +1353,7 @@
 	fprintf(stderr, "Whooops, having memory problems?\n");
 	exit(1);
     }
-    gui_init_xm(1);
+    gui_init_xm(1, TRUE);
 }
 
 void
@@ -1360,7 +1368,7 @@
 	gui_new_xm();
 	statusbar_update(STATUS_IDLE, FALSE);
     } else {
-	gui_init_xm(1);
+	gui_init_xm(1, TRUE);
 	statusbar_update(STATUS_MODULE_LOADED, FALSE);
 	gui_update_title (filename);
     }
@@ -1420,7 +1428,7 @@
 }
 
 void
-gui_set_current_pattern (int p)
+gui_set_current_pattern (int p, gboolean updatespin)
 {
     int m;
 
@@ -1431,7 +1439,8 @@
 
     editing_pat = p;
     tracker_set_pattern(tracker, &xm->patterns[p]);
-    gtk_spin_button_set_value(GTK_SPIN_BUTTON(spin_editpat), p);
+    if(updatespin)
+	gtk_spin_button_set_value(GTK_SPIN_BUTTON(spin_editpat), p);
     gui_update_pattern_data();
 
     xm_set_modified(m);
@@ -1469,6 +1478,7 @@
 gui_set_current_instrument (int n)
 {
     int m = xm_get_modified();
+
     g_return_if_fail(n >= 1 && n <= 128);
     if(n != gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(curins_spin))) {
 	gtk_spin_button_set_value(GTK_SPIN_BUTTON(curins_spin), n);
@@ -1480,7 +1490,7 @@
 gui_set_current_sample (int n)
 {
     int m = xm_get_modified();
-    g_return_if_fail(n >= 0 && n <= 15);
+    g_return_if_fail(n >= 0 && n <= 127);
     if(n != gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(cursmpl_spin))) {
 	gtk_spin_button_set_value(GTK_SPIN_BUTTON(cursmpl_spin), n);
     }
@@ -1549,8 +1559,8 @@
 
     if(nv < 0)
 	nv = 0;
-    else if(nv > 15)
-	nv = 15;
+    else if(nv > 127)
+	nv = 127;
 
     gui_set_current_sample(nv);
 }
@@ -1594,10 +1604,11 @@
 {
     GtkWidget *thing;
 
-    thing = gtk_entry_new_with_max_length(length);
+    thing = gtk_entry_new();
+    gtk_entry_set_max_length(GTK_ENTRY(thing), length);
 
-    gtk_signal_connect_after(GTK_OBJECT(thing), "changed",
-			     GTK_SIGNAL_FUNC(changedfunc), NULL);
+    g_signal_connect_after(GTK_EDITABLE(thing), "insert-text",
+			     G_CALLBACK(changedfunc), NULL);
 
     *widget = thing;
 }
@@ -1714,7 +1725,7 @@
     gdk_rgb_init();
 #endif
 
-    gui_splash_window = gtk_window_new (GTK_WINDOW_DIALOG);
+    gui_splash_window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
 
     gtk_window_set_title (GTK_WINDOW(gui_splash_window), _("SoundTracker Startup"));
 //    gtk_window_set_wmclass (GTK_WINDOW (gui_splash_window), "soundtracker_startup", "SoundTracker");
@@ -1722,8 +1733,8 @@
     gtk_window_set_policy (GTK_WINDOW (gui_splash_window), FALSE, FALSE, FALSE);
     gtk_window_set_modal(GTK_WINDOW(gui_splash_window), TRUE);
 
-    gtk_signal_connect(GTK_OBJECT (gui_splash_window), "delete_event",
-		       GTK_SIGNAL_FUNC (gui_splash_close), NULL);
+    g_signal_connect(gui_splash_window, "delete_event",
+		       G_CALLBACK(gui_splash_close), NULL);
 
     vbox = gtk_vbox_new (FALSE, 4);
     gtk_container_add (GTK_CONTAINER (gui_splash_window), vbox);
@@ -1733,7 +1744,8 @@
     /* Show splash screen if enabled and image available. */
 
 #ifndef NO_GDK_PIXBUF
-    gui_splash_logo = gdk_pixbuf_new_from_file(PREFIX"/share/soundtracker/soundtracker_splash.png");
+    GError *error = NULL;
+    gui_splash_logo = gdk_pixbuf_new_from_file(PREFIX"/share/soundtracker/soundtracker_splash.png", &error);
     if(gui_splash_logo) {
 	thing = gtk_hseparator_new();
 	gtk_widget_show(thing);
@@ -1756,8 +1768,8 @@
 
 	add_empty_vbox(hbox);
 
-	gtk_signal_connect (GTK_OBJECT (logo_area), "expose_event",
-			    GTK_SIGNAL_FUNC (gui_splash_logo_expose),
+	g_signal_connect(logo_area, "expose_event",
+			    G_CALLBACK(gui_splash_logo_expose),
 			    NULL);
 
 	gtk_drawing_area_size (GTK_DRAWING_AREA (logo_area),
@@ -1804,8 +1816,8 @@
 	gui_splash_close_button = thing = gtk_button_new_with_label(_("Use SoundTracker!"));
 	gtk_widget_show(thing);
 	gtk_box_pack_start(GTK_BOX(vbox), thing, FALSE, TRUE, 0);
-	gtk_signal_connect(GTK_OBJECT (thing), "clicked",
-			   GTK_SIGNAL_FUNC(gui_splash_close), NULL);
+	g_signal_connect(thing, "clicked",
+			   (gui_splash_close), NULL);
 	gtk_widget_set_sensitive(thing, FALSE);
     }
 
@@ -1817,6 +1829,19 @@
     return 1;
 }
 
+GtkStyle*
+gui_get_style(void)
+{
+    static GtkStyle *style = NULL;
+    
+    if(!style) {
+	if(!GTK_WIDGET_REALIZED(mainwindow))
+	    gtk_widget_realize(mainwindow); /* to produce the correct style... */
+	style = gtk_widget_get_style(mainwindow);
+    }
+    return style;
+}
+
 int
 gui_final (int argc,
 	   char *argv[])
@@ -1842,8 +1867,8 @@
     gtk_window_set_title (GTK_WINDOW (mainwindow), "SoundTracker " VERSION);
 #endif
 
-    gtk_signal_connect (GTK_OBJECT (mainwindow), "delete_event",
-			GTK_SIGNAL_FUNC (menubar_quit_requested), NULL);
+    g_signal_connect(mainwindow, "delete_event",
+			G_CALLBACK(menubar_quit_requested), NULL);
 
     if(gui_splash_window) {
 	gtk_window_set_transient_for(GTK_WINDOW(gui_splash_window),
@@ -1901,18 +1926,18 @@
     gtk_widget_show(thing);
 
     playlist = PLAYLIST(thing);
-    gtk_signal_connect (GTK_OBJECT (playlist), "current_position_changed",
-			GTK_SIGNAL_FUNC (gui_playlist_position_changed), NULL);
-    gtk_signal_connect (GTK_OBJECT (playlist), "restart_position_changed",
-			GTK_SIGNAL_FUNC (gui_playlist_restart_position_changed), NULL);
-    gtk_signal_connect (GTK_OBJECT (playlist), "song_length_changed",
-			GTK_SIGNAL_FUNC (gui_playlist_song_length_changed), NULL);
-    gtk_signal_connect (GTK_OBJECT (playlist), "entry_changed",
-			GTK_SIGNAL_FUNC (gui_playlist_entry_changed), NULL);
-    gtk_signal_connect (GTK_OBJECT (playlist->ifbutton), "clicked",
-			GTK_SIGNAL_FUNC (gui_add_free_pattern), playlist);
-    gtk_signal_connect (GTK_OBJECT (playlist->icbutton), "clicked",
-			GTK_SIGNAL_FUNC (gui_add_free_pattern_and_copy), playlist);
+    g_signal_connect(playlist, "current_position_changed",
+			G_CALLBACK(gui_playlist_position_changed), NULL);
+    g_signal_connect(playlist, "restart_position_changed",
+			G_CALLBACK(gui_playlist_restart_position_changed), NULL);
+    g_signal_connect(playlist, "song_length_changed",
+			G_CALLBACK(gui_playlist_song_length_changed), NULL);
+    g_signal_connect(playlist, "entry_changed",
+			G_CALLBACK(gui_playlist_entry_changed), NULL);
+    g_signal_connect(playlist->ifbutton, "clicked",
+			G_CALLBACK(gui_add_free_pattern), playlist);
+    g_signal_connect(playlist->icbutton, "clicked",
+			G_CALLBACK(gui_add_free_pattern_and_copy), playlist);
     
     thing = gtk_vseparator_new();
     gtk_box_pack_start(GTK_BOX(mainwindow_upper_hbox), thing, FALSE, TRUE, 0);
@@ -1926,8 +1951,9 @@
     gtk_box_pack_start(GTK_BOX(mainwindow_upper_hbox), table, FALSE, TRUE, 0);
     gtk_widget_show(table);
 
-    gtk_widget_realize(mainwindow); /* to produce the correct style... */
-    style = gtk_widget_get_style(mainwindow);
+//    gtk_widget_realize(mainwindow); /* to produce the correct style... */
+//    style = gtk_widget_get_style(mainwindow);
+    style = gui_get_style();
     hbox = gtk_hbox_new(FALSE, 4);
     gtk_table_attach_defaults(GTK_TABLE(table), hbox, 0, 2, 0, 1);
     gtk_widget_show(hbox);
@@ -1938,8 +1964,8 @@
     pmw = gtk_pixmap_new(pm, mask);
     pbutton = thing = gtk_button_new();
     gtk_container_add(GTK_CONTAINER(thing), pmw);
-    gtk_signal_connect (GTK_OBJECT (thing), "clicked",
-			GTK_SIGNAL_FUNC(play_song), NULL);
+    g_signal_connect(thing, "clicked",
+			G_CALLBACK(play_song), NULL);
     gtk_box_pack_start(GTK_BOX(hbox), thing, FALSE, FALSE,0);
     gui_hang_tooltip(thing, _("Play Song"));
     gtk_widget_show_all(thing);
@@ -1950,8 +1976,8 @@
     pmw = gtk_pixmap_new(pm, mask);
     thing = gtk_button_new();
     gtk_container_add(GTK_CONTAINER(thing), pmw);
-    gtk_signal_connect (GTK_OBJECT (thing), "clicked",
-			GTK_SIGNAL_FUNC(play_pattern), NULL);
+    g_signal_connect(thing, "clicked",
+			G_CALLBACK(play_pattern), NULL);
     gtk_box_pack_start(GTK_BOX(hbox), thing, FALSE, FALSE,0);
     gui_hang_tooltip(thing, _("Play Pattern"));
     gtk_widget_show_all(thing);
@@ -1962,8 +1988,8 @@
     pmw = gtk_pixmap_new(pm, mask);
     thing = gtk_button_new();
     gtk_container_add(GTK_CONTAINER(thing), pmw);
-    gtk_signal_connect (GTK_OBJECT (thing), "clicked",
-			GTK_SIGNAL_FUNC(gui_play_stop), NULL);
+    g_signal_connect(thing, "clicked",
+			G_CALLBACK(gui_play_stop), NULL);
     gtk_box_pack_start(GTK_BOX(hbox), thing, FALSE, FALSE,0);		
     gui_hang_tooltip(thing, _("Stop"));
     gtk_widget_show_all(thing);
@@ -1974,13 +2000,13 @@
     gtk_box_pack_start(GTK_BOX(hbox), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
 
-    spin_editpat = extspinbutton_new(GTK_ADJUSTMENT(gtk_adjustment_new(0, 0, 255, 1.0, 10.0, 0.0)), 0, 0);
+    spin_editpat = extspinbutton_new(GTK_ADJUSTMENT(gtk_adjustment_new(0, 0, 255, 1.0, 10.0, 0.0)), 1, 0);
     extspinbutton_disable_size_hack(EXTSPINBUTTON(spin_editpat));
     gui_hang_tooltip(spin_editpat, _("Edited pattern"));
     gtk_box_pack_start(GTK_BOX(hbox), spin_editpat, FALSE, TRUE, 0);
     gtk_widget_show(spin_editpat);
-    gtk_signal_connect(GTK_OBJECT(spin_editpat), "changed",
-		       GTK_SIGNAL_FUNC(gui_editpat_changed), NULL);
+    g_signal_connect(spin_editpat, "value-changed",
+		     G_CALLBACK(gui_editpat_changed), NULL);
 		       
     pm = gdk_pixmap_create_from_xpm(mainwindow->window,
 	&mask, &style->bg[GTK_STATE_NORMAL],
@@ -2011,11 +2037,11 @@
 
     add_empty_hbox(hbox);
 
-    spin_numchans = extspinbutton_new(GTK_ADJUSTMENT(gtk_adjustment_new(8, 2, 32, 2.0, 8.0, 0.0)), 0, 0);
+    spin_numchans = extspinbutton_new(GTK_ADJUSTMENT(gtk_adjustment_new(8, 2, 32, 2.0, 8.0, 0.0)), 1, 0);
     extspinbutton_disable_size_hack(EXTSPINBUTTON(spin_numchans));
     gtk_box_pack_start(GTK_BOX(hbox), spin_numchans, FALSE, TRUE, 0);
-    gtk_signal_connect(GTK_OBJECT(spin_numchans), "changed",
-		       GTK_SIGNAL_FUNC(gui_numchans_changed), NULL);
+    g_signal_connect(spin_numchans, "value-changed",
+		       G_CALLBACK(gui_numchans_changed), NULL);
     gtk_widget_show(spin_numchans);
 
     hbox = gtk_hbox_new(FALSE, 4);
@@ -2028,11 +2054,11 @@
 
     add_empty_hbox(hbox);
 
-    spin_patlen = extspinbutton_new(GTK_ADJUSTMENT(gtk_adjustment_new(64, 1, 256, 1.0, 16.0, 0.0)), 0, 0);
+    spin_patlen = extspinbutton_new(GTK_ADJUSTMENT(gtk_adjustment_new(64, 1, 256, 1.0, 16.0, 0.0)), 1, 0);
     extspinbutton_disable_size_hack(EXTSPINBUTTON(spin_patlen));
     gtk_box_pack_start(GTK_BOX(hbox), spin_patlen, FALSE, TRUE, 0);
-    gtk_signal_connect(GTK_OBJECT(spin_patlen), "changed",
-		       GTK_SIGNAL_FUNC(gui_patlen_changed), NULL);
+    g_signal_connect(spin_patlen, "value-changed",
+		       G_CALLBACK(gui_patlen_changed), NULL);
     gtk_widget_show(spin_patlen);
 
     hbox = gtk_hbox_new(FALSE, 4);
@@ -2059,16 +2085,16 @@
     gtk_box_pack_start(GTK_BOX(hbox), thing, FALSE, FALSE, 0);
     gui_hang_tooltip(thing, _("Set preferred accidental type"));
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(gui_accidentals_clicked), NULL);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(gui_accidentals_clicked), NULL);
 
     add_empty_hbox(hbox);
     thing = gtk_toggle_button_new_with_label(_("Measure"));
     gui_hang_tooltip(thing, _("Enable row highlighting"));
     gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(thing),gui_settings.highlight_rows);
     gtk_box_pack_start(GTK_BOX(hbox), thing, FALSE, FALSE, 0);
-    gtk_signal_connect(GTK_OBJECT(thing), "toggled",
-		       GTK_SIGNAL_FUNC(gui_highlight_rows_toggled), NULL);
+    g_signal_connect(thing, "toggled",
+		       G_CALLBACK(gui_highlight_rows_toggled), NULL);
     gtk_widget_show(thing);
 
     thing = gtk_combo_new();
@@ -2083,7 +2109,8 @@
     selected = -1;
     for(i = 0; measure_msr[i].title != NULL; i++) {
 	glist = g_list_append(glist, (gpointer)measure_msr[i].title);
-	if ((cur = gdk_string_width(style->font, measure_msr[i].title)) > wdth)
+	if ((cur = gdk_string_width(gdk_font_from_description(style->font_desc),
+				    measure_msr[i].title)) > wdth)
 	    wdth = cur;
 	if ((measure_msr[i].major == gui_settings.highlight_rows_n) &&
 	    (measure_msr[i].minor == gui_settings.highlight_rows_minor_n))
@@ -2092,18 +2119,19 @@
     if (selected == -1) selected = i;
     other = _("Other...");
     glist = g_list_append(glist, other);
-    if ((cur = gdk_string_width(style->font,other)) > wdth) wdth = cur;
+    if ((cur = gdk_string_width(gdk_font_from_description(style->font_desc),
+				    other)) > wdth) wdth = cur;
 
     gtk_combo_set_popdown_strings(GTK_COMBO(thing), glist);
     list = GTK_COMBO(thing)->list;
     gtk_list_select_item(GTK_LIST(list), selected);
-    gtk_signal_connect(GTK_OBJECT(list), "select_child",
-		       GTK_SIGNAL_FUNC(measure_changed), NULL);
+    g_signal_connect(list, "select_child",
+		       G_CALLBACK(measure_changed), NULL);
     /* the direct use of combo->popwin is not recommended, but I couldn't find another way... */
-    gtk_signal_connect(GTK_OBJECT(GTK_COMBO(thing)->popwin), "hide",
-		       GTK_SIGNAL_FUNC(popwin_hide), entry);
+    g_signal_connect(GTK_COMBO(thing)->popwin, "hide",
+		       G_CALLBACK(popwin_hide), entry);
     
-    gtk_widget_set_usize(entry, wdth + 5, -1);//-1 to suppress the height changing
+    gtk_widget_set_size_request(entry, wdth + 5, -1);//-1 to suppress the height changing
     gtk_entry_set_editable(GTK_ENTRY(entry), FALSE);
     
     add_empty_hbox(hbox);
@@ -2128,8 +2156,8 @@
     gtk_box_pack_start(GTK_BOX(hbox), thing, FALSE, FALSE, 0);
     gui_hang_tooltip(thing, _("Change effect column editing direction"));
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(gui_direction_clicked), NULL);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(gui_direction_clicked), NULL);
     
     /* Scopes Group or Instrument / Sample Listing */
 
@@ -2138,7 +2166,8 @@
     gtk_widget_show(thing);
 
 #ifndef NO_GDK_PIXBUF
-    scopegroup = SCOPE_GROUP(scope_group_new(gdk_pixbuf_new_from_file(PREFIX"/share/soundtracker/muted.png")));
+    GError *error = NULL;
+    scopegroup = SCOPE_GROUP(scope_group_new(gdk_pixbuf_new_from_file(PREFIX"/share/soundtracker/muted.png", &error)));
 #else
     scopegroup = SCOPE_GROUP(scope_group_new());
 #endif
@@ -2161,8 +2190,8 @@
     gtk_scale_set_draw_value(GTK_SCALE(thing), FALSE);
     gtk_widget_show(thing);
     gtk_box_pack_start(GTK_BOX(hbox), thing, TRUE, TRUE, 0);
-    gtk_signal_connect (GTK_OBJECT(adj_amplification), "value_changed",
-			GTK_SIGNAL_FUNC(gui_adj_amplification_changed), NULL);
+    g_signal_connect(adj_amplification, "value_changed",
+			G_CALLBACK(gui_adj_amplification_changed), NULL);
 
     frame = gtk_frame_new(NULL);
     gtk_frame_set_shadow_type (GTK_FRAME (frame), GTK_SHADOW_IN);
@@ -2184,7 +2213,7 @@
     gui_clipping_led_off.pixel = 0;
     gdk_color_alloc(colormap, &gui_clipping_led_on);
     gdk_color_alloc(colormap, &gui_clipping_led_off);
-    gtk_signal_connect(GTK_OBJECT(thing), "event", GTK_SIGNAL_FUNC(gui_clipping_led_event), thing);
+    g_signal_connect(thing, "event", G_CALLBACK(gui_clipping_led_event), thing);
     gtk_widget_show (thing);
 
     hbox = gtk_vbox_new(FALSE, 2);
@@ -2197,15 +2226,15 @@
     gtk_scale_set_draw_value(GTK_SCALE(thing), FALSE);
     gtk_widget_show(thing);
     gtk_box_pack_start(GTK_BOX(hbox), thing, TRUE, TRUE, 0);
-    gtk_signal_connect (GTK_OBJECT(adj_pitchbend), "value_changed",
-			GTK_SIGNAL_FUNC(gui_adj_pitchbend_changed), NULL);
+    g_signal_connect(adj_pitchbend, "value_changed",
+			G_CALLBACK(gui_adj_pitchbend_changed), NULL);
 
     thing = gtk_button_new_with_label("R");
     gui_hang_tooltip(thing, _("Reset pitchbend to its normal value"));
     gtk_widget_show(thing);
     gtk_box_pack_start(GTK_BOX(hbox), thing, FALSE, TRUE, 0);
-    gtk_signal_connect (GTK_OBJECT (thing), "clicked",
-			GTK_SIGNAL_FUNC(gui_reset_pitch_bender), NULL);
+    g_signal_connect(thing, "clicked",
+			G_CALLBACK(gui_reset_pitch_bender), NULL);
 
     /* Instrument, sample, editing status */
 
@@ -2217,8 +2246,8 @@
     gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(thing), 0);
     gtk_box_pack_start(GTK_BOX(hbox), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect (GTK_OBJECT(thing), "toggled",
-			GTK_SIGNAL_FUNC(editing_toggled), NULL);
+    g_signal_connect (thing, "toggled",
+			G_CALLBACK(editing_toggled), NULL);
 
     thing = gtk_label_new(_("Octave"));
     gtk_box_pack_start(GTK_BOX(hbox), thing, FALSE, TRUE, 0);
@@ -2246,29 +2275,29 @@
     extspinbutton_disable_size_hack(EXTSPINBUTTON(curins_spin));
     gtk_box_pack_start(GTK_BOX(hbox), curins_spin, FALSE, TRUE, 0);
     gtk_widget_show(curins_spin);
-    gtk_signal_connect (GTK_OBJECT(curins_spin), "changed",
-			GTK_SIGNAL_FUNC(current_instrument_changed), NULL);
+    g_signal_connect(curins_spin, "value-changed",
+			G_CALLBACK(current_instrument_changed), NULL);
 
     gui_get_text_entry(22, current_instrument_name_changed, &gui_curins_name);
     gtk_box_pack_start(GTK_BOX(hbox), gui_curins_name, TRUE, TRUE, 0);
     gtk_widget_show(gui_curins_name);
-    gtk_widget_set_usize(gui_curins_name, 100, gui_curins_name->requisition.height);
+    gtk_widget_set_size_request(gui_curins_name, 100, gui_curins_name->requisition.height);
 
     thing = gtk_label_new(_("Sample"));
     gtk_box_pack_start(GTK_BOX(hbox), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
 
-    cursmpl_spin = extspinbutton_new(GTK_ADJUSTMENT(gtk_adjustment_new(0.0, 0.0, 15.0, 1.0, 4.0, 0.0)), 0, 0);
+    cursmpl_spin = extspinbutton_new(GTK_ADJUSTMENT(gtk_adjustment_new(0.0, 0.0, 127.0, 1.0, 4.0, 0.0)), 0, 0);
     extspinbutton_disable_size_hack(EXTSPINBUTTON(cursmpl_spin));
     gtk_box_pack_start(GTK_BOX(hbox), cursmpl_spin, FALSE, TRUE, 0);
     gtk_widget_show(cursmpl_spin);
-    gtk_signal_connect (GTK_OBJECT(cursmpl_spin), "changed",
-			GTK_SIGNAL_FUNC(current_sample_changed), NULL);
+    g_signal_connect(cursmpl_spin, "value-changed",
+			G_CALLBACK(current_sample_changed), NULL);
 
     gui_get_text_entry(22, current_sample_name_changed, &gui_cursmpl_name);
     gtk_box_pack_start(GTK_BOX(hbox), gui_cursmpl_name, TRUE, TRUE, 0);
     gtk_widget_show(gui_cursmpl_name);
-    gtk_widget_set_usize(gui_cursmpl_name, 100, gui_cursmpl_name->requisition.height);
+    gtk_widget_set_size_request(gui_cursmpl_name, 100, gui_cursmpl_name->requisition.height);
 
     /* The notebook */
 
@@ -2277,8 +2306,8 @@
     gtk_notebook_set_tab_pos(GTK_NOTEBOOK(notebook), GTK_POS_TOP);
     gtk_widget_show(notebook);
     gtk_container_border_width(GTK_CONTAINER(notebook), 0);
-    gtk_signal_connect(GTK_OBJECT(notebook), "switch_page",
-		       GTK_SIGNAL_FUNC(notebook_page_switched), NULL);
+    g_signal_connect(notebook, "switch_page",
+		       G_CALLBACK(notebook_page_switched), NULL);
 
     fileops_page_create(GTK_NOTEBOOK(notebook));
     tracker_page_create(GTK_NOTEBOOK(notebook));
@@ -2296,8 +2325,9 @@
 #define WELCOME_MESSAGE _("Welcome to SoundTracker!")
 
 #ifdef USE_GNOME
-    dockitem = gnome_dock_item_new("Status Bar", (GNOME_DOCK_ITEM_BEH_EXCLUSIVE | GNOME_DOCK_ITEM_BEH_NEVER_VERTICAL));
-    gnome_app_add_dock_item(GNOME_APP(mainwindow), GNOME_DOCK_ITEM(dockitem), GNOME_DOCK_BOTTOM, 0, 0, 0);
+    dockitem = bonobo_dock_item_new("Status Bar", (BONOBO_DOCK_ITEM_BEH_EXCLUSIVE | BONOBO_DOCK_ITEM_BEH_NEVER_VERTICAL));
+    gnome_app_add_dock_item(GNOME_APP(mainwindow), BONOBO_DOCK_ITEM(dockitem),
+		   BONOBO_DOCK_BOTTOM, 0, 0, 0);
     gtk_widget_show(dockitem);
 
     hbox = gtk_hbox_new(FALSE, 2);
@@ -2308,21 +2338,14 @@
     status_bar = gnome_appbar_new (FALSE, TRUE, GNOME_PREFERENCES_NEVER);
     gtk_widget_show (status_bar);
     gtk_box_pack_start (GTK_BOX (hbox), status_bar, TRUE, TRUE, 0);
-    gtk_widget_set_usize (status_bar, 300 , 20); /* so that it doesn't vanish when undocked */
+    gtk_widget_set_size_request (status_bar, 300 , 20); /* so that it doesn't vanish when undocked */
 
     thing = gtk_frame_new (NULL);
     gtk_widget_show (thing);
     gtk_box_pack_start (GTK_BOX (hbox), thing, FALSE, FALSE, 0);
-    gtk_widget_set_usize (thing, 48, 20);
+    gtk_widget_set_size_request (thing, 48, 20);
     gtk_frame_set_shadow_type (GTK_FRAME (thing), GTK_SHADOW_IN);
 
-    st_clock = gtk_clock_new (GTK_CLOCK_INCREASING);
-    gtk_widget_show (st_clock);
-    gtk_container_add (GTK_CONTAINER (thing), st_clock);
-    gtk_widget_set_usize (st_clock, 48, 20);
-    gtk_clock_set_format (GTK_CLOCK (st_clock), _("%M:%S"));
-    gtk_clock_set_seconds(GTK_CLOCK (st_clock), 0);
-
     gnome_appbar_set_status(GNOME_APPBAR(status_bar), WELCOME_MESSAGE);
 #else
     thing = gtk_hbox_new(FALSE, 1);
@@ -2332,7 +2355,7 @@
     status_bar = gtk_statusbar_new();
     gtk_box_pack_start(GTK_BOX (thing), status_bar, TRUE, TRUE, 0);
     gtk_widget_show(status_bar);
-    gtk_widget_set_usize(status_bar, -2, 20);
+    gtk_widget_set_size_request(status_bar, -1, 20);
 
     statusbar_context_id = gtk_statusbar_get_context_id(GTK_STATUSBAR(status_bar), "ST Statusbar");
     gtk_statusbar_push(GTK_STATUSBAR(status_bar), statusbar_context_id, WELCOME_MESSAGE);
@@ -2340,8 +2363,8 @@
     
     /* capture all key presses */
     gtk_widget_add_events(GTK_WIDGET(mainwindow), GDK_KEY_RELEASE_MASK);
-    gtk_signal_connect(GTK_OBJECT(mainwindow), "key_press_event", GTK_SIGNAL_FUNC(keyevent), (gpointer)1);
-    gtk_signal_connect(GTK_OBJECT(mainwindow), "key_release_event", GTK_SIGNAL_FUNC(keyevent), (gpointer)0);
+    g_signal_connect(mainwindow, "key-press-event", G_CALLBACK(keyevent), (gpointer)1);
+    g_signal_connect(mainwindow, "key_release_event", G_CALLBACK(keyevent), (gpointer)0);
 
     if(argc == 2) {
 	gui_load_xm(argv[1]);
@@ -2373,8 +2396,8 @@
 	    if(gui_splash_logo) {
 		gtk_widget_add_events(gui_splash_logo_area,
 				      GDK_BUTTON_PRESS_MASK);
-		gtk_signal_connect (GTK_OBJECT (gui_splash_logo_area), "button_press_event",
-				    GTK_SIGNAL_FUNC (gui_splash_close),
+		g_signal_connect(gui_splash_logo_area, "button_press_event",
+				    G_CALLBACK(gui_splash_close),
 				    NULL);
 	    }
 #endif
@@ -2384,5 +2407,6 @@
 	}
     }
 
+    gtk_widget_grab_focus(pbutton);
     return 1;
 }
diff -Naur soundtracker-0.6.8/app/gui.h soundtracker-0.6.8-gtk2/app/gui.h
--- soundtracker-0.6.8/app/gui.h	2006-02-25 13:12:12.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/gui.h	2010-09-23 11:11:35.000000000 +0200
@@ -85,7 +85,7 @@
 
 void                 gui_set_current_instrument       (int);
 void                 gui_set_current_sample           (int);
-void                 gui_set_current_pattern          (int);
+void                 gui_set_current_pattern          (int, gboolean);
 void                 gui_update_pattern_data          (void);
 
 int                  gui_get_current_instrument       (void);
@@ -99,7 +99,7 @@
 void                 gui_update_player_pos            (const audio_player_pos *p);
 void                 gui_clipping_indicator_update    (double songtime);
 
-void                 gui_init_xm                      (int new_xm);
+void                 gui_init_xm                      (int new_xm, gboolean updatechspin);
 void                 gui_free_xm                      (void);
 void                 gui_new_xm                       (void);
 void                 gui_load_xm                      (const char *filename);
@@ -113,4 +113,5 @@
 void		     gui_expand_pattern		      (void);	
 void		     play_song			      (void);
 
+GtkStyle*	     gui_get_style		      (void);
 #endif /* _GUI_H */
diff -Naur soundtracker-0.6.8/app/gui-settings.c soundtracker-0.6.8-gtk2/app/gui-settings.c
--- soundtracker-0.6.8/app/gui-settings.c	2006-02-25 13:30:54.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/gui-settings.c	2010-09-23 11:11:35.000000000 +0200
@@ -3,6 +3,7 @@
  * The Real SoundTracker - GUI configuration dialog
  *
  * Copyright (C) 1999-2001 Michael Krause
+ * Copyright (C) 2006 Yury Aliaev (GTK+-2 porting)
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -90,6 +91,25 @@
     "bunzip2"
 };
 
+static const gchar *color_meanings[] = {
+    N_("Tracker background"),
+    N_("Cursor background"),
+    N_("Major lines highlighting"),
+    N_("Minor lines highlighting"),
+    N_("Selection"),
+    N_("Notes"),
+    N_("Delimiters"),
+    N_("Channel numbers"),
+    N_("Cursor idle"),
+    N_("Cursor editing")
+};
+
+gui_prefs_colors gui_settings_colors;
+
+static GtkWidget *col_samples[TRACKERCOL_LAST];
+static GtkWidget *colorsel;
+static guint active_col_item = 0;
+
 static GtkWidget *configwindow = NULL;
 static GtkWidget *ts_box = NULL;
 
@@ -106,13 +126,7 @@
 static void
 gui_settings_close_requested (void)
 {
-/* I needed to change this code because I use some object from gui settings
-   window in the other place and these objects must not be destroyed. (yaliaev)
-    gtk_container_remove(GTK_CONTAINER(ts_box), trackersettings);
-    gtk_widget_destroy(configwindow);
-*/
     gdk_window_hide(configwindow->window);
-//    configwindow = NULL;
 }
 
 static void
@@ -226,7 +240,7 @@
 static void
 gui_settings_tracker_line_note_modified(GtkEntry *entry)
 {
-    gchar *text = gtk_entry_get_text(entry);
+    gchar* text = g_strdup(gtk_entry_get_text(entry));
     int i;
 
     for(i=0 ; i<3 ; i++)    {
@@ -240,12 +254,13 @@
 	strncpy(gui_settings.tracker_line_format, text, 3);
 	tracker_redraw(tracker);
     }
+    g_free(text);
 }
 
 static void
 gui_settings_tracker_line_ins_modified(GtkEntry *entry)
 {
-    gchar *text = gtk_entry_get_text(entry);
+    gchar *text = g_strdup(gtk_entry_get_text(entry));
     int i;
 
     for(i=0 ; i<2 ; i++)    {
@@ -259,12 +274,13 @@
           strncpy(gui_settings.tracker_line_format+3, text, 2);
      	   tracker_redraw(tracker);
     }
+    g_free(text);
 }
 
 static void
 gui_settings_tracker_line_vol_modified(GtkEntry *entry)
 {
-    gchar *text = gtk_entry_get_text(entry);
+    gchar *text = g_strdup(gtk_entry_get_text(entry));
     int i;
 
     for(i=0 ; i<2 ; i++)    {
@@ -278,12 +294,13 @@
           strncpy(gui_settings.tracker_line_format+5, text, 2);
      	   tracker_redraw(tracker);
     }
+    g_free(text);
 }
 
 static void
 gui_settings_tracker_line_effect_modified(GtkEntry *entry, GdkEventKey *event)
 {
-    gchar *text = gtk_entry_get_text(entry);
+    gchar *text = g_strdup(gtk_entry_get_text(entry));
     int i;
 
     for(i=0 ; i<3 ; i++)    {
@@ -297,6 +314,135 @@
           strncpy(gui_settings.tracker_line_format+7, text, 3);
      	   tracker_redraw(tracker);
     }
+    g_free(text);
+}
+
+static gboolean
+col_sample_paint (GtkWidget *widget, GdkEvent *event, guint n)
+{
+    static GdkGC *gc = NULL;
+    
+    if(!gc)
+	gc = gdk_gc_new(widget->window);
+
+    gdk_gc_set_foreground(gc, &tracker->colors[n]);
+    gdk_draw_rectangle(widget->window, gc, TRUE, 0, 0, widget->allocation.width, widget->allocation.height);
+    return TRUE;
+}
+
+static void
+colors_dialog_response (GtkWidget *dialog, gint response)
+{
+    guint i;
+
+    switch (response) {
+    case GTK_RESPONSE_CLOSE:
+	gtk_widget_hide(dialog);
+	break;
+    case GTK_RESPONSE_APPLY:
+	tracker_apply_colors(tracker);
+	tracker_redraw(tracker);
+	break;
+    case GTK_RESPONSE_REJECT:
+	tracker_init_colors(tracker);
+	tracker_redraw(tracker);
+	for(i = 0; i < TRACKERCOL_LAST; i++)
+	    col_sample_paint(col_samples[i], NULL, i);
+	gtk_color_selection_set_current_color(GTK_COLOR_SELECTION(colorsel), &tracker->colors[active_col_item]);
+    default:
+	break;
+    }
+}
+
+static void
+col_item_toggled (GtkToggleButton *butt, guint n)
+{
+    if(gtk_toggle_button_get_active(butt)) {
+	active_col_item = n;
+	gtk_color_selection_set_current_color(GTK_COLOR_SELECTION(colorsel), &tracker->colors[n]);
+    }
+}
+
+static void
+color_changed (void)
+{
+    gtk_color_selection_get_current_color(GTK_COLOR_SELECTION(colorsel), &tracker->colors[active_col_item]);
+    gdk_color_alloc(gtk_widget_get_colormap(colorsel), &tracker->colors[active_col_item]);
+    col_sample_paint(col_samples[active_col_item], NULL, active_col_item);
+}
+
+static void
+gui_settings_tracker_colors_dialog (GtkWindow *window)
+{
+    static GtkWidget *dialog;
+    GtkWidget *thing, *table, *radio, *hbox;
+    GtkBoxChild *child;
+    guint i;
+
+    if(dialog) {
+	gtk_widget_show(dialog);
+	gdk_window_raise(dialog->window);
+	return;
+    }
+
+    dialog = gtk_dialog_new_with_buttons(_("Tracker colors configuration"), window,
+					 GTK_DIALOG_DESTROY_WITH_PARENT,
+					 _("Reset"), GTK_RESPONSE_REJECT,
+					 GTK_STOCK_APPLY, GTK_RESPONSE_APPLY,
+					 GTK_STOCK_CLOSE, GTK_RESPONSE_CLOSE, NULL);
+
+    /* Heavy Gtk+ hack just to access the button widget... */
+    child = g_list_nth_data(GTK_BOX(GTK_DIALOG(dialog)->action_area)->children, 0);
+    gui_hang_tooltip(child->widget, _("Reset tracker colors to standard ST"));
+
+    g_signal_connect(dialog, "delete_event",
+		     G_CALLBACK(gtk_widget_hide), NULL);
+    g_signal_connect(dialog, "response",
+		     G_CALLBACK(colors_dialog_response), NULL);
+
+    table = gtk_table_new(TRACKERCOL_LAST, 5, FALSE);
+    for(i = 0; i < TRACKERCOL_LAST; i++) {
+	radio = i ? gtk_radio_button_new_from_widget(GTK_RADIO_BUTTON(radio))
+		  : gtk_radio_button_new(NULL);
+	gtk_table_attach_defaults(GTK_TABLE(table), radio, 0, 1, i, i+1);
+	g_signal_connect(radio, "toggled",
+			 G_CALLBACK(col_item_toggled), (gpointer)i);
+
+	col_samples[i] = gtk_drawing_area_new();
+	gtk_table_attach_defaults(GTK_TABLE(table), col_samples[i], 1, 2, i, i+1);
+	g_signal_connect(col_samples[i],"expose_event",
+			 G_CALLBACK(col_sample_paint), (gpointer)i);
+
+	hbox = gtk_hbox_new(FALSE, 0);
+	thing = gtk_label_new(_(color_meanings[i]));
+	gtk_box_pack_start(GTK_BOX(hbox), thing, FALSE, FALSE, 0);
+	gtk_table_attach_defaults(GTK_TABLE(table), hbox, 2, 3, i, i+1);
+	gtk_table_set_row_spacing(GTK_TABLE(table), i, 2);
+    }
+
+    thing = gtk_vseparator_new();
+    gtk_table_attach_defaults(GTK_TABLE(table), thing, 3, 4, 0, TRACKERCOL_LAST - 1);
+    gtk_table_set_col_spacing(GTK_TABLE(table), 1, 2);
+    gtk_table_set_col_spacing(GTK_TABLE(table), 3, 2);
+
+    colorsel = gtk_color_selection_new();
+    gtk_color_selection_set_current_color(GTK_COLOR_SELECTION(colorsel), &tracker->colors[0]);
+    g_signal_connect(colorsel, "color_changed",
+		     G_CALLBACK(color_changed), NULL);
+    gtk_table_attach_defaults(GTK_TABLE(table), colorsel, 4, 5, 0, TRACKERCOL_LAST - 1);
+
+    gtk_widget_show_all(table);
+    gtk_box_pack_start(GTK_BOX(GTK_DIALOG(dialog)->vbox), table, TRUE, TRUE, 0);
+
+    gtk_widget_realize(dialog);
+
+    for(i = 0; i < TRACKERCOL_LAST; i++)
+	gtk_widget_set_size_request(col_samples[i], radio->allocation.width * 2, radio->allocation.height);
+
+    gtk_widget_show(dialog);
+
+    for(i = 0; i < TRACKERCOL_LAST; i++)
+	col_sample_paint(col_samples[i], NULL, i);
 }
 
 void
@@ -319,8 +465,8 @@
     configwindow = gtk_window_new(GTK_WINDOW_TOPLEVEL);
     gtk_window_set_title(GTK_WINDOW(configwindow), _("GUI Configuration"));
 #endif
-    gtk_signal_connect (GTK_OBJECT (configwindow), "delete_event",
-			GTK_SIGNAL_FUNC (gui_settings_close_requested), NULL);
+    g_signal_connect (configwindow, "delete_event",
+			G_CALLBACK(gui_settings_close_requested), NULL);
 //    gtk_window_set_policy(GTK_WINDOW(configwindow), FALSE, FALSE, FALSE);
 
     mainbox = gtk_vbox_new(FALSE, 2);
@@ -355,57 +501,57 @@
     gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(thing), gui_settings.tracker_hexmode);
     gtk_box_pack_start(GTK_BOX(vbox1), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "toggled",
-		       GTK_SIGNAL_FUNC(gui_settings_hexmode_toggled), NULL);
+    g_signal_connect(thing, "toggled",
+		       G_CALLBACK(gui_settings_hexmode_toggled), NULL);
 
     thing = gtk_check_button_new_with_label(_("Use upper case letters for hex numbers"));
     gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(thing), gui_settings.tracker_upcase);
     gtk_box_pack_start(GTK_BOX(vbox1), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "toggled",
-		       GTK_SIGNAL_FUNC(gui_settings_upcase_toggled), NULL);
+    g_signal_connect(thing, "toggled",
+		       G_CALLBACK(gui_settings_upcase_toggled), NULL);
 
     thing = gtk_check_button_new_with_label(_("Asynchronous (IT-style) pattern editing"));
     gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(thing), gui_settings.asynchronous_editing);
     gtk_box_pack_start(GTK_BOX(vbox1), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "toggled",
-		       GTK_SIGNAL_FUNC(gui_settings_asyncedit_toggled), NULL);
+    g_signal_connect(thing, "toggled",
+		       G_CALLBACK(gui_settings_asyncedit_toggled), NULL);
 
     thing = gtk_check_button_new_with_label(_("Fxx command updates Tempo/BPM sliders"));
     gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(thing), gui_settings.tempo_bpm_update);
     gtk_box_pack_start(GTK_BOX(vbox1), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "toggled",
-		       GTK_SIGNAL_FUNC(gui_settings_tempo_bpm_update_toggled), NULL);
+    g_signal_connect(thing, "toggled",
+		       G_CALLBACK(gui_settings_tempo_bpm_update_toggled), NULL);
 
     thing = gtk_check_button_new_with_label(_("Switch to tracker after loading/saving"));
     gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(thing), gui_settings.auto_switch);
     gtk_box_pack_start(GTK_BOX(vbox1), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "toggled",
-		       GTK_SIGNAL_FUNC(gui_settings_auto_switch_toggled), NULL);
+    g_signal_connect(thing, "toggled",
+		       G_CALLBACK(gui_settings_auto_switch_toggled), NULL);
 
     thing = gtk_check_button_new_with_label(_("Save window geometry on exit"));
     gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(thing), gui_settings.save_geometry);
     gtk_box_pack_start(GTK_BOX(vbox1), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "toggled",
-		       GTK_SIGNAL_FUNC(gui_settings_save_geometry_toggled), NULL);
+    g_signal_connect(thing, "toggled",
+		       G_CALLBACK(gui_settings_save_geometry_toggled), NULL);
 
     thing = gtk_check_button_new_with_label(_("Use note name B instead of H"));
     gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(thing), gui_settings.bh);
     gtk_box_pack_start(GTK_BOX(vbox1), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "toggled",
-		       GTK_SIGNAL_FUNC(gui_settings_bh_toggled), NULL);
+    g_signal_connect(thing, "toggled",
+		       G_CALLBACK(gui_settings_bh_toggled), NULL);
 
     thing = gtk_check_button_new_with_label(_("Save and restore permanent channels"));
     gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(thing), gui_settings.store_perm);
     gtk_box_pack_start(GTK_BOX(vbox1), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "toggled",
-		       GTK_SIGNAL_FUNC(gui_settings_perm_toggled), NULL);
+    g_signal_connect(thing, "toggled",
+		       G_CALLBACK(gui_settings_perm_toggled), NULL);
 
     gui_subs_set_slider_value(&prefs_scopesfreq_slider, gui_settings.scopes_update_freq);
     gui_subs_set_slider_value(&prefs_trackerfreq_slider, gui_settings.tracker_update_freq);
@@ -422,8 +568,8 @@
     gtk_box_pack_start(GTK_BOX(box1), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
     gtk_spin_button_set_digits(GTK_SPIN_BUTTON(thing), 1);
-    gtk_signal_connect(GTK_OBJECT(thing), "changed",
-		       GTK_SIGNAL_FUNC(gui_settings_scopebufsize_changed), NULL);
+    g_signal_connect(thing, "value-changed",
+		       G_CALLBACK(gui_settings_scopebufsize_changed), NULL);
 
     thing = gtk_hseparator_new();
     gtk_widget_show(thing);
@@ -445,8 +591,8 @@
     gtk_entry_set_text((GtkEntry*)thing, stmp);
     gtk_box_pack_start(GTK_BOX(box1), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "changed",
-        GTK_SIGNAL_FUNC(gui_settings_tracker_line_note_modified), 0);
+    g_signal_connect(thing, "changed",
+        G_CALLBACK(gui_settings_tracker_line_note_modified), 0);
 
     thing = gtk_entry_new();
     gtk_widget_set_usize(thing, 13*2, thing->requisition.height);
@@ -456,8 +602,8 @@
     gtk_entry_set_text((GtkEntry*)thing, stmp);
     gtk_box_pack_start(GTK_BOX(box1), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "changed",
-        GTK_SIGNAL_FUNC(gui_settings_tracker_line_ins_modified), 0);
+    g_signal_connect(thing, "changed",
+        G_CALLBACK(gui_settings_tracker_line_ins_modified), 0);
 
     thing = gtk_entry_new();
     gtk_widget_set_usize(thing, 13*2, thing->requisition.height);
@@ -467,8 +613,8 @@
     gtk_entry_set_text((GtkEntry*)thing, stmp);
     gtk_box_pack_start(GTK_BOX(box1), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "changed",
-        GTK_SIGNAL_FUNC(gui_settings_tracker_line_vol_modified), 0);
+    g_signal_connect(thing, "changed",
+        G_CALLBACK(gui_settings_tracker_line_vol_modified), 0);
 
     thing = gtk_entry_new();
     gtk_widget_set_usize(thing, 13*3, thing->requisition.height);
@@ -478,8 +624,16 @@
     gtk_entry_set_text((GtkEntry*)thing, stmp);
     gtk_box_pack_start(GTK_BOX(box1), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "changed",
-        GTK_SIGNAL_FUNC(gui_settings_tracker_line_effect_modified), 0);
+    g_signal_connect(thing, "changed",
+        G_CALLBACK(gui_settings_tracker_line_effect_modified), 0);
+
+    /* Tracker colors configuration dialog */
+    thing = gtk_button_new_with_label(_("Col. scheme"));
+    gui_hang_tooltip(thing, _("Tracker colors configuration"));
+    gtk_box_pack_end(GTK_BOX(box1), thing, FALSE, TRUE, 0);
+    gtk_widget_show(thing);
+    g_signal_connect_swapped(thing, "clicked",
+        G_CALLBACK(gui_settings_tracker_colors_dialog), GTK_WINDOW(configwindow));
 
     thing = gtk_vseparator_new();
     gtk_widget_show(thing);
@@ -506,15 +660,11 @@
 			FALSE, FALSE, 0);
     gtk_widget_show (hbox);
 
-#ifdef USE_GNOME
-    thing = gnome_stock_button (GNOME_STOCK_BUTTON_CLOSE);
-#else
-    thing = gtk_button_new_with_label (_("Close"));
-#endif
+    thing = gtk_button_new_from_stock(GTK_STOCK_CLOSE);
     GTK_WIDGET_SET_FLAGS(thing, GTK_CAN_DEFAULT);
     gtk_window_set_default(GTK_WINDOW(configwindow), thing);
-    gtk_signal_connect (GTK_OBJECT (thing), "clicked",
-			GTK_SIGNAL_FUNC (gui_settings_close_requested), NULL);
+    g_signal_connect (thing, "clicked",
+			G_CALLBACK(gui_settings_close_requested), NULL);
     gtk_box_pack_start (GTK_BOX (hbox), thing, FALSE, FALSE, 0);
     gtk_widget_show (thing);
 
@@ -529,6 +679,8 @@
 
     f = prefs_open_read("settings");
     if(f) {
+	guint i;
+
 	prefs_get_int(f, "st-window-x", &gui_settings.st_window_x);
 	prefs_get_int(f, "st-window-y", &gui_settings.st_window_y);
 	prefs_get_int(f, "st-window-w", &gui_settings.st_window_w);
@@ -546,6 +698,9 @@
 	prefs_get_int(f, "tracker-highlight-rows", &gui_settings.highlight_rows);
 	prefs_get_int(f, "tracker-highlight-rows-n", &gui_settings.highlight_rows_n);
 	prefs_get_int(f, "tracker-highlight-rows-minor-n", &gui_settings.highlight_rows_minor_n);
+	gui_settings_colors.ok = TRUE;
+	for(i = 0; i < TRACKERCOL_LAST; i++)
+	    gui_settings_colors.ok &= prefs_get_color(f, color_meanings[i], &gui_settings_colors.val[i]);
 	prefs_get_int(f, "save-geometry", &gui_settings.save_geometry);
 	prefs_get_int(f, "save-settings-on-exit", &gui_settings.save_settings_on_exit);
 	prefs_get_int(f, "tracker-update-frequency", &gui_settings.tracker_update_freq);
@@ -556,7 +711,7 @@
 	prefs_get_int(f, "store-permanent", &gui_settings.store_perm);
 	
 	if(gui_settings.store_perm)
-	    prefs_get_int(f, "permanent-channels", &gui_settings.permanent_channels);
+	    prefs_get_int(f, "permanent-channels", (gint32*)&gui_settings.permanent_channels);
 
 	prefs_close(f);
     }
@@ -590,6 +745,7 @@
 gui_settings_save_config (void)
 {
     prefs_node *f;
+    guint i;
 
     f = prefs_open_write("settings");
     if(!f)
@@ -621,6 +777,8 @@
     prefs_put_int(f, "tracker-highlight-rows", gui_settings.highlight_rows);
     prefs_put_int(f, "tracker-highlight-rows-n", gui_settings.highlight_rows_n);
     prefs_put_int(f, "tracker-highlight-rows-minor-n", gui_settings.highlight_rows_minor_n);
+    for(i = 0; i < TRACKERCOL_LAST; i++)
+	prefs_put_color(f, color_meanings[i], tracker->colors[i]);
     prefs_put_int(f, "save-geometry", gui_settings.save_geometry);
     prefs_put_int(f, "save-settings-on-exit", gui_settings.save_settings_on_exit);
     prefs_put_int(f, "tracker-update-frequency", gui_settings.tracker_update_freq);
diff -Naur soundtracker-0.6.8/app/gui-settings.h soundtracker-0.6.8-gtk2/app/gui-settings.h
--- soundtracker-0.6.8/app/gui-settings.h	2006-02-25 13:30:54.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/gui-settings.h	2010-09-23 11:11:35.000000000 +0200
@@ -23,6 +23,7 @@
 #define _ST_GUI_SETTINGS_H
 
 #include <gtk/gtk.h>
+#include "tracker.h" /* To know the number of colors */
 
 typedef struct gui_prefs {
     gchar tracker_line_format[10];
@@ -79,7 +80,13 @@
 
 } gui_prefs;
 
+typedef struct _gui_prefs_colors {
+    gboolean ok;
+    GdkColor val[TRACKERCOL_LAST];
+} gui_prefs_colors;
+
 extern gui_prefs gui_settings;
+extern gui_prefs_colors gui_settings_colors;
 
 void        gui_settings_dialog                   (void);
 
diff -Naur soundtracker-0.6.8/app/gui-subs.c soundtracker-0.6.8-gtk2/app/gui-subs.c
--- soundtracker-0.6.8/app/gui-subs.c	2003-05-18 16:56:10.000000000 +0200
+++ soundtracker-0.6.8-gtk2/app/gui-subs.c	2010-09-23 11:11:35.000000000 +0200
@@ -3,6 +3,7 @@
  * The Real SoundTracker - GUI support routines
  *
  * Copyright (C) 1998-2001 Michael Krause
+ * Copyright (C) 2005 Yury Aliaev (GTK+-2 porting)
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -109,14 +110,14 @@
 
     while (*labels) {
 	thing = gtk_radio_button_new_with_label ((thing
-						  ? gtk_radio_button_group (GTK_RADIO_BUTTON (thing))
-						  : 0),
+						  ? gtk_radio_button_get_group (GTK_RADIO_BUTTON (thing))
+						  : NULL),
 						 gettext(*labels++));
 	*saveptr++ = thing;
 	gtk_widget_show (thing);
 	gtk_box_pack_start (GTK_BOX (tobox), thing, t1, t2, 0);
 	if(sigfunc) {
-	    gtk_signal_connect (GTK_OBJECT (thing), "clicked", (GtkSignalFunc) sigfunc, data);
+	    g_signal_connect (thing, "clicked", G_CALLBACK(sigfunc), data);
 	}
     }
 }
@@ -182,7 +183,7 @@
     *spin = extspinbutton_new(GTK_ADJUSTMENT(gtk_adjustment_new(min, min, max, 1.0, 5.0, 0.0)), 0, 0);
     gtk_box_pack_start(GTK_BOX(hbox), *spin, FALSE, TRUE, 0);
     gtk_widget_show(*spin);
-    gtk_signal_connect(GTK_OBJECT(*spin), "changed",
+    g_signal_connect(*spin, "value-changed",
 		       GTK_SIGNAL_FUNC(callback), callbackdata);
 }
 
@@ -195,18 +196,18 @@
     window = gtk_file_selection_new (title);
     gtk_window_position (GTK_WINDOW (window), GTK_WIN_POS_MOUSE);
 	
-    gtk_signal_connect(GTK_OBJECT (window), "destroy",
-		       GTK_SIGNAL_FUNC(gtk_main_quit),
+    g_signal_connect(window, "destroy",
+		       G_CALLBACK(gtk_main_quit),
 		       NULL);
-    gtk_signal_connect(GTK_OBJECT (GTK_FILE_SELECTION (window)->ok_button),
-		       "clicked", GTK_SIGNAL_FUNC(clickfunc),
+    g_signal_connect(GTK_FILE_SELECTION (window)->ok_button,
+		       "clicked", G_CALLBACK(clickfunc),
 		       window);
  
-    gtk_signal_connect(GTK_OBJECT (window), "delete_event",
-		       GTK_SIGNAL_FUNC(gtk_widget_hide),
+    g_signal_connect(window, "delete_event",
+		       G_CALLBACK(gtk_widget_hide),
 		       window);
-    gtk_signal_connect_object(GTK_OBJECT (GTK_FILE_SELECTION (window)->cancel_button),
-			      "clicked", GTK_SIGNAL_FUNC(gtk_widget_hide),
+    g_signal_connect_swapped(GTK_FILE_SELECTION (window)->cancel_button,
+			      "clicked", G_CALLBACK(gtk_widget_hide),
 			      GTK_OBJECT (window));
 
     return window;
@@ -278,8 +279,8 @@
 	gtk_scale_set_draw_value(GTK_SCALE(s->slider), FALSE);
 	gtk_widget_show(s->slider);
 	gtk_box_pack_start(GTK_BOX(box), s->slider, TRUE, TRUE, 0);
-	gtk_signal_connect (GTK_OBJECT(s->adjustment1), "value_changed",
-			    GTK_SIGNAL_FUNC(gui_subs_slider_update_1), s);
+	g_signal_connect(s->adjustment1, "value_changed",
+			    G_CALLBACK(gui_subs_slider_update_1), s);
     } else {
 	add_empty_hbox(box);
     }
@@ -288,8 +289,8 @@
     thing = extspinbutton_new(s->adjustment2, 0, 0);
     gtk_box_pack_start(GTK_BOX(box), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "changed",
-		       GTK_SIGNAL_FUNC(gui_subs_slider_update_2), s);
+    g_signal_connect(thing, "value-changed",
+		       G_CALLBACK(gui_subs_slider_update_2), s);
 
     s->update_without_signal = FALSE;
 
@@ -345,7 +346,7 @@
 	adj = GTK_ADJUSTMENT(gtk_adjustment_new(pos+1, 0, upper, 1, window-2, window));
 	gtk_range_set_adjustment(range, adj); /* old adjustment is freed automagically */
 	gtk_adjustment_set_value(adj, pos);
-	gtk_signal_connect(GTK_OBJECT(adj), "value_changed", GTK_SIGNAL_FUNC(func), NULL);
+	g_signal_connect(adj, "value_changed", G_CALLBACK(func), NULL);
     } else {
 	if((int)(adj->value) != pos)
 	    gtk_adjustment_set_value(adj, pos);
@@ -383,8 +384,8 @@
   for (i = 0; i < num_items; i++)
     {
       menu_item = gtk_radio_menu_item_new_with_label (group, items[i].name);
-      gtk_signal_connect (GTK_OBJECT (menu_item), "activate",
-			  (GtkSignalFunc) items[i].func, GINT_TO_POINTER(i));
+      g_signal_connect (menu_item, "activate",
+			  G_CALLBACK(items[i].func), GINT_TO_POINTER(i));
       group = gtk_radio_menu_item_group (GTK_RADIO_MENU_ITEM (menu_item));
       gtk_menu_append (GTK_MENU (menu), menu_item);
       if (i == history)
@@ -398,18 +399,99 @@
   return omenu;
 }
 
-// Create CList in scrolled window, show and add to box
 GtkWidget *
-gui_clist_in_scrolled_window (int n,
-			      gchar **tp,
-			      GtkWidget *hbox)
+gui_stringlist_in_scrolled_window (int n, gchar **tp,  GtkWidget *hbox)
+{
+    GType *types;
+    GtkWidget *list;
+    guint i;
+    
+    types = g_new(GType, n);
+    for(i = 0; i < n; i++)
+	types[i] = G_TYPE_STRING;
+    list = gui_list_in_scrolled_window(n, tp, hbox, types, NULL, NULL, GTK_SELECTION_BROWSE);
+    g_free(types);
+    return list;
+}
+
+void
+gui_list_clear (GtkWidget *list)
+{
+    GtkTreeIter iter;
+    GtkTreeModel *model;
+    gboolean result;
+
+    result = gtk_tree_model_get_iter_from_string(model = gtk_tree_view_get_model(GTK_TREE_VIEW(list)),
+						 &iter, "0");
+    while(result)
+	result = gtk_list_store_remove(GTK_LIST_STORE(model), &iter);
+}
+
+void
+gui_list_clear_with_model (GtkTreeModel *model)
+{
+    GtkTreeIter iter;
+    gboolean result;
+
+    result = gtk_tree_model_get_iter_from_string(model, &iter, "0");
+
+    while(result)
+	result = gtk_list_store_remove(GTK_LIST_STORE(model), &iter);
+}
+
+GtkTreeModel *
+gui_list_freeze (GtkWidget *list)
+{
+    GtkTreeModel *model;
+
+    model = gtk_tree_view_get_model(GTK_TREE_VIEW(list));
+    g_object_ref(model);
+    gtk_tree_view_set_model(GTK_TREE_VIEW(list), NULL);
+
+    return model;
+}
+
+void
+gui_list_thaw (GtkWidget *list, GtkTreeModel *model)
+{
+    gtk_tree_view_set_model(GTK_TREE_VIEW(list), model);
+    g_object_unref(model);
+}
+
+GtkWidget *
+gui_list_in_scrolled_window (int n, gchar **tp,  GtkWidget *hbox,
+			     GType *types, gfloat *alignments, gboolean *expands,
+			     GtkSelectionMode mode)
 {
     GtkWidget *list;
     GtkWidget *sw;
-    list = gtk_clist_new_with_titles(n, tp);
+    guint i;
+    GtkListStore *list_store;
+    GtkTreeViewColumn *column;
+    GtkCellRenderer *renderer;
+    GtkTreeSelection *sel;
+    
+    list_store = gtk_list_store_newv(n, types);
+    list = gtk_tree_view_new_with_model(GTK_TREE_MODEL(list_store));
+    for(i = 0; i < n; i++) {
+	renderer = gtk_cell_renderer_text_new();
+	column = gtk_tree_view_column_new_with_attributes(tp[i], renderer, "text", i, NULL);
+	if(alignments) {
+	    g_object_set(G_OBJECT(renderer), "xalign", alignments[i], NULL);
+	    gtk_tree_view_column_set_alignment(column, alignments[i]);
+	}
+	g_object_set(G_OBJECT(renderer), "ypad", 0, NULL);
+	if(expands)
+	    gtk_tree_view_column_set_expand(column, expands[i]);
+	gtk_tree_view_append_column(GTK_TREE_VIEW(list), column);
+    }
+
+    sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(list));
+    gtk_tree_selection_set_mode(sel, mode);
+
     sw = gtk_scrolled_window_new(NULL, NULL);
+    gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(sw), GTK_SHADOW_ETCHED_IN);
     gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(sw), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
-    gtk_clist_set_shadow_type(GTK_CLIST(list), GTK_SHADOW_ETCHED_IN);
     gtk_container_add(GTK_CONTAINER(sw), list);
     gtk_widget_show(sw);
     gtk_box_pack_start(GTK_BOX(hbox), sw, TRUE, TRUE, 0);
@@ -417,39 +499,73 @@
     return list;
 }
 
+void
+gui_list_handle_selection (GtkWidget *list, GCallback handler, gpointer data)
+{
+    GtkTreeSelection *sel;
+
+    sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(list));
+    g_signal_connect_after(sel, "changed", handler, data);
+}
+
+inline void
+gui_list_moveto (GtkWidget *list, guint n)
+{
+    gchar *path_string;
+    GtkTreePath *path;
+
+    path_string = g_strdup_printf("%u", n);
+    path = gtk_tree_path_new_from_string(path_string);
+    gtk_tree_view_scroll_to_cell(GTK_TREE_VIEW(list), path, NULL,
+			         TRUE, 0.5, 0.0);
+    g_free(path_string);
+    gtk_tree_path_free(path);
+}
+
+inline gboolean
+gui_list_get_iter (guint n, GtkListStore *tree_model, GtkTreeIter *iter)
+{
+    gchar *path;
+    gboolean result;
+    
+    path = g_strdup_printf("%u", n);
+    result = gtk_tree_model_get_iter_from_string(GTK_TREE_MODEL(tree_model), iter, path);
+    g_free(path);
+    return result;
+}
+
+inline void
+gui_string_list_set_text (GtkWidget *list, guint row, guint col, const gchar *string)
+{
+    GtkTreeIter iter;
+    GtkListStore *list_store;
+
+    if(gui_list_get_iter(row, list_store = GUI_GET_LIST_STORE(list), &iter))
+	gtk_list_store_set(list_store, &iter, col, string, -1);
+}
+
+inline void
+gui_list_select (GtkWidget *list, guint row)
+{
+    GtkTreeIter iter;
+    GtkTreeSelection *sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(list));
+
+    if(!gui_list_get_iter(row, GUI_GET_LIST_STORE(list), &iter))
+       return;
+    gtk_tree_selection_select_iter(sel, &iter);
+}
+
 GtkWidget *
-gui_button (GtkWidget * win, char *stock, char *labeltext,
+gui_button (GtkWidget * win, char *stock,
 	    void *callback, gpointer userdata, GtkWidget * box)
 {
-   GtkWidget *button, *label, *hbox;
-#ifdef USE_GNOME
-   GtkWidget *pixmap;
-#endif
-
-   hbox = gtk_hbox_new (0, 0);
-   gtk_widget_show (hbox);
+   GtkWidget *button;
 
-   button = gtk_button_new ();
-   gtk_signal_connect (GTK_OBJECT (button), "clicked",
-                       GTK_SIGNAL_FUNC (callback), userdata);
+   button = gtk_button_new_from_stock (stock);
+   g_signal_connect(button, "clicked",
+                    G_CALLBACK(callback), userdata);
    gtk_widget_show (button);
 
-#ifdef USE_GNOME
-   if (stock)
-   {
-      pixmap = gnome_stock_pixmap_widget_at_size (win, stock, 12, 14);
-      gtk_container_add (GTK_CONTAINER (hbox), pixmap);
-      gtk_widget_show (pixmap);
-   }
-#endif
-
-   if (labeltext)
-   {
-      label = gtk_label_new (labeltext);
-      gtk_container_add (GTK_CONTAINER (hbox), label);
-      gtk_widget_show (label);
-   }
-   gtk_container_add (GTK_CONTAINER (button), hbox);
    if (box)
       gtk_container_add (GTK_CONTAINER (box), button);
 
@@ -478,7 +594,7 @@
     aaccallback = callback;
     aaccallbackdata = data;
     
-    aacdialog = gtk_dialog_new();
+    aacdialog = gtk_window_new(GTK_WINDOW_TOPLEVEL);
     gtk_window_position (GTK_WINDOW(aacdialog), GTK_WIN_POS_CENTER);
     gtk_window_set_title(GTK_WINDOW(aacdialog), _("Question"));
     gtk_window_set_modal(GTK_WINDOW(aacdialog), TRUE);
@@ -492,23 +608,23 @@
     button = gtk_button_new_with_label (_("Yes"));
     GTK_WIDGET_SET_FLAGS (button, GTK_CAN_DEFAULT);
     gtk_box_pack_start (GTK_BOX (GTK_DIALOG(aacdialog)->action_area), button, TRUE, TRUE, 10);
-    gtk_signal_connect_object (GTK_OBJECT (button), "clicked",
-                               GTK_SIGNAL_FUNC (aacdialog_close), (gpointer)0);
+    g_signal_connect_swapped(button, "clicked",
+                               G_CALLBACK(aacdialog_close), (gpointer)0);
     gtk_widget_grab_default (button);
     gtk_widget_show (button);
     
     button = gtk_button_new_with_label (_("No"));
     GTK_WIDGET_SET_FLAGS (button, GTK_CAN_DEFAULT);
     gtk_box_pack_start (GTK_BOX (GTK_DIALOG(aacdialog)->action_area), button, TRUE, TRUE, 10);
-    gtk_signal_connect_object (GTK_OBJECT (button), "clicked",
-                               GTK_SIGNAL_FUNC (aacdialog_close), (gpointer)1);
+    g_signal_connect_swapped (button, "clicked",
+                              G_CALLBACK(aacdialog_close), (gpointer)1);
     gtk_widget_show (button);
     
     button = gtk_button_new_with_label (_("Cancel"));
     GTK_WIDGET_SET_FLAGS (button, GTK_CAN_DEFAULT);
     gtk_box_pack_start (GTK_BOX (GTK_DIALOG(aacdialog)->action_area), button, TRUE, TRUE, 10);
-    gtk_signal_connect_object (GTK_OBJECT (button), "clicked",
-                               GTK_SIGNAL_FUNC (aacdialog_close), (gpointer)2);
+    g_signal_connect_swapped (button, "clicked",
+                               G_CALLBACK(aacdialog_close), (gpointer)2);
     gtk_widget_show (button);
     
     gtk_widget_show(aacdialog);
@@ -549,7 +665,7 @@
     ccallback = callback;
     ccallbackdata = data;
     
-    cdialog = gtk_dialog_new();
+    cdialog = gtk_window_new(GTK_WINDOW_TOPLEVEL);
     gtk_window_position (GTK_WINDOW(cdialog), GTK_WIN_POS_CENTER);
     gtk_window_set_title(GTK_WINDOW(cdialog), _("Question"));
     gtk_window_set_modal(GTK_WINDOW(cdialog), TRUE);
@@ -563,16 +679,16 @@
     button = gtk_button_new_with_label ("Ok");
     GTK_WIDGET_SET_FLAGS (button, GTK_CAN_DEFAULT);
     gtk_box_pack_start (GTK_BOX (GTK_DIALOG(cdialog)->action_area), button, TRUE, TRUE, 10);
-    gtk_signal_connect_object (GTK_OBJECT (button), "clicked",
-                               GTK_SIGNAL_FUNC (cdialog_close), (gpointer)0);
+    g_signal_connect_swapped(button, "clicked",
+                               G_CALLBACK(cdialog_close), (gpointer)0);
     gtk_widget_grab_default (button);
     gtk_widget_show (button);
     
     button = gtk_button_new_with_label (_("Cancel"));
     GTK_WIDGET_SET_FLAGS (button, GTK_CAN_DEFAULT);
     gtk_box_pack_start (GTK_BOX (GTK_DIALOG(cdialog)->action_area), button, TRUE, TRUE, 10);
-    gtk_signal_connect_object (GTK_OBJECT (button), "clicked",
-                               GTK_SIGNAL_FUNC (cdialog_close), (gpointer)1);
+    g_signal_connect_swapped(button, "clicked",
+                               G_CALLBACK(cdialog_close), (gpointer)1);
     gtk_widget_show (button);
     
     gtk_widget_show(cdialog);
@@ -584,7 +700,7 @@
     GtkWidget *label, *button;
     GtkWidget *dialog;
 
-    dialog = gtk_dialog_new();
+    dialog = gtk_window_new(GTK_WINDOW_TOPLEVEL);
     gtk_window_position (GTK_WINDOW(dialog), GTK_WIN_POS_CENTER);
     gtk_window_set_title(GTK_WINDOW(dialog), _("Warning"));
 
@@ -596,8 +712,8 @@
     button = gtk_button_new_with_label ("Ok");
     GTK_WIDGET_SET_FLAGS (button, GTK_CAN_DEFAULT);
     gtk_box_pack_start (GTK_BOX (GTK_DIALOG(dialog)->action_area), button, TRUE, TRUE, 10);
-    gtk_signal_connect_object (GTK_OBJECT (button), "clicked",
-                               GTK_SIGNAL_FUNC (dialog_close), (gpointer)dialog);
+    g_signal_connect_swapped(button, "clicked",
+                               G_CALLBACK(dialog_close), (gpointer)dialog);
     gtk_widget_grab_default (button);
     gtk_widget_show (button);
     
@@ -610,7 +726,7 @@
     GtkWidget *label, *button;
     GtkWidget *dialog;
 
-    dialog = gtk_dialog_new();
+    dialog = gtk_window_new(GTK_WINDOW_TOPLEVEL);
     gtk_window_position (GTK_WINDOW(dialog), GTK_WIN_POS_CENTER);
     gtk_window_set_title(GTK_WINDOW(dialog), _("Error!"));
 
@@ -622,8 +738,8 @@
     button = gtk_button_new_with_label ("Ok");
     GTK_WIDGET_SET_FLAGS (button, GTK_CAN_DEFAULT);
     gtk_box_pack_start (GTK_BOX (GTK_DIALOG(dialog)->action_area), button, TRUE, TRUE, 10);
-    gtk_signal_connect_object (GTK_OBJECT (button), "clicked",
-                               GTK_SIGNAL_FUNC (dialog_close), (gpointer)dialog);
+    g_signal_connect_swapped(button, "clicked",
+                               G_CALLBACK(dialog_close), (gpointer)dialog);
     gtk_widget_grab_default (button);
     gtk_widget_show (button);
     
diff -Naur soundtracker-0.6.8/app/gui-subs.h soundtracker-0.6.8-gtk2/app/gui-subs.h
--- soundtracker-0.6.8/app/gui-subs.h	2003-05-18 16:35:30.000000000 +0200
+++ soundtracker-0.6.8-gtk2/app/gui-subs.h	2010-09-23 11:11:35.000000000 +0200
@@ -3,6 +3,7 @@
  * The Real SoundTracker - GUI support routines (header)
  *
  * Copyright (C) 1998-2001 Michael Krause
+ * Copyright (C) 2005 Yury Aliaev (GTK+-2 porting)
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -129,7 +130,7 @@
 
 typedef struct OptionMenuItem {
   const gchar *name;
-  GtkSignalFunc func;
+  void *func;
 } OptionMenuItem;
 
 GtkWidget *          gui_build_option_menu            (OptionMenuItem items[],
@@ -138,11 +139,44 @@
 
 GtkWidget *          gui_clist_in_scrolled_window     (int n,
 						       gchar **tp,
+						       GtkWidget *hbox);//!!!
+
+GtkWidget *	     gui_list_in_scrolled_window      (int n, gchar **tp,  GtkWidget *hbox,
+						       GType *types, gfloat *alignments,
+						        gboolean *expands,
+							GtkSelectionMode mode);
+
+GtkWidget *          gui_stringlist_in_scrolled_window(int n,
+						       gchar **tp,
 						       GtkWidget *hbox);
 
+void		     gui_list_clear		      (GtkWidget *list);
+
+void		     gui_list_clear_with_model	      (GtkTreeModel *model);
+
+GtkTreeModel *	     gui_list_freeze		      (GtkWidget *list);
+
+void		     gui_list_thaw		      (GtkWidget *list, GtkTreeModel *model);
+
+#define GUI_GET_LIST_STORE(list) GTK_LIST_STORE(gtk_tree_view_get_model(GTK_TREE_VIEW(list)))
+
+void		     gui_list_handle_selection	      (GtkWidget *list,
+						       GCallback handler,
+						       gpointer data);
+
+inline gboolean	     gui_list_get_iter		      (guint n,
+						       GtkListStore *tree_model,
+						       GtkTreeIter *iter);
+
+inline void	     gui_list_moveto                  (GtkWidget *list, guint n);
+
+inline void	     gui_string_list_set_text	      (GtkWidget *list, guint row,
+						       guint col, const gchar *string);
+
+inline void	     gui_list_select		      (GtkWidget *list, guint row);
+
 GtkWidget *          gui_button                       (GtkWidget * win,
 						       char *stock,
-						       char *labeltext,
 						       void *callback,
 						       gpointer userdata,
 						       GtkWidget *box);
diff -Naur soundtracker-0.6.8/app/instrument-editor.c soundtracker-0.6.8-gtk2/app/instrument-editor.c
--- soundtracker-0.6.8/app/instrument-editor.c	2004-01-11 16:19:55.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/instrument-editor.c	2010-09-23 11:11:35.000000000 +0200
@@ -271,14 +271,14 @@
     thing = gtk_button_new_with_label(_("Load XI"));
     gtk_box_pack_start(GTK_BOX(box2), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(fileops_open_dialog), (void*)DIALOG_LOAD_INSTRUMENT);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(fileops_open_dialog), (void*)DIALOG_LOAD_INSTRUMENT);
 
     disableboxes[3] = thing = gtk_button_new_with_label(_("Save XI"));
     gtk_box_pack_start(GTK_BOX(box2), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(fileops_open_dialog), (void*)DIALOG_SAVE_INSTRUMENT);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(fileops_open_dialog), (void*)DIALOG_SAVE_INSTRUMENT);
 
     thing = gtk_vseparator_new();
     gtk_box_pack_start(GTK_BOX(box), thing, FALSE, TRUE, 0);
@@ -346,17 +346,17 @@
     clavier_set_show_middle_c(CLAVIER(clavier), FALSE);
     clavier_set_show_transpose(CLAVIER(clavier), FALSE);
 
-    gtk_signal_connect (GTK_OBJECT (clavier), "clavierkey_press",
-			GTK_SIGNAL_FUNC (instrument_editor_clavierkey_press_event),
+    g_signal_connect(clavier, "clavierkey_press",
+			G_CALLBACK(instrument_editor_clavierkey_press_event),
 			NULL);
-    gtk_signal_connect (GTK_OBJECT (clavier), "clavierkey_release",
-			GTK_SIGNAL_FUNC (instrument_editor_clavierkey_release_event),
+    g_signal_connect(clavier, "clavierkey_release",
+			G_CALLBACK(instrument_editor_clavierkey_release_event),
 			NULL);
-    gtk_signal_connect (GTK_OBJECT (clavier), "clavierkey_enter",
-			GTK_SIGNAL_FUNC (instrument_editor_clavierkey_enter_event),
+    g_signal_connect(clavier, "clavierkey_enter",
+			G_CALLBACK(instrument_editor_clavierkey_enter_event),
 			NULL);
-    gtk_signal_connect (GTK_OBJECT (clavier), "clavierkey_leave",
-			GTK_SIGNAL_FUNC (instrument_editor_clavierkey_leave_event),
+    g_signal_connect(clavier, "clavierkey_leave",
+			G_CALLBACK(instrument_editor_clavierkey_leave_event),
 			NULL);
 
     box3 = gtk_vbox_new(FALSE, 2);
@@ -386,8 +386,8 @@
     thing = gtk_button_new_with_label(_("Initialize"));
     gtk_widget_show(thing);
     gtk_box_pack_start(GTK_BOX(box3), thing, FALSE, TRUE, 0);
-    gtk_signal_connect (GTK_OBJECT (thing), "clicked",
-			GTK_SIGNAL_FUNC(instrument_editor_init_samplemap), NULL);
+    g_signal_connect(thing, "clicked",
+			G_CALLBACK(instrument_editor_init_samplemap), NULL);
 
     add_empty_vbox(box3);
 
diff -Naur soundtracker-0.6.8/app/keys.c soundtracker-0.6.8-gtk2/app/keys.c
--- soundtracker-0.6.8/app/keys.c	2004-01-04 17:01:50.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/keys.c	2010-09-23 11:11:35.000000000 +0200
@@ -8,6 +8,7 @@
  *
  * Copyright (C) 1997-2001 Michael Krause
  * Copyright (C) 2000 Fabian Giesen (Win32 stuff)
+ * Copyright (C) 2005 Yury Aliaev (GTK+-2 porting)
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -57,7 +58,7 @@
 #define NONE_TEXT _("<none>")
 
 static GtkWidget *configwindow = NULL,
-    *cw_clist,
+    *cw_list,
     *cw_explabel,
     *cw_explabel2,
     *cw_combo,
@@ -322,10 +323,13 @@
 keys_key_group_changed (void *a,
 			void *b)
 {
+    GtkListStore *list_store = GUI_GET_LIST_STORE(cw_list);
+    GtkTreeIter iter;
+    GtkTreeModel *model;
+
     unsigned n = GPOINTER_TO_INT(b);
     keys_key *kpt;
     gchar string[128];
-    gchar * insertbuf[2] = { NULL, string };
 
     g_assert(n < NUM_KEY_GROUPS);
     cw_currentgroup = -1;
@@ -333,59 +337,68 @@
     // Set explanation
     gtk_label_set_text(GTK_LABEL(cw_explabel), gettext(groups[n].explanation));
 
-    gtk_clist_clear(GTK_CLIST(cw_clist));
-    gtk_clist_freeze(GTK_CLIST(cw_clist));
+    model = gui_list_freeze(cw_list);
+    gui_list_clear_with_model(model);
     for(kpt = groups[n].keys_edit; kpt->title; kpt++) {
-	insertbuf[0] = (gchar*)gettext(kpt->title);
 	keys_encode_assignment(string, kpt->modifiers, kpt->xkeysym);
-	gtk_clist_append(GTK_CLIST(cw_clist), insertbuf);
+	gtk_list_store_append(list_store, &iter);
+	gtk_list_store_set(list_store, &iter, 0, (gchar*)gettext(kpt->title),
+			   1, string, -1);
     }
-    gtk_clist_thaw(GTK_CLIST(cw_clist));
+    gui_list_thaw(cw_list, model);
 
     cw_currentgroup = n;
-    gtk_clist_select_row(GTK_CLIST(cw_clist), 0, 0);
+    gui_list_select(cw_list, 0);
 }
 
 static void
-keys_clist_select (GtkCList *list,
-		   gint row,
-		   gint column)
+keys_list_select (GtkTreeSelection *sel)
 {
-    gchar *code;
-    int mod, i, h;
+    GtkTreeModel *mdl;
+    GtkTreeIter iter;
+    gchar *str;
+    gint row;
+    
+    if(gtk_tree_selection_get_selected(sel, &mdl, &iter)) {
+	gchar *code;
+	int mod, i, h;
 
-    if(cw_currentgroup == -1)
-	return;
+	row = atoi(str = gtk_tree_model_get_string_from_iter(mdl, &iter));
+	g_free(str);
 
-    cw_currentkey = -1;
+	if(cw_currentgroup == -1)
+	    return;
 
-    // Set explanation
-    gtk_label_set_text(GTK_LABEL(cw_explabel2), gettext(groups[cw_currentgroup].keys_edit[row].explanation));
+	cw_currentkey = -1;
 
-    // Set combo box list
-    if(cw_combostrings != (0)) {
-	cw_combostrings = (0);
-	gtk_combo_set_popdown_strings(GTK_COMBO(cw_combo), xkeys[cw_combostrings]);
-    }
+	// Set explanation
+	gtk_label_set_text(GTK_LABEL(cw_explabel2), gettext(groups[cw_currentgroup].keys_edit[row].explanation));
 
-    // Set modifier toggles
-    mod = groups[cw_currentgroup].keys_edit[row].modifiers;
-    for(i = 0; i <= 2; i++) {
-	gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(cw_modtoggles[i]), mod & (1 << i));
-    }
+	// Set combo box list
+	if(cw_combostrings != (0)) {
+	    cw_combostrings = (0);
+	    gtk_combo_set_popdown_strings(GTK_COMBO(cw_combo), xkeys[cw_combostrings]);
+	}
+
+	// Set modifier toggles
+	mod = groups[cw_currentgroup].keys_edit[row].modifiers;
+	for(i = 0; i <= 2; i++) {
+	    gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(cw_modtoggles[i]), mod & (1 << i));
+	}
     
-    // Set combo box entry
-    code = NONE_TEXT;
-    h = groups[cw_currentgroup].keys_edit[row].xkeysym;
-    for(i = 0; h != 0 && i < xkeymaplen; i++) {
-	if(xkeymap[i].xkeysym == h) {
-	    code = xkeymap[i].xname;
-	    break;
+	// Set combo box entry
+	code = NONE_TEXT;
+	h = groups[cw_currentgroup].keys_edit[row].xkeysym;
+	for(i = 0; h != 0 && i < xkeymaplen; i++) {
+	    if(xkeymap[i].xkeysym == h) {
+		code = xkeymap[i].xname;
+		break;
+	    }
 	}
+	gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(cw_combo)->entry), code);
+
+	cw_currentkey = row;
     }
-    gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(cw_combo)->entry), code);
-    
-    cw_currentkey = row;
 }
 
 static void
@@ -414,7 +427,7 @@
     keys_encode_assignment(string,
 			   groups[cw_currentgroup].keys_edit[cw_currentkey].modifiers,
 			   keysym);
-    gtk_clist_set_text(GTK_CLIST(cw_clist), cw_currentkey, 1, string);
+    gui_string_list_set_text(cw_list, cw_currentkey, 1, string);
 }
 
 static void
@@ -461,25 +474,25 @@
 	groups[cw_currentgroup].keys_edit[cw_currentkey].xkeysym = keysym;
 	groups[cw_currentgroup].keys_edit[cw_currentkey].modifiers = mod;
 
-	gtk_clist_set_text(GTK_CLIST(cw_clist), cw_currentkey, 1, string);
+	gui_string_list_set_text(cw_list, cw_currentkey, 1, string);
 
 	if(capturing_all) {
 	    int nextkey = cw_currentkey + 1;
 	    if(groups[cw_currentgroup].keys_edit[nextkey].title) {
-		gtk_clist_select_row(GTK_CLIST(cw_clist), nextkey, 0);
-		gtk_clist_moveto(GTK_CLIST(cw_clist), nextkey, 0, 0.5, 0.0);
+		gui_list_select(cw_list, nextkey);
+		gui_list_moveto(cw_list, nextkey);
 	    } else {
-		keys_clist_select(GTK_CLIST(cw_clist), cw_currentkey, 0);
+		keys_list_select(gtk_tree_view_get_selection(GTK_TREE_VIEW(cw_list)));
 		capturing = capturing_all = 0;
 		keys_lb_switch(1);
 	    }
 	} else {
-	    keys_clist_select(GTK_CLIST(cw_clist), cw_currentkey, 0);
+	    keys_list_select(gtk_tree_view_get_selection(GTK_TREE_VIEW(cw_list)));
 	    capturing = capturing_all = 0;
 	    keys_lb_switch(1);
 	}
 
-	gtk_signal_emit_stop_by_name(GTK_OBJECT(widget), "key_press_event");
+	g_signal_stop_emission_by_name(G_OBJECT(widget), "key_press_event");
     }
 
     return 1;
@@ -498,8 +511,8 @@
 {
     capturing = 1;
     capturing_all = 1;
-    gtk_clist_select_row(GTK_CLIST(cw_clist), 0, 0);
-    gtk_clist_moveto(GTK_CLIST(cw_clist), 0, 0, 0.5, 0.0);
+    gui_list_select(cw_list, 0);
+    gui_list_moveto(cw_list, 0);
     keys_lb_switch(0);
 }
 
@@ -525,8 +538,8 @@
     configwindow = gtk_window_new(GTK_WINDOW_TOPLEVEL);
     gtk_window_set_title(GTK_WINDOW(configwindow), _("Keyboard Configuration"));
 #endif
-    gtk_signal_connect (GTK_OBJECT (configwindow), "delete_event",
-			GTK_SIGNAL_FUNC (keys_cancel), NULL);
+    g_signal_connect(configwindow, "delete_event",
+			G_CALLBACK(keys_cancel), NULL);
 
     mainbox = gtk_vbox_new(FALSE, 2);
     gtk_container_border_width(GTK_CONTAINER(mainbox), 4);
@@ -556,15 +569,10 @@
     gtk_box_pack_start(GTK_BOX(mainbox), box1, TRUE, TRUE, 0);
 
     // List at the left side of the window
-    thing = gui_clist_in_scrolled_window(2, listtitles, box1);
-    gtk_clist_set_selection_mode(GTK_CLIST(thing), GTK_SELECTION_BROWSE);
-    gtk_clist_column_titles_passive(GTK_CLIST(thing));
-    gtk_clist_set_column_justification(GTK_CLIST(thing), 0, GTK_JUSTIFY_LEFT);
-    gtk_clist_set_column_justification(GTK_CLIST(thing), 1, GTK_JUSTIFY_LEFT);
-    gtk_widget_set_usize(thing, 200, 50);
-    gtk_signal_connect_after(GTK_OBJECT(thing), "select_row",
-			     GTK_SIGNAL_FUNC(keys_clist_select), NULL);
-    cw_clist = thing;
+    thing = gui_stringlist_in_scrolled_window(2, listtitles, box1);
+    gtk_widget_set_size_request(thing, 200, 50);
+    gui_list_handle_selection(thing, G_CALLBACK(keys_list_select), NULL);
+    cw_list = thing;
 
 
     box2 = gtk_vbox_new(FALSE, 2);
@@ -612,8 +620,8 @@
     gtk_box_pack_start(GTK_BOX(box2), cw_combo, FALSE, FALSE, 0);
     gtk_combo_set_case_sensitive(GTK_COMBO(cw_combo), TRUE);
     gtk_combo_set_value_in_list(GTK_COMBO(cw_combo), TRUE, TRUE);
-    gtk_signal_connect(GTK_OBJECT(GTK_COMBO(cw_combo)->entry), "changed",
-		       GTK_SIGNAL_FUNC(keys_assignment_changed), NULL);
+    g_signal_connect(GTK_COMBO(cw_combo)->entry, "changed",
+		       G_CALLBACK(keys_assignment_changed), NULL);
 
     // Modifier Group
     box3 = gtk_hbox_new(FALSE, 4);
@@ -629,34 +637,34 @@
     thing = cw_modtoggles[0] = gtk_check_button_new_with_label("Shift");
     gtk_box_pack_start(GTK_BOX(box3), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "toggled",
-		       GTK_SIGNAL_FUNC(keys_assignment_changed), NULL);
+    g_signal_connect(thing, "toggled",
+		       G_CALLBACK(keys_assignment_changed), NULL);
 
     thing = cw_modtoggles[1] = gtk_check_button_new_with_label("Ctrl");
     gtk_box_pack_start(GTK_BOX(box3), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "toggled",
-		       GTK_SIGNAL_FUNC(keys_assignment_changed), NULL);
+    g_signal_connect(thing, "toggled",
+		       G_CALLBACK(keys_assignment_changed), NULL);
 
     thing = cw_modtoggles[2] = gtk_check_button_new_with_label("Meta");
     gtk_box_pack_start(GTK_BOX(box3), thing, FALSE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "toggled",
-		       GTK_SIGNAL_FUNC(keys_assignment_changed), NULL);
+    g_signal_connect(thing, "toggled",
+		       G_CALLBACK(keys_assignment_changed), NULL);
 
 
     // Learn-Buttons
     cw_lb1 = thing = gtk_button_new_with_label(_("Learn selected key"));
     gtk_widget_show(thing);
     gtk_box_pack_start(GTK_BOX(box2), thing, FALSE, FALSE, 0);
-    gtk_signal_connect (GTK_OBJECT (thing), "clicked",
-			GTK_SIGNAL_FUNC(keys_learn_key_clicked), NULL);
+    g_signal_connect(thing, "clicked",
+			G_CALLBACK(keys_learn_key_clicked), NULL);
 
     cw_lb2 = thing = gtk_button_new_with_label(_("Learn all keys"));
     gtk_widget_show(thing);
     gtk_box_pack_start(GTK_BOX(box2), thing, FALSE, FALSE, 0);
-    gtk_signal_connect (GTK_OBJECT (thing), "clicked",
-			GTK_SIGNAL_FUNC(keys_learn_all_keys_clicked), NULL);
+    g_signal_connect(thing, "clicked",
+			G_CALLBACK(keys_learn_all_keys_clicked), NULL);
 
     cw_label3 = gtk_label_new(_("Please press the desired key combination!\nClick into left list to cancel"));
     gtk_label_set_justify(GTK_LABEL(cw_label3), GTK_JUSTIFY_CENTER);
@@ -664,12 +672,12 @@
 
 
     keys_key_group_changed(NULL, (void*)0);
-    keys_clist_select(GTK_CLIST(cw_clist), 0, 0);
+    keys_list_select(gtk_tree_view_get_selection(GTK_TREE_VIEW(cw_list)));
 
-    gtk_signal_connect(GTK_OBJECT(configwindow), "key_press_event",
-		       GTK_SIGNAL_FUNC(keys_keyevent), NULL);
-    gtk_signal_connect(GTK_OBJECT(configwindow), "button_press_event",
-		       GTK_SIGNAL_FUNC(keys_buttonevent), NULL);
+    g_signal_connect(configwindow, "key_press_event",
+		       G_CALLBACK(keys_keyevent), NULL);
+    g_signal_connect(configwindow, "button_press_event",
+		       G_CALLBACK(keys_buttonevent), NULL);
 
 
     /* The button area */
@@ -685,33 +693,21 @@
 			FALSE, FALSE, 0);
     gtk_widget_show (hbox);
 
-#ifdef USE_GNOME
-    thing = gnome_stock_button (GNOME_STOCK_BUTTON_OK);
-#else
-    thing = gtk_button_new_with_label (_ ("Ok"));
-#endif
-    gtk_signal_connect (GTK_OBJECT (thing), "clicked",
-			GTK_SIGNAL_FUNC (keys_ok), NULL);
+    thing = gtk_button_new_from_stock (GTK_STOCK_OK);
+    g_signal_connect(thing, "clicked",
+			G_CALLBACK(keys_ok), NULL);
     gtk_box_pack_start (GTK_BOX (hbox), thing, FALSE, FALSE, 0);
     gtk_widget_show (thing);
 
-#ifdef USE_GNOME
-    thing = gnome_stock_button (GNOME_STOCK_BUTTON_APPLY);
-#else
-    thing = gtk_button_new_with_label (_ ("Apply"));
-#endif
-    gtk_signal_connect (GTK_OBJECT (thing), "clicked",
-			GTK_SIGNAL_FUNC (keys_apply), NULL);
+    thing = gtk_button_new_from_stock (GTK_STOCK_APPLY);
+    g_signal_connect(thing, "clicked",
+			G_CALLBACK(keys_apply), NULL);
     gtk_box_pack_start (GTK_BOX (hbox), thing, FALSE, FALSE, 0);
     gtk_widget_show (thing);
 
-#ifdef USE_GNOME
-    thing = gnome_stock_button (GNOME_STOCK_BUTTON_CANCEL);
-#else
-    thing = gtk_button_new_with_label (_ ("Cancel"));
-#endif
-    gtk_signal_connect (GTK_OBJECT (thing), "clicked",
-			GTK_SIGNAL_FUNC (keys_cancel), NULL);
+    thing = gtk_button_new_from_stock (GTK_STOCK_CANCEL);
+    g_signal_connect(thing, "clicked",
+			G_CALLBACK(keys_cancel), NULL);
     gtk_box_pack_start (GTK_BOX (hbox), thing, FALSE, FALSE, 0);
     gtk_widget_show (thing);
 
diff -Naur soundtracker-0.6.8/app/main.c soundtracker-0.6.8-gtk2/app/main.c
--- soundtracker-0.6.8/app/main.c	2006-02-25 14:02:27.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/main.c	2010-09-23 11:11:35.000000000 +0200
@@ -123,8 +123,8 @@
     {
 	int setresuid(uid_t ruid, uid_t euid, uid_t suid);
 	int setresgid(gid_t rgid, gid_t egid, gid_t sgid);
-	setresuid(getuid(), getuid(), getuid());
-	setresgid(getgid(), getgid(), getgid());
+//	setresuid(getuid(), getuid(), getuid());
+//	setresgid(getgid(), getgid(), getgid());
     }
 #else
     seteuid(getuid());
@@ -134,6 +134,7 @@
 #if ENABLE_NLS
     gtk_set_locale();
     bindtextdomain(PACKAGE, LOCALEDIR);
+    bind_textdomain_codeset(PACKAGE,"UTF-8");
     textdomain(PACKAGE);
 #endif
 
diff -Naur soundtracker-0.6.8/app/menubar.c soundtracker-0.6.8-gtk2/app/menubar.c
--- soundtracker-0.6.8/app/menubar.c	2006-02-25 13:30:54.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/menubar.c	2010-09-23 11:11:35.000000000 +0200
@@ -81,9 +81,9 @@
     GtkWidget *about = gnome_about_new("SoundTracker",
 				       VERSION,
 				       "Copyright (C) 1998-2003 Michael Krause",
-				       authors,
 				       "Includes OpenCP player from Niklas Beisert and Tammo Hinrichs.",
-				       NULL);
+				       authors,
+					  NULL, NULL, NULL);
     gtk_widget_show (about);
 #else
     GtkWidget *label, *button;
@@ -104,8 +104,8 @@
     button = gtk_button_new_with_label (_("Ok"));
     GTK_WIDGET_SET_FLAGS (button, GTK_CAN_DEFAULT);
     gtk_box_pack_start (GTK_BOX (GTK_DIALOG(about)->action_area), button, TRUE, TRUE, 10);
-    gtk_signal_connect_object (GTK_OBJECT (button), "clicked",
-                               GTK_SIGNAL_FUNC (about_close), 0);
+    g_signal_connect_swapped(button, "clicked",
+                               G_CALLBACK(about_close), 0);
     gtk_widget_grab_default (button);
     gtk_widget_show (button);
     
@@ -125,7 +125,7 @@
 	} else {
 	    gui_play_stop();
 	    st_clean_song(xm);
-	    gui_init_xm(1);
+	    gui_init_xm(1, TRUE);
 	    xm->modified = 0;
 	}
     }
@@ -716,7 +716,7 @@
 menubar_init_prefs ()
 {
 #ifndef USE_GNOME
-    gtk_item_factory_parse_rc(prefs_get_filename("non-gnome-accels"));
+    gtk_accel_map_load(prefs_get_filename("non-gnome-accels"));
 #endif
 
     gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(settings_menu[0].widget), gui_settings.gui_display_scopes);
@@ -902,7 +902,7 @@
     menubar_gnome_to_gtk_get_widgets(main_menu, 0);
     g_free(menubar_gtk_items);
 
-    gtk_accel_group_attach (accel_group, GTK_OBJECT (window));
+    gtk_window_add_accel_group (window, accel_group);
 
     thing = gtk_item_factory_get_widget (item_factory, "<main>");
     gtk_box_pack_start(GTK_BOX(destbox), thing, FALSE, TRUE, 0);
@@ -912,7 +912,7 @@
 void
 menubar_write_accels ()
 {
-    gtk_item_factory_dump_rc(prefs_get_filename("non-gnome-accels"), NULL, TRUE);
+    gtk_accel_map_save(prefs_get_filename("non-gnome-accels"));
 }
 
 #endif
diff -Naur soundtracker-0.6.8/app/midi-settings-050.c soundtracker-0.6.8-gtk2/app/midi-settings-050.c
--- soundtracker-0.6.8/app/midi-settings-050.c	2003-04-12 01:38:29.000000000 +0200
+++ soundtracker-0.6.8-gtk2/app/midi-settings-050.c	2010-09-23 11:11:35.000000000 +0200
@@ -498,23 +498,23 @@
   gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(thing),
                               settings.input.auto_connect);
   gtk_box_pack_start(GTK_BOX(page), thing, FALSE, TRUE, 0);
-  gtk_signal_connect(GTK_OBJECT(thing), "toggled",
-                     GTK_SIGNAL_FUNC(input_auto_connect_toggled), NULL);
+  g_signal_connect(thing, "toggled",
+                     G_CALLBACK(input_auto_connect_toggled), NULL);
 
   thing = gtk_check_button_new_with_label(_("Volume"));
   gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(thing),
                               settings.input.volume_enabled);
   gtk_box_pack_start(GTK_BOX(page), thing, FALSE, TRUE, 0);
 
-  gtk_signal_connect(GTK_OBJECT(thing), "toggled",
-                     GTK_SIGNAL_FUNC(input_volume_toggled), NULL);
+  g_signal_connect(thing, "toggled",
+                     G_CALLBACK(input_volume_toggled), NULL);
 
   thing = gtk_check_button_new_with_label(_("Channel"));
   gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(thing),
                               settings.input.channel_enabled);
   gtk_box_pack_start(GTK_BOX(page), thing, FALSE, TRUE, 0);
-  gtk_signal_connect(GTK_OBJECT(thing), "toggled",
-                     GTK_SIGNAL_FUNC(input_channel_toggled), NULL);
+  g_signal_connect(thing, "toggled",
+                     G_CALLBACK(input_channel_toggled), NULL);
 
   /* Create the spin button for the input client number. */
 
@@ -654,17 +654,17 @@
 
   /* Connect dialog/notebook callbacks. */
 
-  gtk_signal_connect_object( GTK_OBJECT( okay_button),
+  g_signal_connect_swapped(okay_button,
                              "clicked",
-                             GTK_SIGNAL_FUNC (dialog_okay_callback),
+                             G_CALLBACK(dialog_okay_callback),
                              0);
-  gtk_signal_connect_object( GTK_OBJECT( apply_button),
+  g_signal_connect_swapped(apply_button,
                              "clicked",
-                             GTK_SIGNAL_FUNC (dialog_apply_callback),
-                             GTK_OBJECT(midi_notebook));
-  gtk_signal_connect_object( GTK_OBJECT( cancel_button),
+                             G_CALLBACK(dialog_apply_callback),
+                             G_OBJECT(midi_notebook));
+  g_signal_connect_swapped(cancel_button,
                              "clicked",
-                             GTK_SIGNAL_FUNC (dialog_cancel_callback),
+                             G_CALLBACK(dialog_cancel_callback),
                              0);
 
   /* Add the notebook to the upper part of the dialog box. */
diff -Naur soundtracker-0.6.8/app/midi-settings-09x.c soundtracker-0.6.8-gtk2/app/midi-settings-09x.c
--- soundtracker-0.6.8/app/midi-settings-09x.c	2003-04-13 00:02:47.000000000 +0200
+++ soundtracker-0.6.8-gtk2/app/midi-settings-09x.c	2010-09-23 11:11:35.000000000 +0200
@@ -501,23 +501,23 @@
   gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(thing),
                               settings.input.auto_connect);
   gtk_box_pack_start(GTK_BOX(page), thing, FALSE, TRUE, 0);
-  gtk_signal_connect(GTK_OBJECT(thing), "toggled",
-                     GTK_SIGNAL_FUNC(input_auto_connect_toggled), NULL);
+  g_signal_connect(thing, "toggled",
+                     G_CALLBACK(input_auto_connect_toggled), NULL);
 
   thing = gtk_check_button_new_with_label(_("Volume"));
   gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(thing),
                               settings.input.volume_enabled);
   gtk_box_pack_start(GTK_BOX(page), thing, FALSE, TRUE, 0);
 
-  gtk_signal_connect(GTK_OBJECT(thing), "toggled",
-                     GTK_SIGNAL_FUNC(input_volume_toggled), NULL);
+  g_signal_connect(thing, "toggled",
+                     G_CALLBACK(input_volume_toggled), NULL);
 
   thing = gtk_check_button_new_with_label(_("Channel"));
   gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(thing),
                               settings.input.channel_enabled);
   gtk_box_pack_start(GTK_BOX(page), thing, FALSE, TRUE, 0);
-  gtk_signal_connect(GTK_OBJECT(thing), "toggled",
-                     GTK_SIGNAL_FUNC(input_channel_toggled), NULL);
+  g_signal_connect(thing, "toggled",
+                     G_CALLBACK(input_channel_toggled), NULL);
 
   /* Create the spin button for the input client number. */
 
@@ -657,17 +657,17 @@
 
   /* Connect dialog/notebook callbacks. */
 
-  gtk_signal_connect_object( GTK_OBJECT( okay_button),
+  g_signal_connect_swapped(okay_button,
                              "clicked",
-                             GTK_SIGNAL_FUNC (dialog_okay_callback),
+                             G_CALLBACK(dialog_okay_callback),
                              0);
-  gtk_signal_connect_object( GTK_OBJECT( apply_button),
+  g_signal_connect_swapped(apply_button,
                              "clicked",
-                             GTK_SIGNAL_FUNC (dialog_apply_callback),
-                             GTK_OBJECT(midi_notebook));
-  gtk_signal_connect_object( GTK_OBJECT( cancel_button),
+                             G_CALLBACK(dialog_apply_callback),
+                             G_OBJECT(midi_notebook));
+  g_signal_connect_swapped(cancel_button,
                              "clicked",
-                             GTK_SIGNAL_FUNC (dialog_cancel_callback),
+                             G_CALLBACK(dialog_cancel_callback),
                              0);
 
   /* Add the notebook to the upper part of the dialog box. */
diff -Naur soundtracker-0.6.8/app/mixers/integer32-asm.S soundtracker-0.6.8-gtk2/app/mixers/integer32-asm.S
--- soundtracker-0.6.8/app/mixers/integer32-asm.S	2002-08-17 18:11:49.000000000 +0200
+++ soundtracker-0.6.8-gtk2/app/mixers/integer32-asm.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,234 +0,0 @@
-
-/*
- * The Real SoundTracker - Assembly routines for the mixer (header)
- *
- * Copyright (C) 1999 Michael Krause
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-
- --------------------------------------------------------------------------
-	
- The first code ever that I've written in i386 Assembly. It's not been
- optimized for pairing / pipelining, and it's only marginally faster than
- the C version on my K6-2 @400 (12-13% instead of 14% CPU usage with
- astaris.xm -- stereo_16_scopes, that is).
-
- --------------------------------------------------------------------------
- */
-
-#ifndef _C_LABEL
-# ifdef __ELF__
-#  define _C_LABEL(x) x
-# else
-#  define _C_LABEL(x) _ ## x
-# endif
-#endif
-#undef GLOBAL
-#define GLOBAL(x)   .globl _C_LABEL(x); _C_LABEL(x):
-
-#if defined(__i386__)
-	
-#define ACCURACY 12
-	
-.text
-
- GLOBAL(mixerasm_stereo_16_scopes)
-	pushl	%ebp
-	movl	%esp,%ebp
-
-	pushl	%edi
-	pushl	%esi
-	pushl	%ebx
-	pushl	%ecx
-	pushl	%edx
-
-	movl	8(%ebp),%eax	# eax = fixed-point sample position
-	movl	16(%ebp),%esi	# esi = source sample data
-	movl	20(%ebp),%ecx	# ecx = destination mixed data (32bit)
-	movl	24(%ebp),%edi	# edi = destination scope data (8bit)
-	movl	40(%ebp),%esp	# esp = loop counter
-				# ebx, edx = working registers
-.0:
-	movl	%eax,%ebx	# Get sample into edx
-	sarl	$ACCURACY,%ebx
-	movswl	(%esi,%ebx,2),%edx
-
-	imull	28(%ebp),%edx	# Apply volume
-
-	movl	%edx,%ebx	# left channel
-	imull	32(%ebp),%ebx		
-	sarl	$6,%ebx
-	addl	%ebx,(%ecx)
-
-	movl	%edx, %ebx	# right channel
-	imull	36(%ebp),%ebx
-	sarl	$6,%ebx
-	addl	%ebx,4(%ecx)
-	sarl	$6,%edx
-
-	addl	$8,%ecx		# (increment mixed data pointer)
-	movw	%dx,(%edi)	# Store scope data
-	addl	12(%ebp),%eax	# (increment sample position pointer)
-
-	lea	2(%edi),%edi	# (increment scope data pointer)
-	
-	decl	%esp		# loop
-	jnz	.0
-
-	lea	-20(%ebp),%esp
-		
-	popl	%edx
-	popl	%ecx
-	popl	%ebx
-	popl	%esi
-	popl	%edi
-		
-	leave
-	ret
-
- GLOBAL(mixerasm_mono_16_scopes)
-	pushl	%ebp
-	movl	%esp,%ebp
-
-	pushl	%edi
-	pushl	%esi
-	pushl	%ebx
-	pushl	%ecx
-	pushl	%edx
-
-	movl	8(%ebp),%eax	# eax = fixed-point sample position
-	movl	16(%ebp),%esi	# esi = source sample data
-	movl	20(%ebp),%ecx	# ecx = destination mixed data (32bit)
-	movl	24(%ebp),%edi	# edi = destination scope data (8bit)
-	movl	32(%ebp),%esp	# esp = loop counter
-	movl	28(%ebp),%ebx	# ebx = volume
-				# edx = working register
-.1:
-	movl	%eax,%edx	# Get sample into edx
-	sarl	$ACCURACY,%edx
-	movswl	(%esi,%edx,2),%edx
-
-	imull	%ebx,%edx	# Apply volume
-	addl	%edx,(%ecx)
-
-	sarl	$6,%edx
-	movw	%dx,(%edi)	# Store scope data
-	lea	2(%edi),%edi	# (increment scope data pointer)
-
-	addl	$4,%ecx
-	addl	12(%ebp),%eax	# (increment sample position pointer)
-
-	decl	%esp		# loop
-	jnz	.1
-
-	lea	-20(%ebp),%esp
-		
-	popl	%edx
-	popl	%ecx
-	popl	%ebx
-	popl	%esi
-	popl	%edi
-		
-	leave
-	ret
-
- GLOBAL(mixerasm_stereo_16)
-	pushl	%ebp
-	movl	%esp,%ebp
-
-	pushl	%edi
-	pushl	%esi
-	pushl	%ebx
-	pushl	%ecx
-	pushl	%edx
-
-	movl	8(%ebp),%eax	# eax = fixed-point sample position
-	movl	12(%ebp),%ecx	# ecx = increment
-	movl	16(%ebp),%esi	# esi = source sample data
-	movl	20(%ebp),%edi	# edi = destination mixed data (32bit)
-	movl	32(%ebp),%esp	# esp = loop counter
-				# ebx, edx = working registers
-.2:
-	movl	%eax,%ebx	# Get sample into edx
-	sarl	$ACCURACY,%ebx
-	movswl	(%esi,%ebx,2),%edx
-	movl	%edx,%ebx
-
-	imull	24(%ebp),%ebx	# left channel
-	imull	28(%ebp),%edx	# right channel
-	sarl	$6,%ebx
-	sarl	$6,%edx
-	addl	%ebx,(%edi)
-	addl	%edx,4(%edi)
-
-	addl	$8,%edi		# (increment mixed data pointer)
-	addl	%ecx,%eax	# (increment sample position pointer)
-
-	decl	%esp		# loop
-	jnz	.2
-
-	lea	-20(%ebp),%esp
-		
-	popl	%edx
-	popl	%ecx
-	popl	%ebx
-	popl	%esi
-	popl	%edi
-		
-	leave
-	ret
-
- GLOBAL(mixerasm_mono_16)
-	pushl	%ebp
-	movl	%esp,%ebp
-
-	pushl	%edi
-	pushl	%esi
-	pushl	%ebx
-	pushl	%ecx
-	pushl	%edx
-
-	movl	8(%ebp),%eax	# eax = fixed-point sample position
-	movl	12(%ebp),%ecx	# ecx = increment
-	movl	16(%ebp),%esi	# esi = source sample data
-	movl	20(%ebp),%edi	# edi = destination mixed data (32bit)
-	movl	28(%ebp),%esp	# esp = loop counter
-	movl	24(%ebp),%ebx	# ebx = volume
-				# edx = working register
-.3:
-	movl	%eax,%edx	# Get sample into edx
-	sarl	$ACCURACY,%edx
-	movswl	(%esi,%edx,2),%edx
-
-	imull	%ebx,%edx	# Apply volume
-	addl	%ecx,%eax	# (increment sample position pointer)
-	addl	%edx,(%edi)
-	addl	$4,%edi
-
-	decl	%esp		# loop
-	jnz	.3
-
-	lea	-20(%ebp),%esp
-		
-	popl	%edx
-	popl	%ecx
-	popl	%ebx
-	popl	%esi
-	popl	%edi
-		
-	leave
-	ret
-
-#endif /* defined(__i386__) */
diff -Naur soundtracker-0.6.8/app/mixers/kb-x86-asmIntel.a soundtracker-0.6.8-gtk2/app/mixers/kb-x86-asmIntel.a
--- soundtracker-0.6.8/app/mixers/kb-x86-asmIntel.a	2000-09-19 17:56:05.000000000 +0200
+++ soundtracker-0.6.8-gtk2/app/mixers/kb-x86-asmIntel.a	1970-01-01 01:00:00.000000000 +0100
@@ -1,387 +0,0 @@
-; The Real SoundTracker - Cubically interpolating mixing routines
-;                         with IT style filter support
-; Version for non-gas assemblers by Fabian Giesen, as of ST v0.5.4.
-;
-; Copyright (C) 1999-2000 Tammo Hinrichs
-; Copyright (C) 2000 Michael Krause
-; Copyright (C) 2000 Fabian Giesen
-;
-; This program is free software; you can redistribute it and/or modify
-; it under the terms of the GNU General Public License as published by
-; the Free Software Foundation; either version 2 of the License, or
-; (at your option) any later version.
-;
-; This program is distributed in the hope that it will be useful,
-; but WITHOUT ANY WARRANTY; without even the implied warranty of
-; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-; GNU General Public License for more details.
-;
-; You should have received a copy of the GNU General Public License
-; along with this program; if not, write to the Free Software
-; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-;
-;
-
-section      .data
-
-_volrl       dd 0
-_volrr       dd 0
-_voll        dd 0
-_volr        dd 0
-magic1       dd 0
-ebpstore     dd 0
-store2       dd 0
-scopebuf     dd 0
-
-ffreq        dd 0.0
-freso        dd 0.0
-fl1          dd 0.0
-fb1          dd 0.0
-
-minampl      dd 0.0001
-cremoveconst dd 0.992
-clampmax     dd 32766.0
-clampmin:    dd -32767.0
-minuseins:   dd -1.0
-
-extern _kb_x86_outbuf
-extern _kb_x86_tempbuf
-extern _kb_x86_nsamples
-extern _kb_x86_amplification
-extern _kb_x86_ct0
-extern _kb_x86_ct1
-extern _kb_x86_ct2
-extern _kb_x86_ct3
-
-section      .text
-
-global _kbasm_prepare_mixer
-_kbasm_prepare_mixer:
-    push    ebp
-    mov     ebp, esp
-
-    push    eax
-
-    ; nothing happening here right now...
-	
-    pop     eax
-
-	leave
-	ret
-
-global _kbasm_post_mixing
-_kbasm_post_mixing:
-    push    ebp
-    mov     ebp, esp
-
-    push    ebx
-    push    ecx
-    push    edx
-    push    esi
-    push    edi
-	
-	finit
-
-    mov     edi,[_kb_x86_outbuf]
-    mov     esi,[_kb_x86_tempbuf]
-    mov     ecx,[_kb_x86_nsamples]
-    shl     ecx,1         ; stereo
-	
-	call	clipstereo
-
-    pop     edi
-    pop     esi
-    pop     edx
-    pop     ecx
-    pop     ebx
-
-	leave
-	ret
-
-clipstereo: ; convert/clip samples, 16bit signed
-    fld     dword [_kb_x86_amplification]
-    fld     dword [clampmin]    ; (min) (amp)
-    fld     dword [clampmax]    ; (max) (min) (amp)
-    mov     bx, 32766
-    mov     dx, -32767
-    mov     [ebpstore],ebp
-    xor     ebp,ebp
-		
-.lp:
-    fld     dword [esi]         ; (ls) (max) (min) (amp)
-    fmul    st3
-    fcom    st1
-    fnstsw  ax
-	sahf
-    ja      .max
-    fcom    st2
-    fstsw   ax
-	sahf
-    jb      .min
-    fistp   word [edi]          ; (max) (min) (amp)
-
-.next:
-    add     esi,4
-    add     edi,2 
-    dec     ecx
-    jnz     .lp
-    jmp     short .ende
-
-.max:
-    fstp    st0     ; (max) (min) (amp)
-    mov     [edi], bx
-    inc     ebp
-    jmp     short .next
-
-.min:
-    fstp    st0     ; (max) (min) (amp)
-    mov     [edi], dx
-    inc     ebp
-    jmp     short .next
-
-.ende:
-    mov     eax, ebp
-    mov     ebp, [ebpstore]
-    fstp    st0     ; (min) (amp)
-    fstp    st0     ; (amp)
-    fstp    st0     ; -
-	ret
-
-global _kbasm_mix
-_kbasm_mix:
-    push    ebp
-    mov     ebp, esp
-
-    push    eax
-    push    ebx
-    push    ecx
-    push    edx
-    push    esi
-    push    edi
-	
-	finit
-
-    mov     [ebpstore],ebp
-    mov     ebp,[ebp+8]
-
-    ; Put data into appropriate places for the real mixer subroutine
-    mov     eax,[ebp]
-    mov     ebx,[ebp+4]
-    mov     [_voll],eax
-    mov     [_volr],ebx
-    mov     eax,[ebp+8]
-    mov     ebx,[ebp+12]
-    mov     [_volrl],eax
-    mov     [_volrr],ebx
-
-    mov     eax,[ebp+44]
-    mov     [ffreq],eax
-    mov     eax,[ebp+48]
-    mov     [freso],eax
-    mov     eax,[ebp+52]
-    mov     [fl1],eax
-    mov     eax,[ebp+56]
-    mov     [fb1],eax
-    mov     ecx,[ebp+60]
-    mov     [scopebuf],ecx
-    mov     ebx,[ebp+24] ; freqi
-    mov     esi,[ebp+28] ; freqf
-    mov     eax,[ebp+16] ; pointer to sample data
-    mov     edx,[ebp+20] ; sample position (fractional part)
-    mov     edi,[ebp+32] ; destination float buffer
-    mov     ecx,[ebp+36] ; number of samples to mix
-
-    mov     ebp,[ebp+64]
-    add     ebp,_kbasm_mixers
-    mov     ebp,[ebp]
-    call    ebp
-	
-    ; Update changed values
-    mov     ebp,[ebpstore]
-    mov     ebp,[ebp+8]
-
-    mov     [ebp+16],eax ; pointer to sample data
-    mov     [ebp+20],edx ; sample position (fractional part)
-    mov     [ebp+32],edi ; destination float buffer
-    mov     eax,[fl1]
-    mov     [ebp+52],eax
-    mov     eax,[fb1]
-    mov     [ebp+56],eax
-	
-    mov     eax,[_voll]
-    mov     ebx,[_volr]
-    mov     [ebp],eax
-    mov     [ebp+4],ebx
-
-    mov     ebp,[ebpstore]
-
-    pop     edi
-    pop     esi
-    pop     edx
-    pop     ecx
-    pop     ebx
-    pop     eax
-
-	leave
-	ret
-
-%macro cubicmixer 4
-    fld     dword [_voll]
-    fld     dword [_volr]
-    mov     ebp,eax
-    shr     ebp,1
-    mov     eax,edx
-%if %3
-    neg     eax
-%endif
-    shr     eax,24
-%if %1
-    mov     [store2],esp
-    mov     esp,[scopebuf]
-%endif
-    align   16
-%%mixlp:
-    fild    word [ebp*2]               
-    fmul    dword [_kb_x86_ct0+eax*4]   
-%if %3
-    fild    word [ebp*2-2]             
-    fmul    dword [_kb_x86_ct1+eax*4]   
-    fild    word [ebp*2-4]             
-    fmul    dword [_kb_x86_ct2+eax*4]   
-    fild    word [ebp*2-6]             
-%else
-    fild    word [ebp*2+2]             
-    fmul    dword [_kb_x86_ct1+eax*4]   
-    fild    word [ebp*2+4]             
-    fmul    dword [_kb_x86_ct2+eax*4]   
-    fild    word [ebp*2+6]             
-%endif
-    fmul    dword [_kb_x86_ct3+eax*4]   
-    fxch    st2
-    faddp   st3,st0
-    add     edx,esi
-    lea     edi,[edi+8]
-    faddp   st2,st0
-    adc     ebp,ebx
-    mov     eax,edx
-    faddp   st1,st0
-%if %3
-    neg     eax
-%endif
-%if %2
-    fsub    dword [fl1]
-    fmul    dword [ffreq]
-    fld     dword [fb1]
-    fmul    dword [freso]
-    faddp   st1,st0
-    fst     dword [fb1]
-    fmul    dword [ffreq]
-    fadd    dword [fl1]
-    fst     dword [fl1]
-%endif
-%if %1
-    fld     st0
-    fmul    st2
-    fld     st1
-    fmul    st4
-    faddp   st1,st0
-    fistp   word [esp]
-    lea     esp,[esp+2]
-%endif
-    shr     eax,24
-%if %4
-    fld     st1
-    fld     st3
-    fmul    st2
-    fxch    st4
-    fadd    dword [_volrl]
-    fxch    st2
-    fmulp   st1
-    fxch    st2
-    fadd    dword [_volrr]
-    fxch    st3
-    fadd    dword [edi-8]
-    fxch    st2
-    fadd    dword [edi-4]
-    fstp    dword [edi-4]
-    fxch    st1
-    fstp    dword [edi-8]
-    fxch    st1
-%else
-    fld     st2
-    fmul    st1
-    fadd    dword [edi-8]
-    fxch    st1
-    fmul    st2
-    fadd    dword [edi-4]
-    fstp    dword [edi-4]
-    fstp    dword [edi-8]
-%endif
-    dec     ecx
-    jz      %%mixend
-    jmp     %%mixlp
-%%mixend:
-%if %4
-    fstp    dword [_volr]
-    fstp    dword [_voll]
-%endif
-    shl     ebp,1
-    mov     eax,ebp
-%if %1
-    mov     esp,[store2]
-%endif
-    ret
-%endmacro
-
-_kbasm_mix_cubic_noscopes_unfiltered_forward_noramp:
-    cubicmixer 0,0,0,0
-_kbasm_mix_cubic_noscopes_unfiltered_backward_noramp:
-    cubicmixer 0,0,1,0
-_kbasm_mix_cubic_noscopes_filtered_forward_noramp:
-    cubicmixer 0,1,0,0
-_kbasm_mix_cubic_noscopes_filtered_backward_noramp:
-    cubicmixer 0,1,1,0
-_kbasm_mix_cubic_scopes_unfiltered_forward_noramp:
-    cubicmixer 1,0,0,0
-_kbasm_mix_cubic_scopes_unfiltered_backward_noramp:
-    cubicmixer 1,0,1,0
-_kbasm_mix_cubic_scopes_filtered_forward_noramp:
-    cubicmixer 1,1,0,0
-_kbasm_mix_cubic_scopes_filtered_backward_noramp:
-    cubicmixer 1,1,1,0
-_kbasm_mix_cubic_noscopes_unfiltered_forward:
-    cubicmixer 0,0,0,1
-_kbasm_mix_cubic_noscopes_unfiltered_backward:
-    cubicmixer 0,0,1,1
-_kbasm_mix_cubic_noscopes_filtered_forward:
-    cubicmixer 0,1,0,1
-_kbasm_mix_cubic_noscopes_filtered_backward:
-    cubicmixer 0,1,1,1
-_kbasm_mix_cubic_scopes_unfiltered_forward:
-    cubicmixer 1,0,0,1
-_kbasm_mix_cubic_scopes_unfiltered_backward:
-    cubicmixer 1,0,1,1
-_kbasm_mix_cubic_scopes_filtered_forward:
-    cubicmixer 1,1,0,1
-_kbasm_mix_cubic_scopes_filtered_backward:
-    cubicmixer 1,1,1,1
-
-section    .data
-global _kbasm_mixers
-_kbasm_mixers:
-    dd _kbasm_mix_cubic_noscopes_unfiltered_forward_noramp
-    dd _kbasm_mix_cubic_noscopes_unfiltered_backward_noramp
-    dd _kbasm_mix_cubic_noscopes_filtered_forward_noramp
-    dd _kbasm_mix_cubic_noscopes_filtered_backward_noramp
-    dd _kbasm_mix_cubic_scopes_unfiltered_forward_noramp
-    dd _kbasm_mix_cubic_scopes_unfiltered_backward_noramp
-    dd _kbasm_mix_cubic_scopes_filtered_forward_noramp
-    dd _kbasm_mix_cubic_scopes_filtered_backward_noramp
-    dd _kbasm_mix_cubic_noscopes_unfiltered_forward
-    dd _kbasm_mix_cubic_noscopes_unfiltered_backward
-    dd _kbasm_mix_cubic_noscopes_filtered_forward
-    dd _kbasm_mix_cubic_noscopes_filtered_backward
-    dd _kbasm_mix_cubic_scopes_unfiltered_forward
-    dd _kbasm_mix_cubic_scopes_unfiltered_backward
-    dd _kbasm_mix_cubic_scopes_filtered_forward
-    dd _kbasm_mix_cubic_scopes_filtered_backward
diff -Naur soundtracker-0.6.8/app/mixers/kb-x86-asm.S soundtracker-0.6.8-gtk2/app/mixers/kb-x86-asm.S
--- soundtracker-0.6.8/app/mixers/kb-x86-asm.S	2006-01-15 15:16:43.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/mixers/kb-x86-asm.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,391 +0,0 @@
-
-/*
- * The Real SoundTracker - Cubically interpolating mixing routines
- *                         with IT style filter support
- *
- *                         Highly optimized i386 version.
- *
- * Copyright (C) 1999-2000 Tammo Hinrichs
- * Copyright (C) 2000 Michael Krause
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- */
-
-#ifndef _C_LABEL
-# ifdef __ELF__
-#  define _C_LABEL(x) x
-# else
-#  define _C_LABEL(x) _ ## x
-# endif
-#endif
-#undef GLOBAL
-#define GLOBAL(x)   .globl _C_LABEL(x); _C_LABEL(x):
-
-#if defined(__i386__)
-
-.section	.data
-		.align 4
-
-_volrl:		.long 0
-_volrr:		.long 0
-_voll:		.long 0
-_volr:		.long 0
-magic1:		.long 0
-ebpstore:	.long 0
-store2:		.long 0
-scopebuf:	.long 0
-	
-ffreq:		.float 0.0
-freso:		.float 0.0
-fl1:		.float 0.0
-fb1:		.float 0.0
-				
-.section	.rodata
-		.align 4
-minampl:	.float 0.0001
-cremoveconst:	.float 0.992
-clampmax:	.float 32767.0
-clampmin:	.float -32767.0
-minuseins:	.float -1.0
-			
-.text
-
- GLOBAL(kbasm_post_mixing)
-	pushl	%ebp
-	movl	%esp, %ebp
-
-	pushl	%ebx
-	pushl	%ecx
-	pushl	%edx
-	pushl	%esi
-	pushl	%edi
-	
-	finit
-
-	movl	8(%ebp),%esi
-	movl	12(%ebp),%edi
-	movl	16(%ebp),%ecx
-	addl	%ecx,%ecx	// stereo
-	flds	20(%ebp)	// (amp)
-	
-	call	clipstereo
-
-	popl	%edi
-	popl	%esi
-	popl	%edx
-	popl	%ecx
-	popl	%ebx
-
-	leave
-	ret
-	
-clipstereo:	// convert/clip samples, 16bit signed
-	flds	clampmin	// (min) (amp)
-	flds	clampmax	// (max) (min) (amp)
-	movw	$32767,%bx
-	movw	$-32767,%dx
-	movl	%ebp,ebpstore
-	xorl	%ebp,%ebp
-		
-.lp:
-	flds    (%esi)		// (ls) (max) (min) (amp)
-	fmul	%st(3)
-	fcom	%st(1)
-	fnstsw	%ax
-	sahf
-	ja	.max
-	fcom	%st(2)
-	fstsw	%ax
-	sahf
-	jb	.min
-	fistp	(%edi)		// (max) (min) (amp)
-.next:
-	addl	$4,%esi
-	addl	$2,%edi
-	decl	%ecx
-	jnz	.lp
-	jmp	.ende
-
-.max:
-	fstp	%st		// (max) (min) (amp)
-	movw    %bx,(%edi)
-	incl	%ebp
-	jmp	.next
-.min:
-	fstp	%st		// (max) (min) (amp)
-	movw	%dx,(%edi)
-	incl	%ebp
-	jmp	.next
-
-.ende:
-	movl	%ebp,%eax
-	movl	ebpstore,%ebp
-	fstp	%st		// (min) (amp)
-	fstp	%st		// (amp)
-	fstp	%st		// -
-	ret
-
- GLOBAL(kbasm_mix)
-	pushl	%ebp
-	movl	%esp, %ebp
-
-	pushl	%eax
-	pushl	%ebx
-	pushl	%ecx
-	pushl	%edx
-	pushl	%esi
-	pushl	%edi
-	
-	finit
-
-	movl	%ebp,ebpstore
-	movl	8(%ebp),%ebp
-
-	// Put data into appropriate places for the real mixer subroutine
-	movl	(%ebp),%eax
-	movl	4(%ebp),%ebx
-	movl	%eax,_voll
-	movl	%ebx,_volr
-	movl	8(%ebp),%eax
-	movl	12(%ebp),%ebx
-	movl	%eax,_volrl
-	movl	%ebx,_volrr
-
-	movl	44(%ebp),%eax
-	movl	%eax,ffreq
-	movl	48(%ebp),%eax
-	movl	%eax,freso
-	movl	52(%ebp),%eax
-	movl	%eax,fl1
-	movl	56(%ebp),%eax
-	movl	%eax,fb1
-	movl	60(%ebp),%ecx
-	movl	%ecx,scopebuf
-	movl	24(%ebp),%ebx // freqi
-	movl	28(%ebp),%esi // freqf
-	movl	16(%ebp),%eax // pointer to sample data
-	movl	20(%ebp),%edx // sample position (fractional part)
-	movl	32(%ebp),%edi // destination float buffer
-	movl	36(%ebp),%ecx // number of samples to mix
-
-	movl	64(%ebp),%ebp
-	addl	$kbasm_mixers,%ebp
-	movl	(%ebp),%ebp
-	call	*%ebp
-	
-	// Update changed values
-	movl	ebpstore,%ebp
-	movl	8(%ebp),%ebp
-
-	movl	%eax,16(%ebp) // pointer to sample data
-	movl	%edx,20(%ebp) // sample position (fractional part)
-	movl	%edi,32(%ebp) // destination float buffer
-	movl	fl1,%eax
-	movl	%eax,52(%ebp)
-	movl	fb1,%eax
-	movl	%eax,56(%ebp)
-	
-	movl	_voll,%eax
-	movl	_volr,%ebx
-	movl	%eax,(%ebp)
-	movl	%ebx,4(%ebp)
-
-	movl	ebpstore,%ebp
-
-	popl	%edi
-	popl	%esi
-	popl	%edx
-	popl	%ecx
-	popl	%ebx
-	popl	%eax
-
-	leave
-	ret
-
-	.MACRO	CUBICMIXER SCOPES=0, FILTERED=0, BACKWARDS=0, VOLRAMP
-	flds	_voll			/* (vl) */
-	flds	_volr			/* (vr) (vl) */
-	movl	%eax,%ebp
-	shrl	$1,%ebp
-	movl	%edx,%eax
-	.if	\BACKWARDS 
-	negl	%eax
-	.endif
-	shrl	$24,%eax
-
-	.if	\SCOPES 
-	movl	%esp,store2
-	movl	scopebuf,%esp
-	.endif
-
-	.p2align 4,,7
-cubicmixer\@:
-	fild	(,%ebp,2)		/* (w0) (vl) */
-	fmuls	kb_x86_ct0(,%eax,4)	/* (w0') (vl) */
-	.ifeq	\BACKWARDS 
-	fild	2(,%ebp,2)		/* (w1) (w0') (vl) */
-	fmuls	kb_x86_ct1(,%eax,4)	/* (w1') (w0') (vl) */
-	fild	4(,%ebp,2)		/* (w2) (w1') (w0') (vl) */
-	fmuls	kb_x86_ct2(,%eax,4)	/* (w2') (w1') (w0') (vl) */
-	fild	6(,%ebp,2)		/* (w3) (w2') (w1') (w0') (vl) */
-	.else
-	fild	-2(,%ebp,2)		/* (w1) (w0') (vl) */
-	fmuls	kb_x86_ct1(,%eax,4)	/* (w1') (w0') (vl) */
-	fild	-4(,%ebp,2)		/* (w2) (w1') (w0') (vl) */
-	fmuls	kb_x86_ct2(,%eax,4)	/* (w2') (w1') (w0') (vl) */
-	fild	-6(,%ebp,2)		/* (w3) (w2') (w1') (w0') (vl) */
-	.endif
-	fmuls	kb_x86_ct3(,%eax,4)	/* (w3') (w2') (w1') (w0') (vl) */
-	fxch	%st(2)			/* (w1') (w2') (w3') (w0') (vr) (vl) */
-	faddp	%st,%st(3)		/* (w2') (w3') (w0+w1) (vr) (vl) */
-	addl	%esi,%edx
-	lea	8(%edi),%edi
-	faddp	%st,%st(2)		/* (w2+w3) (w0+w1) (vr) (vl) */
-	adcl	%ebx,%ebp
-	movl	%edx,%eax
-	faddp	%st,%st(1)		/* (val) (vr) (vl) */
-
-	.if	\BACKWARDS 
-	negl	%eax
-	.endif
-
-	.if	\FILTERED 
-	/* IT Filter Code */
-	/* b=reso*b+freq*(in-l); */
-	/* l+=freq*b; */
-	fsubs	fl1			/* (in-l) .. */
-	fmuls	ffreq			/* (f*(in-l)) .. */
-	flds	fb1			/* (b) (f*(in-l)) .. */
-	fmuls	freso			/* (r*b) (f*(in-l)) .. */
-	faddp	%st,%st(1)		/* (b') .. */
-	fsts	fb1
-	fmuls	ffreq			/* (f*b') .. */
-	fadds	fl1			/* (l') .. */
-	fsts	fl1			/* (val) (vr) (vl) */
-	.endif
-
-	shrl	$24,%eax
-
-	.if	\SCOPES 
-	/* Scopes */
-	fld	%st(1)                  /* (vr) (val) (vr) (vl) */
-	fadd	%st(3)			/* (vr + vl) (val) (vr) (vl) */
-	fmul	%st(1),%st		/* (val * (vr + vl)) (val) (vr) (vl) */
-	fistp	(%esp)			/* (val) (vr) (vl) */
-	lea	2(%esp),%esp
-	.endif
-
-	.if	\VOLRAMP 
-	fld	%st(1)			/* (vr) (val) (vr) (vl) */
-	fld	%st(3)			/* (vl) (vr) (val) (vr) (vl) */
-	fmul	%st(2),%st		/* (left) (vr) (val) (vr) (vl) */
-	fxch	%st(4)			/* (vl)  (vr) (val) (vr) (left) */
-	fadds	_volrl			/* (vl') (vr) (val) (vr) (left) */
-	fxch	%st(2)			/* (val) (vr) (vl') (vr) (left) */
-	fmulp	%st(1)			/* (right) (vl') (vr) (left) */
-	fxch	%st(2)			/* (vr) (vl') (right) (left) */
-	fadds	_volrr			/* (vr') (vl') (right) (left) */
-	fxch	%st(3)			/* (left)  (vl') (right) (vr') */
-	fadds	-8(%edi)		/* (lfinal) (vl') (right) (vr') */
-	fxch	%st(2)			/* (right) (vl') (lfinal) (vr') */
-	fadds	-4(%edi)		/* (rfinal) (vl') (lfinal) (vr') */
-	fstps	-4(%edi)		/* (vl') (lfinal) (vr') */
-	fxch	%st(1)			/* (lfinal) (vl) (vr) */
-	fstps	-8(%edi)		/* (vl) (vr) */
-	fxch	%st(1)			/* (vr) (vl) */
-	.else
-	fld	%st(2)			/* (vl) (val) (vr) (vl) */
-	fmul	%st(1),%st		/* (left) (val) (vr) (vl) */
-	fadds	-8(%edi)		/* (lfinal) (val) (vr) (vl) */
-	fxch	%st(1)			/* (val) (lfinal) (vr) (vl) */
-	fmul	%st(2),%st		/* (right) (lfinal) (vr) (vl) */
-	fadds	-4(%edi)		/* (rfinal) (lfinal) (vr) (vl) */
-	fstps	-4(%edi)		/* (lfinal) (vr) (vl) */
-	fstps	-8(%edi)		/* (vr) (vl) */
-	.endif
-		
-	decl	%ecx
-	jnz	cubicmixer\@
-
-	.if	\VOLRAMP 
-	fstps	_volr			/* (vl) */
-	fstps	_voll			/* - */
-	.endif
-	shll	$1,%ebp
-	movl	%ebp,%eax
-
-	.if	\SCOPES 
-	movl	store2,%esp
-	.endif
-
-	ret
-	.ENDM
-
-kbasm_mix_cubic_noscopes_unfiltered_forward_noramp:
-	CUBICMIXER 0, 0, 0, 0
-kbasm_mix_cubic_noscopes_unfiltered_backward_noramp:
-	CUBICMIXER 0, 0, 1, 0
-kbasm_mix_cubic_noscopes_filtered_forward_noramp:
-	CUBICMIXER 0, 1, 0, 0
-kbasm_mix_cubic_noscopes_filtered_backward_noramp:
-	CUBICMIXER 0, 1, 1, 0
-kbasm_mix_cubic_scopes_unfiltered_forward_noramp:
-	CUBICMIXER 1, 0, 0, 0
-kbasm_mix_cubic_scopes_unfiltered_backward_noramp:
-	CUBICMIXER 1, 0, 1, 0
-kbasm_mix_cubic_scopes_filtered_forward_noramp:
-	CUBICMIXER 1, 1, 0, 0
-kbasm_mix_cubic_scopes_filtered_backward_noramp:
-	CUBICMIXER 1, 1, 1, 0
-kbasm_mix_cubic_noscopes_unfiltered_forward:
-	CUBICMIXER 0, 0, 0, 1
-kbasm_mix_cubic_noscopes_unfiltered_backward:
-	CUBICMIXER 0, 0, 1, 1
-kbasm_mix_cubic_noscopes_filtered_forward:
-	CUBICMIXER 0, 1, 0, 1
-kbasm_mix_cubic_noscopes_filtered_backward:
-	CUBICMIXER 0, 1, 1, 1
-kbasm_mix_cubic_scopes_unfiltered_forward:
-	CUBICMIXER 1, 0, 0, 1
-kbasm_mix_cubic_scopes_unfiltered_backward:
-	CUBICMIXER 1, 0, 1, 1
-kbasm_mix_cubic_scopes_filtered_forward:
-	CUBICMIXER 1, 1, 0, 1
-kbasm_mix_cubic_scopes_filtered_backward:
-	CUBICMIXER 1, 1, 1, 1
-
-.section	.data
- GLOBAL(kbasm_mixers)
-	.long kbasm_mix_cubic_noscopes_unfiltered_forward_noramp
-	.long kbasm_mix_cubic_noscopes_unfiltered_backward_noramp
-	.long kbasm_mix_cubic_noscopes_filtered_forward_noramp
-	.long kbasm_mix_cubic_noscopes_filtered_backward_noramp
-	.long kbasm_mix_cubic_scopes_unfiltered_forward_noramp
-	.long kbasm_mix_cubic_scopes_unfiltered_backward_noramp
-	.long kbasm_mix_cubic_scopes_filtered_forward_noramp
-	.long kbasm_mix_cubic_scopes_filtered_backward_noramp
-	.long kbasm_mix_cubic_noscopes_unfiltered_forward
-	.long kbasm_mix_cubic_noscopes_unfiltered_backward
-	.long kbasm_mix_cubic_noscopes_filtered_forward
-	.long kbasm_mix_cubic_noscopes_filtered_backward
-	.long kbasm_mix_cubic_scopes_unfiltered_forward
-	.long kbasm_mix_cubic_scopes_unfiltered_backward
-	.long kbasm_mix_cubic_scopes_filtered_forward
-	.long kbasm_mix_cubic_scopes_filtered_backward
-
-#endif /* defined(__i386__) */
-
-	.END
diff -Naur soundtracker-0.6.8/app/mixers/Makefile.am soundtracker-0.6.8-gtk2/app/mixers/Makefile.am
--- soundtracker-0.6.8/app/mixers/Makefile.am	2006-02-25 14:24:43.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/mixers/Makefile.am	2010-09-23 11:11:35.000000000 +0200
@@ -1,17 +1,8 @@
-EXTRA_DIST = kb-x86-asm.S kb-x86-asmIntel.a \
-	integer32.c integer32-asm.S integer32-asm.h
-
 noinst_LIBRARIES = libmixers.a
 
-if NO_ASM
 MIXERSOURCES = \
 	integer32.c \
 	kb-x86.c kbfloat-mix.c kb-x86-asm.h
-else
-MIXERSOURCES = \
-	integer32.c integer32-asm.S integer32-asm.h \
-	kb-x86.c kb-x86-asm.h kb-x86-asm.S
-endif
 
 libmixers_a_SOURCES = $(MIXERSOURCES)
 
diff -Naur soundtracker-0.6.8/app/module-info.c soundtracker-0.6.8-gtk2/app/module-info.c
--- soundtracker-0.6.8/app/module-info.c	2003-05-24 13:22:40.000000000 +0200
+++ soundtracker-0.6.8-gtk2/app/module-info.c	2010-09-23 11:11:35.000000000 +0200
@@ -21,8 +21,10 @@
 
 #include <stdio.h>
 #include <string.h>
+#include <glib.h>
+#include <glib/gprintf.h>
 
-#include <gtk/gtkfeatures.h>
+//#include <gtk/gtkfeatures.h>
 
 #include "i18n.h"
 #include "module-info.h"
@@ -72,51 +74,57 @@
 }
 
 static void
-ilist_size_allocate (GtkCList *list)
+ilist_select (GtkTreeSelection *sel)
 {
-    gtk_clist_set_column_width(list, 0, 30);
-    gtk_clist_set_column_width(list, 2, 30);
-    gtk_clist_set_column_width(list, 1, list->clist_window_width - 2 * 30 - 2 * 8 - 6);
+    GtkTreeModel *mdl;
+    GtkTreeIter iter;
+    gchar *str;
+    gint row;
+    
+    if(gtk_tree_selection_get_selected(sel, &mdl, &iter)) {
+	row = atoi(str = gtk_tree_model_get_string_from_iter(mdl, &iter));
+	g_free(str);
+	if(row == curi)
+	    return;
+	curi = row;
+	gui_set_current_instrument(row + 1);
+    }
 }
 
 static void
-slist_size_allocate (GtkCList *list)
+slist_select (GtkTreeSelection *sel)
 {
-    gtk_clist_set_column_width(list, 0, 30);
-    gtk_clist_set_column_width(list, 1, list->clist_window_width - 30 - 8 - 7);
-}
-
-static void
-ilist_select (GtkCList *list,
-	      gint row,
-	      gint column)
-{
-    if(row == curi)
-	return;
-    curi = row;
-    gui_set_current_instrument(row + 1);
-}
-
-static void
-slist_select (GtkCList *list,
-	      gint row,
-	      gint column)
-{
-    if(row == curs)
-	return;
-    curs = row;
-    gui_set_current_sample(row);
+    GtkTreeModel *mdl;
+    GtkTreeIter iter;
+    gchar *str;
+    gint row;
+    
+    if(gtk_tree_selection_get_selected(sel, &mdl, &iter)) {
+	row = atoi(str = gtk_tree_model_get_string_from_iter(mdl, &iter));
+	g_free(str);
+	if(row == curs)
+	    return;
+	curs = row;
+	gui_set_current_sample(row);
+    }
 }
 
 void
 modinfo_page_create (GtkNotebook *nb)
 {
     GtkWidget *hbox, *thing, *vbox;
+    GtkListStore *list_store;
+    GtkTreeIter iter;
+    GtkTreeModel *model;
     gchar *ititles[3] = { "n", _("Instrument Name"), _("#smpl") };
     gchar *stitles[2] = { "n", _("Sample Name") };
+    GType itypes[3] = {G_TYPE_INT, G_TYPE_STRING, G_TYPE_INT};
+    GType stypes[2] = {G_TYPE_INT, G_TYPE_STRING};
+    gfloat ialignments[3] = {0.5, 0.0, 0.5};
+    gfloat salignments[2] = {0.5, 0.0};
+    gboolean iexpands[3] = {FALSE, TRUE, FALSE};
+    gboolean sexpands[3] = {FALSE, TRUE};
     static const char *freqlabels[] = { N_("Linear"), N_("Amiga"), NULL };
-    char buf[5];
-    gchar *insertbuf[3] = { buf, "", "0" };
     int i;
 
     hbox = gtk_hbox_new(TRUE, 10);
@@ -124,38 +132,32 @@
     gtk_notebook_append_page(nb, hbox, gtk_label_new(_("Module Info")));
     gtk_widget_show(hbox);
 
-    ilist = gui_clist_in_scrolled_window(3, ititles, hbox);
-    gtk_clist_set_selection_mode(GTK_CLIST(ilist), GTK_SELECTION_BROWSE);
-    gtk_clist_column_titles_passive(GTK_CLIST(ilist));
-    gtk_clist_set_column_justification(GTK_CLIST(ilist), 0, GTK_JUSTIFY_CENTER);
-    gtk_clist_set_column_justification(GTK_CLIST(ilist), 1, GTK_JUSTIFY_LEFT);
-    gtk_clist_set_column_justification(GTK_CLIST(ilist), 2, GTK_JUSTIFY_CENTER);
+    ilist = gui_list_in_scrolled_window(3, ititles, hbox, itypes, ialignments,
+					iexpands, GTK_SELECTION_BROWSE);
+    list_store = GUI_GET_LIST_STORE(ilist);
+    model = gui_list_freeze(ilist);
     for(i = 1; i <= 128; i++) {
-	sprintf(buf, "%d", i);
-	gtk_clist_append(GTK_CLIST(ilist), insertbuf);
+	gtk_list_store_append(list_store, &iter);
+	gtk_list_store_set(list_store, &iter, 0, i, 1, "", 2, 0, -1);
     }
-    gtk_signal_connect_after(GTK_OBJECT(ilist), "size_allocate",
-			     GTK_SIGNAL_FUNC(ilist_size_allocate), NULL);
-    gtk_signal_connect_after(GTK_OBJECT(ilist), "select_row",
-			     GTK_SIGNAL_FUNC(ilist_select), NULL);
+    gui_list_thaw(ilist, model);
+
+    gui_list_handle_selection(ilist, G_CALLBACK(ilist_select), NULL);
 
     vbox = gtk_vbox_new(FALSE, 2);
     gtk_box_pack_start(GTK_BOX(hbox), vbox, TRUE, TRUE, 0);
     gtk_widget_show(vbox);
 
-    slist = gui_clist_in_scrolled_window(2, stitles, vbox);
-    gtk_clist_set_selection_mode(GTK_CLIST(slist), GTK_SELECTION_BROWSE);
-    gtk_clist_column_titles_passive(GTK_CLIST(slist));
-    gtk_clist_set_column_justification(GTK_CLIST(slist), 0, GTK_JUSTIFY_CENTER);
-    gtk_clist_set_column_justification(GTK_CLIST(slist), 1, GTK_JUSTIFY_LEFT);
-    for(i = 0; i < 16; i++) {
-	sprintf(buf, "%d", i);
-	gtk_clist_append(GTK_CLIST(slist), insertbuf);
-    }
-    gtk_signal_connect_after(GTK_OBJECT(slist), "size_allocate",
-			     GTK_SIGNAL_FUNC(slist_size_allocate), NULL);
-    gtk_signal_connect_after(GTK_OBJECT(slist), "select_row",
-			     GTK_SIGNAL_FUNC(slist_select), NULL);
+    slist = gui_list_in_scrolled_window(2, stitles, vbox, stypes, salignments,
+					sexpands, GTK_SELECTION_BROWSE);
+    list_store = GUI_GET_LIST_STORE(slist);
+    model = gui_list_freeze(slist);
+    for(i = 1; i <= 16; i++) {
+	gtk_list_store_append(list_store, &iter);
+	gtk_list_store_set(list_store, &iter, 0, i, 1, "", -1);
+    }
+    gui_list_thaw(slist, model);
+    gui_list_handle_selection(slist, G_CALLBACK(slist_select), NULL);
 
     hbox = gtk_hbox_new(FALSE, 4);
     gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);
@@ -167,8 +169,8 @@
 
     gui_get_text_entry(20, songname_changed, &songname);
     gtk_box_pack_start(GTK_BOX(hbox), songname, TRUE, TRUE, 0);
-    gtk_signal_connect_after(GTK_OBJECT(songname), "changed",
-			     GTK_SIGNAL_FUNC(songname_changed), NULL);
+    g_signal_connect_after(songname, "changed",
+			     G_CALLBACK(songname_changed), NULL);
     gtk_widget_show(songname);
 
     hbox = gtk_hbox_new(FALSE, 4);
@@ -184,11 +186,10 @@
     ptmode_toggle = gtk_check_button_new_with_label(_("ProTracker Mode"));
     gtk_box_pack_start(GTK_BOX(hbox), ptmode_toggle, FALSE, TRUE, 0);
     gtk_widget_show(ptmode_toggle);
-    gtk_signal_connect (GTK_OBJECT(ptmode_toggle), "toggled",
-			GTK_SIGNAL_FUNC(ptmode_changed), NULL);
+    g_signal_connect(ptmode_toggle, "toggled",
+			G_CALLBACK(ptmode_changed), NULL);
 
     add_empty_hbox(hbox);
-
 }
 
 void
@@ -230,12 +231,13 @@
 modinfo_update_instrument (int n)
 {
     int i;
-    GtkCList *list = GTK_CLIST(ilist);
-    char buf[5];
+    GtkTreeIter iter;
+    GtkListStore *list_store = GUI_GET_LIST_STORE(ilist);
 
-    gtk_clist_set_text(list, n, 1, xm->instruments[n].name);
-    sprintf(buf, "%d", st_instrument_num_samples(&xm->instruments[n]));
-    gtk_clist_set_text(list, n, 2, buf);
+    if(!gui_list_get_iter(n, list_store, &iter))
+       return; /* Some bullshit happens :-/ */
+    gtk_list_store_set(list_store, &iter, 1, xm->instruments[n].name,
+		       2, st_instrument_num_samples(&xm->instruments[n]), -1);
 
     if(n == curi) {
 	for(i = 0; i < 16; i++)
@@ -246,9 +248,13 @@
 void
 modinfo_update_sample (int n)
 {
-    GtkCList *list = GTK_CLIST(slist);
+    GtkTreeIter iter;
+    GtkListStore *list_store = GUI_GET_LIST_STORE(slist);
 
-    gtk_clist_set_text(list, n, 1, xm->instruments[curi].samples[n].name);
+    if(!gui_list_get_iter(n, list_store, &iter))
+       return; /* Some bullshit happens :-/ */
+    gtk_list_store_set(list_store, &iter, 1,
+		       xm->instruments[curi].samples[n].name, -1);
 }
 
 void
@@ -274,7 +280,8 @@
 
     g_return_if_fail(n >= 0 && n <= 127);
     curi = n;
-    gtk_clist_select_row(GTK_CLIST(ilist), n, 1);
+    gui_list_select(ilist, n);
+
     for(i = 0; i < 16; i++)
 	modinfo_update_sample(i);
 }
@@ -284,7 +291,7 @@
 {
     g_return_if_fail(n >= 0 && n <= 15);
     curs = n;
-    gtk_clist_select_row(GTK_CLIST(slist), n, 1);
+    gui_list_select(slist, n);
 }
 
 void
@@ -295,7 +302,7 @@
     printf("%d\n", n);
 
     if(n != -1)
-	gui_set_current_pattern(n);
+	gui_set_current_pattern(n, TRUE);
 }
 
 void
@@ -308,7 +315,7 @@
 	gui_play_stop();
 	st_copy_pattern(&xm->patterns[n], &xm->patterns[c]);
 	xm_set_modified(1);
-	gui_set_current_pattern(n);
+	gui_set_current_pattern(n, TRUE);
     }
 }
 
@@ -392,7 +399,7 @@
 	    if(!st_instrument_used_in_song(xm, a + 1)) c++;
     }
 
-    sprintf(infbuf, _("Unused patterns: %d (used: %d)\nUnused instruments: %d (used: %d)\n\nClear unused and reorder playlist?\n"),
+    g_sprintf(infbuf, _("Unused patterns: %d (used: %d)\nUnused instruments: %d (used: %d)\n\nClear unused and reorder playlist?\n"),
 					b, d-b, c, e-c);
 
     gnome_app_ok_cancel_modal(GNOME_APP(mainwindow),
diff -Naur soundtracker-0.6.8/app/playlist.c soundtracker-0.6.8-gtk2/app/playlist.c
--- soundtracker-0.6.8/app/playlist.c	2006-01-15 16:17:50.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/playlist.c	2010-09-23 11:11:35.000000000 +0200
@@ -3,7 +3,7 @@
  * The Real SoundTracker - gtk+ Playlist widget
  *
  * Copyright (C) 1999-2003 Michael Krause
- * Copyright (C) 2003 Yury Aliaev
+ * Copyright (C) 2003, 2005 Yury Aliaev
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -44,6 +44,28 @@
 static guint playlist_signals[LAST_SIGNAL] = { 0 };
 
 static gboolean
+scroll_event (GtkWidget *w, GdkEventScroll *event, Playlist *p)
+{
+    int pos = p->current_position;
+
+    switch(event->direction) {
+    case GDK_SCROLL_UP:
+	pos--;
+	if((pos >= 0) && (pos) < p->length)
+		gtk_adjustment_set_value(GTK_ADJUSTMENT(p->adj_songpos), pos);
+	return TRUE;
+    case GDK_SCROLL_DOWN:
+	pos++;
+	if((pos >= 0) && (pos) < p->length)
+		gtk_adjustment_set_value(GTK_ADJUSTMENT(p->adj_songpos), pos);
+	return TRUE;
+    default:
+	break;
+    }
+    return FALSE;
+}
+
+static gboolean
 label_clicked (GtkWidget *w, GdkEventButton *event, Playlist *p)
 {
     int i;
@@ -423,15 +445,26 @@
 			pos, p->patterns[pos]);
 }
 
+static void
+is_realized(GtkWidget *algn, gpointer data)
+{
+    guint x, y;
+    
+    gtk_widget_realize(algn);
+    x = (algn->allocation).width;
+    y = (algn->allocation).height;
+    gtk_widget_set_size_request(algn, x, y);
+}
+
 GtkWidget *
 playlist_new (void)
 {
     Playlist *p;
-    GtkWidget *box, *thing, *thing1, *vbox, *frame, *box1, *evbox;
+    GtkWidget *box, *thing, *thing1, *vbox, *frame, *box1, *evbox, *al;
     GtkObject *adj;
     gint i;
 
-    p = gtk_type_new(playlist_get_type());
+    p = g_object_new(playlist_get_type(), NULL);
     GTK_BOX(p)->spacing = 2;
     GTK_BOX(p)->homogeneous = FALSE;
 
@@ -451,8 +484,8 @@
 	    evbox = gtk_event_box_new();
 	    gtk_container_add(GTK_CONTAINER(evbox), p->numlabels[i]);
 	    gtk_widget_show(evbox);
-	    gtk_signal_connect(GTK_OBJECT(evbox), "button_press_event",
-			       GTK_SIGNAL_FUNC(label_clicked),
+	    g_signal_connect(evbox, "button_press_event",
+			       G_CALLBACK(label_clicked),
 			       (gpointer)p);
 	    box1 = gtk_hbox_new (FALSE, 0),
 	    gtk_box_pack_start(GTK_BOX(box1), evbox, FALSE, FALSE, 3);
@@ -464,8 +497,8 @@
 	    evbox = gtk_event_box_new();
 	    gtk_container_add(GTK_CONTAINER(evbox), p->patlabels[i]);
 	    gtk_widget_show(evbox);
-	    gtk_signal_connect(GTK_OBJECT(evbox), "button_press_event",
-			       GTK_SIGNAL_FUNC(label_clicked),
+	    g_signal_connect(evbox, "button_press_event",
+			      G_CALLBACK(label_clicked),
 			       (gpointer)p);
 	    box1 = gtk_hbox_new (FALSE, 0),
 	    gtk_box_pack_start(GTK_BOX(box1), evbox, FALSE, FALSE, 0);
@@ -476,7 +509,12 @@
     box1 = gtk_hbox_new(FALSE, 0);
     p->numlabels[2] = gtk_label_new("");
     gtk_widget_show(p->numlabels[2]);
-    gtk_box_pack_start(GTK_BOX(box1), p->numlabels[2], TRUE, TRUE, 0);
+    /* a bit trick to keep label size constant */
+    al = gtk_alignment_new(0.0, 0.5, 0.0, 0.0);
+    gtk_container_add(GTK_CONTAINER(al), p->numlabels[2]);
+    g_signal_connect(al, "realize", G_CALLBACK(is_realized), NULL);
+    gtk_widget_show(al);
+    gtk_box_pack_start(GTK_BOX(box1), al, TRUE, TRUE, 0);
     gtk_widget_show(box1);
 
     /* current pattern */
@@ -484,8 +522,8 @@
     p->spin_songpat = extspinbutton_new(GTK_ADJUSTMENT (adj), 1.0, 0);
     extspinbutton_disable_size_hack(EXTSPINBUTTON(p->spin_songpat));
     gtk_widget_show(p->spin_songpat);
-    gtk_signal_connect(GTK_OBJECT(p->spin_songpat), "changed",
-		    GTK_SIGNAL_FUNC(playlist_songpat_changed),
+    g_signal_connect(p->spin_songpat, "value-changed",
+		    G_CALLBACK(playlist_songpat_changed),
 		    (gpointer)p);
     gtk_box_pack_end(GTK_BOX(box1), p->spin_songpat, TRUE, TRUE, 0);
 
@@ -500,9 +538,12 @@
     evbox = gtk_event_box_new();
     gtk_container_add(GTK_CONTAINER(evbox), thing1);
     gtk_widget_show(evbox);
-    gtk_signal_connect(GTK_OBJECT(evbox), "button_press_event",
-		       GTK_SIGNAL_FUNC(label_clicked),
+    g_signal_connect(evbox, "button_press_event",
+		       G_CALLBACK(label_clicked),
 		       (gpointer)p);
+    g_signal_connect(evbox, "scroll-event",
+			G_CALLBACK(scroll_event),
+			(gpointer)p);
 
     gtk_container_add(GTK_CONTAINER(thing), evbox);
     gtk_widget_show(thing);
@@ -514,8 +555,8 @@
     thing = gtk_vscrollbar_new(GTK_ADJUSTMENT(p->adj_songpos));
     gtk_widget_show(thing);
     gtk_box_pack_start(GTK_BOX(box), thing, FALSE, FALSE, 0);
-    gtk_signal_connect(GTK_OBJECT(p->adj_songpos), "value_changed",
-		    GTK_SIGNAL_FUNC(playlist_songpos_changed),
+    g_signal_connect(p->adj_songpos, "value_changed",
+		    G_CALLBACK(playlist_songpos_changed),
 		    (gpointer)p);
 
     /* buttons */
@@ -526,16 +567,16 @@
     gui_hang_tooltip(thing1, _("Insert pattern that is being edited"));
     gtk_box_pack_start(GTK_BOX(thing), thing1, FALSE, FALSE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing1), "clicked",
-		    GTK_SIGNAL_FUNC(playlist_insert_clicked),
+    g_signal_connect(thing1, "clicked",
+		    G_CALLBACK(playlist_insert_clicked),
 		    (gpointer)p);
 
     thing1 = p->dbutton = gtk_button_new_with_label(_("Delete"));
     gtk_widget_show(thing1);
     gui_hang_tooltip(thing1, _("Remove current playlist entry"));
     gtk_box_pack_start(GTK_BOX(thing), thing1, FALSE, FALSE, 0);
-    gtk_signal_connect(GTK_OBJECT(thing1), "clicked",
-		    GTK_SIGNAL_FUNC(playlist_delete_clicked),
+    g_signal_connect(thing1, "clicked",
+		    G_CALLBACK(playlist_delete_clicked),
 		    (gpointer)p);
 
     add_empty_vbox(thing);
@@ -562,7 +603,7 @@
     gtk_box_pack_start(GTK_BOX(box), thing1, TRUE, TRUE, 0);
     gtk_widget_show(box);
 
-    thing1 = gtk_invisible_new();
+    thing1 = gtk_label_new(NULL);
     gtk_widget_set_usize(thing1, 2, 1);
     gtk_widget_show(thing1);
     gtk_box_pack_start(GTK_BOX(box), thing1, TRUE, TRUE, 0);
@@ -573,15 +614,15 @@
     gtk_widget_show(thing1);
     gui_hang_tooltip(thing1, _("Song length"));
     gtk_box_pack_start(GTK_BOX(box), thing1, TRUE, TRUE, 0);
-    gtk_signal_connect(GTK_OBJECT(thing1), "changed",
-			GTK_SIGNAL_FUNC(playlist_songlength_changed),
+    g_signal_connect(thing1, "value-changed",
+			G_CALLBACK(playlist_songlength_changed),
 			(gpointer)p);
 
     thing1 = gtk_label_new(_("Rstrt"));
     gtk_widget_show(thing1);
     gtk_box_pack_start(GTK_BOX(box), thing1, TRUE, TRUE, 0);
 
-    thing1 = gtk_invisible_new();
+    thing1 = gtk_label_new(NULL);
     gtk_widget_set_usize(thing1, 2, 1);
     gtk_widget_show(thing1);
     gtk_box_pack_start(GTK_BOX(box), thing1, TRUE, TRUE, 0);
@@ -592,8 +633,8 @@
     gtk_widget_show(thing1);
     gui_hang_tooltip(thing1, _("Song restart position"));
     gtk_box_pack_start(GTK_BOX(box), thing1, TRUE, TRUE, 0);
-    gtk_signal_connect(GTK_OBJECT(thing1), "changed",
-			GTK_SIGNAL_FUNC(playlist_restartpos_changed),
+    g_signal_connect(thing1, "value-changed",
+			G_CALLBACK(playlist_restartpos_changed),
 			(gpointer)p);
 
     gtk_box_pack_start(GTK_BOX(vbox), box, FALSE, FALSE, 0);
@@ -608,42 +649,40 @@
 static void
 playlist_class_init (PlaylistClass *class)
 {
-    GtkObjectClass *object_class;
+    GObjectClass *g_object_class;
 
-    object_class = (GtkObjectClass*) class;
+    g_object_class = (GObjectClass*) class;
 
-    playlist_signals[SIG_CURRENT_POSITION_CHANGED] = gtk_signal_new ("current_position_changed",
-								     GTK_RUN_FIRST,
-								     object_class->type,
-								     GTK_SIGNAL_OFFSET(PlaylistClass, current_position_changed),
-								     gtk_marshal_NONE__INT,
-								     GTK_TYPE_NONE, 1,
-								     GTK_TYPE_INT);
-    playlist_signals[SIG_RESTART_POSITION_CHANGED] = gtk_signal_new ("restart_position_changed",
-								     GTK_RUN_FIRST,
-								     object_class->type,
-								     GTK_SIGNAL_OFFSET(PlaylistClass, restart_position_changed),
-								     gtk_marshal_NONE__INT,
-								     GTK_TYPE_NONE, 1,
-								     GTK_TYPE_INT);
-    playlist_signals[SIG_SONG_LENGTH_CHANGED] = gtk_signal_new ("song_length_changed",
-								GTK_RUN_FIRST,
-								object_class->type,
-								GTK_SIGNAL_OFFSET(PlaylistClass, song_length_changed),
-								gtk_marshal_NONE__INT,
-								GTK_TYPE_NONE, 1,
-								GTK_TYPE_INT);
-    playlist_signals[SIG_ENTRY_CHANGED] = gtk_signal_new ("entry_changed",
-							  GTK_RUN_FIRST,
-							  object_class->type,
-							  GTK_SIGNAL_OFFSET(PlaylistClass, entry_changed),
-							  gtk_marshal_NONE__INT_INT,
-							  GTK_TYPE_NONE, 2,
-							  GTK_TYPE_INT,
-							  GTK_TYPE_INT);
+    playlist_signals[SIG_CURRENT_POSITION_CHANGED] =
+	   g_signal_new ("current_position_changed",
+			   G_TYPE_FROM_CLASS (g_object_class),
+			   (GSignalFlags)G_SIGNAL_RUN_FIRST,
+   			   G_STRUCT_OFFSET(PlaylistClass, current_position_changed),
+			   NULL, NULL,
+			   gtk_marshal_NONE__INT, G_TYPE_NONE, 1, G_TYPE_INT);
+    playlist_signals[SIG_RESTART_POSITION_CHANGED] =
+	    g_signal_new ("restart_position_changed",
+			   G_TYPE_FROM_CLASS (g_object_class),
+			   (GSignalFlags)G_SIGNAL_RUN_FIRST,
+			   G_STRUCT_OFFSET(PlaylistClass, restart_position_changed),
+			   NULL, NULL,
+			   gtk_marshal_NONE__INT, G_TYPE_NONE, 1, G_TYPE_INT);
+    playlist_signals[SIG_SONG_LENGTH_CHANGED] =
+	    g_signal_new ("song_length_changed",
+			   G_TYPE_FROM_CLASS (g_object_class),
+			   (GSignalFlags)G_SIGNAL_RUN_FIRST,
+			G_STRUCT_OFFSET(PlaylistClass, song_length_changed),
+			   NULL, NULL,
+			gtk_marshal_NONE__INT, G_TYPE_NONE, 1, G_TYPE_INT);
+    playlist_signals[SIG_ENTRY_CHANGED] =
+	    g_signal_new ("entry_changed",
+			   G_TYPE_FROM_CLASS (g_object_class),
+			   (GSignalFlags)G_SIGNAL_RUN_FIRST,
+			G_STRUCT_OFFSET(PlaylistClass, entry_changed),
+			   NULL, NULL,
+			gtk_marshal_NONE__INT_INT, G_TYPE_NONE, 2,
+			G_TYPE_INT, G_TYPE_INT);
 
-    gtk_object_class_add_signals(object_class, playlist_signals, LAST_SIGNAL);
-    
     class->current_position_changed = NULL;
     class->restart_position_changed = NULL;
     class->song_length_changed = NULL;
@@ -674,18 +713,21 @@
     static guint playlist_type = 0;
     
     if (!playlist_type) {
-	GtkTypeInfo playlist_info =
+	GTypeInfo playlist_info =
 	{
-	    "Playlist",
-	    sizeof(Playlist),
 	    sizeof(PlaylistClass),
-	    (GtkClassInitFunc) playlist_class_init,
-	    (GtkObjectInitFunc) playlist_init,
-	    (GtkArgSetFunc) NULL,
-	    (GtkArgGetFunc) NULL,
+	    (GBaseInitFunc) NULL,
+		(GBaseFinalizeFunc) NULL,
+	    (GClassInitFunc) playlist_class_init,
+	    (GClassFinalizeFunc) NULL,
+	    NULL,
+	    sizeof(Playlist),
+	    0,
+	    (GInstanceInitFunc) playlist_init,
 	};
 	
-	playlist_type = gtk_type_unique (gtk_vbox_get_type (), &playlist_info);
+	playlist_type = g_type_register_static(gtk_vbox_get_type (),
+	    "Playlist", &playlist_info, (GTypeFlags)0);
     }
 
     return playlist_type;
diff -Naur soundtracker-0.6.8/app/playlist.h soundtracker-0.6.8-gtk2/app/playlist.h
--- soundtracker-0.6.8/app/playlist.h	2003-08-04 10:45:27.000000000 +0200
+++ soundtracker-0.6.8-gtk2/app/playlist.h	2010-09-23 11:11:35.000000000 +0200
@@ -3,7 +3,7 @@
  * The Real SoundTracker - gtk+ Playlist widget (header)
  *
  * Copyright (C) 1999-2001 Michael Krause
- * Copyright (C) 2003 Yury Aliaev
+ * Copyright (C) 2003, 2005 Yury Aliaev
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff -Naur soundtracker-0.6.8/app/preferences.c soundtracker-0.6.8-gtk2/app/preferences.c
--- soundtracker-0.6.8/app/preferences.c	2002-02-09 16:59:52.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/preferences.c	2010-09-23 11:11:35.000000000 +0200
@@ -36,6 +36,7 @@
 #include <sys/types.h>
 
 #include <glib.h>
+#include <gdk/gdkcolor.h>
 
 #include "i18n.h"
 #include "gui-subs.h"
@@ -180,6 +181,39 @@
 }
 
 gboolean
+prefs_get_str_array (prefs_node *pn,
+		     const gchar *key,
+		     gboolean (* action_func)(gchar *string, gpointer data),
+		     gpointer data)
+{
+    FILE *f;
+    gboolean stop_condition = FALSE;
+    gchar readbuf[1024], *p, *dest, *end;
+
+    if(pn->writemode)
+	return FALSE;
+    f = pn->file;
+    fseek(f, 0, SEEK_SET);
+
+    while(!feof(f) && !stop_condition) {
+	fgets(readbuf, 1024, f);
+	p = strchr(readbuf, '=');
+	if(!p || p == readbuf || p[1] == 0) {
+	    return FALSE;
+	}
+	p[-1] = 0;
+	if(!g_ascii_strcasecmp(readbuf, key)) {
+	    end = strchr(p + 2, '\n');
+	    end[0] = 0;
+	    dest = g_strdup(p + 2);
+	    stop_condition = (* action_func)(dest, data);
+	}    
+    }
+
+    return TRUE;    
+}
+
+gboolean
 prefs_get_int (prefs_node *pn,
 	       const char *key,
 	       int *dest)
@@ -201,6 +235,32 @@
 }
 
 gboolean
+prefs_get_color (prefs_node *pn,
+	         const char *key,
+	         GdkColor *dest)
+{
+    char buf[21];
+    FILE *f;
+    gchar **components;
+
+    if(pn->writemode)
+	return FALSE;
+    f = pn->file;
+
+    if(prefs_get_line(f, key, buf, 20)) {
+	buf[20] = 0;
+	components = g_strsplit(buf, " ", 3);
+	dest->red = atoi(components[0]);
+	dest->green = atoi(components[1]);
+	dest->blue = atoi(components[2]);
+	g_strfreev(components);
+	return TRUE;
+    }
+
+    return FALSE;
+}
+
+gboolean
 prefs_get_string (prefs_node *pn,
 		  const char *key,
 		  char *dest)
@@ -236,6 +296,20 @@
 }
 
 void
+prefs_put_color (prefs_node *pn,
+	         const char *key,
+	         GdkColor value)
+{
+    FILE *f;
+
+    if(!pn->writemode)
+	return;
+    f = pn->file;
+
+    fprintf(f, "%s = %d %d %d\n", key, value.red, value.green, value.blue);
+}
+
+void
 prefs_put_string (prefs_node *pn,
 		  const char *key,
 		  const char *value)
diff -Naur soundtracker-0.6.8/app/preferences.h soundtracker-0.6.8-gtk2/app/preferences.h
--- soundtracker-0.6.8/app/preferences.h	2002-02-09 16:59:52.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/preferences.h	2010-09-23 11:11:35.000000000 +0200
@@ -50,14 +50,24 @@
 void           prefs_put_int                  (prefs_node *f,
 					       const char *key,
 					       int value);
+void           prefs_put_color                (prefs_node *f,
+					       const char *key,
+					       GdkColor value);
 void           prefs_put_string               (prefs_node *f,
 					       const char *key,
 					       const char *value);
 gboolean       prefs_get_int                  (prefs_node *f,
 					       const char *key,
 					       int *dest);
+gboolean       prefs_get_color                (prefs_node *f,
+					       const char *key,
+					       GdkColor *dest);
 gboolean       prefs_get_string               (prefs_node *f,
 					       const char *key,
 					       char *dest);
+gboolean       prefs_get_str_array	      (prefs_node *pn,
+					       const gchar *key,
+					       gboolean (* action_func)(gchar *string, gpointer data),
+					       gpointer data);
 
 #endif /* _ST_PREFERENCES_H */
diff -Naur soundtracker-0.6.8/app/sample-display.c soundtracker-0.6.8-gtk2/app/sample-display.c
--- soundtracker-0.6.8/app/sample-display.c	2002-07-18 19:11:37.000000000 +0200
+++ soundtracker-0.6.8-gtk2/app/sample-display.c	2010-09-23 11:11:35.000000000 +0200
@@ -3,6 +3,7 @@
  * The Real SoundTracker - GTK+ sample display widget
  *
  * Copyright (C) 1998-2001 Michael Krause
+ * Copytight (C) 2006 Yury Aliaev (Gtk+-2 porting)
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -298,14 +299,19 @@
     s->bg_gc = gdk_gc_new(widget->window);
     s->fg_gc = gdk_gc_new(widget->window);
     s->zeroline_gc = gdk_gc_new(widget->window);
-    gdk_gc_set_foreground(s->bg_gc, &SAMPLE_DISPLAY_CLASS(GTK_OBJECT(widget)->klass)->colors[SAMPLE_DISPLAYCOL_BG]);
-    gdk_gc_set_foreground(s->fg_gc, &SAMPLE_DISPLAY_CLASS(GTK_OBJECT(widget)->klass)->colors[SAMPLE_DISPLAYCOL_FG]);
-    gdk_gc_set_foreground(s->zeroline_gc, &SAMPLE_DISPLAY_CLASS(GTK_OBJECT(widget)->klass)->colors[SAMPLE_DISPLAYCOL_ZERO]);
+    gdk_gc_set_foreground(s->bg_gc, &SAMPLE_DISPLAY_GET_CLASS(
+			    SAMPLE_DISPLAY(widget))->colors[SAMPLE_DISPLAYCOL_BG]);
+    gdk_gc_set_foreground(s->fg_gc, &SAMPLE_DISPLAY_GET_CLASS(
+			   SAMPLE_DISPLAY (widget))->colors[SAMPLE_DISPLAYCOL_FG]);
+    gdk_gc_set_foreground(s->zeroline_gc, &SAMPLE_DISPLAY_GET_CLASS(
+			    SAMPLE_DISPLAY(widget))->colors[SAMPLE_DISPLAYCOL_ZERO]);
     if(s->edit) {
 	s->loop_gc = gdk_gc_new(widget->window);
 	s->mixerpos_gc = gdk_gc_new(widget->window);
-	gdk_gc_set_foreground(s->loop_gc, &SAMPLE_DISPLAY_CLASS(GTK_OBJECT(widget)->klass)->colors[SAMPLE_DISPLAYCOL_LOOP]);
-	gdk_gc_set_foreground(s->mixerpos_gc, &SAMPLE_DISPLAY_CLASS(GTK_OBJECT(widget)->klass)->colors[SAMPLE_DISPLAYCOL_MIXERPOS]);
+	gdk_gc_set_foreground(s->loop_gc, &SAMPLE_DISPLAY_GET_CLASS(
+				SAMPLE_DISPLAY(widget))->colors[SAMPLE_DISPLAYCOL_LOOP]);
+	gdk_gc_set_foreground(s->mixerpos_gc, &SAMPLE_DISPLAY_GET_CLASS(
+				SAMPLE_DISPLAY(widget))->colors[SAMPLE_DISPLAYCOL_MIXERPOS]);
     }
 
     sample_display_init_display(s, attributes.width, attributes.height);
@@ -567,13 +573,6 @@
     }
 }
 
-static void
-sample_display_draw (GtkWidget *widget,
-		     GdkRectangle *area)
-{
-    sample_display_draw_main(widget, area);
-}
-
 static gint
 sample_display_expose (GtkWidget *widget,
 		       GdkEventExpose *event)
@@ -824,51 +823,51 @@
 static void
 sample_display_class_init (SampleDisplayClass *class)
 {
-    GtkObjectClass *object_class;
+    GObjectClass *object_class;
     GtkWidgetClass *widget_class;
     int n;
     const int *p;
     GdkColor *c;
 
-    object_class = (GtkObjectClass*) class;
+    object_class = (GObjectClass*) class;
     widget_class = (GtkWidgetClass*) class;
 
     widget_class->realize = sample_display_realize;
     widget_class->size_allocate = sample_display_size_allocate;
     widget_class->expose_event = sample_display_expose;
-    widget_class->draw = sample_display_draw;
     widget_class->size_request = sample_display_size_request;
     widget_class->button_press_event = sample_display_button_press;
     widget_class->button_release_event = sample_display_button_release;
     widget_class->motion_notify_event = sample_display_motion_notify;
 
-    sample_display_signals[SIG_SELECTION_CHANGED] = gtk_signal_new ("selection_changed",
-							     GTK_RUN_FIRST,
-							     object_class->type,
-							     GTK_SIGNAL_OFFSET(SampleDisplayClass, selection_changed),
-							     gtk_marshal_NONE__INT_INT,
-							     GTK_TYPE_NONE, 2,
-							     GTK_TYPE_INT,
-							     GTK_TYPE_INT);
-    sample_display_signals[SIG_LOOP_CHANGED] = gtk_signal_new ("loop_changed",
-							GTK_RUN_FIRST,
-							object_class->type,
-							GTK_SIGNAL_OFFSET(SampleDisplayClass, loop_changed),
-							gtk_marshal_NONE__INT_INT,
-							GTK_TYPE_NONE, 2,
-							GTK_TYPE_INT,
-							GTK_TYPE_INT);
-    sample_display_signals[SIG_WINDOW_CHANGED] = gtk_signal_new ("window_changed",
-								 GTK_RUN_FIRST,
-								 object_class->type,
-								 GTK_SIGNAL_OFFSET(SampleDisplayClass, window_changed),
-								 gtk_marshal_NONE__INT_INT,
-								 GTK_TYPE_NONE, 2,
-								 GTK_TYPE_INT,
-								 GTK_TYPE_INT);
+    sample_display_signals[SIG_SELECTION_CHANGED] =
+	    g_signal_new ("selection_changed",
+			G_TYPE_FROM_CLASS (object_class),
+			(GSignalFlags)G_SIGNAL_RUN_FIRST,
+			G_STRUCT_OFFSET(SampleDisplayClass, selection_changed),
+			NULL, NULL,
+			gtk_marshal_NONE__INT_INT,
+			G_TYPE_NONE, 2,
+			G_TYPE_INT, G_TYPE_INT);
+    sample_display_signals[SIG_LOOP_CHANGED] =
+	    g_signal_new ("loop_changed",
+			G_TYPE_FROM_CLASS (object_class),
+			(GSignalFlags)G_SIGNAL_RUN_FIRST,
+			G_STRUCT_OFFSET(SampleDisplayClass, loop_changed),
+			NULL, NULL,
+			gtk_marshal_NONE__INT_INT,
+			G_TYPE_NONE, 2,
+			G_TYPE_INT, G_TYPE_INT);
+    sample_display_signals[SIG_WINDOW_CHANGED] =
+	    g_signal_new ("window_changed",
+			G_TYPE_FROM_CLASS (object_class),
+			(GSignalFlags)G_SIGNAL_RUN_FIRST,
+			 G_STRUCT_OFFSET(SampleDisplayClass, window_changed),
+			 NULL, NULL,
+			 gtk_marshal_NONE__INT_INT,
+			 G_TYPE_NONE, 2,
+			 G_TYPE_INT, G_TYPE_INT);
 
-    gtk_object_class_add_signals(object_class, sample_display_signals, LAST_SIGNAL);
-    
     class->selection_changed = NULL;
     class->loop_changed = NULL;
     class->window_changed = NULL;
@@ -894,18 +893,22 @@
     static guint sample_display_type = 0;
 
     if (!sample_display_type) {
-	GtkTypeInfo sample_display_info =
+	GTypeInfo sample_display_info =
 	{
-	    "SampleDisplay",
-	    sizeof(SampleDisplay),
 	    sizeof(SampleDisplayClass),
-	    (GtkClassInitFunc) sample_display_class_init,
-	    (GtkObjectInitFunc) sample_display_init,
-	    (GtkArgSetFunc) NULL,
-	    (GtkArgGetFunc) NULL,
+	    	(GBaseInitFunc) NULL,
+		(GBaseFinalizeFunc) NULL,
+	    (GClassInitFunc) sample_display_class_init,
+	    (GClassFinalizeFunc) NULL,
+	    NULL,
+	    sizeof(SampleDisplay),
+	    0,
+	    (GInstanceInitFunc) sample_display_init,
+	    
 	};
 
-	sample_display_type = gtk_type_unique (gtk_widget_get_type (), &sample_display_info);
+	sample_display_type = g_type_register_static(gtk_widget_get_type (),
+	    "SampleDisplay", &sample_display_info, (GTypeFlags)0);
     }
 
     return sample_display_type;
@@ -914,7 +917,7 @@
 GtkWidget*
 sample_display_new (gboolean edit)
 {
-    SampleDisplay *s = SAMPLE_DISPLAY(gtk_type_new(sample_display_get_type()));
+    SampleDisplay *s = SAMPLE_DISPLAY(g_object_new(sample_display_get_type(), NULL));
 
     s->edit = edit;
     s->datacopy = 0;
diff -Naur soundtracker-0.6.8/app/sample-display.h soundtracker-0.6.8-gtk2/app/sample-display.h
--- soundtracker-0.6.8/app/sample-display.h	2001-01-03 14:24:10.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/sample-display.h	2010-09-23 11:11:35.000000000 +0200
@@ -28,6 +28,7 @@
 #define SAMPLE_DISPLAY(obj)          GTK_CHECK_CAST (obj, sample_display_get_type (), SampleDisplay)
 #define SAMPLE_DISPLAY_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, sample_display_get_type (), SampleDisplayClass)
 #define IS_SAMPLE_DISPLAY(obj)       GTK_CHECK_TYPE (obj, sample_display_get_type ())
+#define SAMPLE_DISPLAY_GET_CLASS(obj)	G_TYPE_INSTANCE_GET_CLASS((obj), sample_display_get_type(), SampleDisplayClass)
 
 typedef struct _SampleDisplay       SampleDisplay;
 typedef struct _SampleDisplayClass  SampleDisplayClass;
diff -Naur soundtracker-0.6.8/app/sample-editor.c soundtracker-0.6.8-gtk2/app/sample-editor.c
--- soundtracker-0.6.8/app/sample-editor.c	2006-02-25 13:26:05.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/sample-editor.c	2010-09-23 11:11:35.000000000 +0200
@@ -38,6 +38,7 @@
 #endif
 
 #include <glib.h>
+#include <glib/gprintf.h>
 #include <gtk/gtk.h>
 #ifdef USE_GNOME
 #include <gnome.h>
@@ -250,12 +251,12 @@
     thing = sample_display_new(TRUE);
     gtk_box_pack_start(GTK_BOX(box), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "loop_changed",
-		       GTK_SIGNAL_FUNC(sample_editor_display_loop_changed), NULL);
-    gtk_signal_connect(GTK_OBJECT(thing), "selection_changed",
-		       GTK_SIGNAL_FUNC(sample_editor_display_selection_changed), NULL);
-    gtk_signal_connect(GTK_OBJECT(thing), "window_changed",
-		       GTK_SIGNAL_FUNC(sample_editor_display_window_changed), NULL);
+    g_signal_connect(thing, "loop_changed",
+		       G_CALLBACK(sample_editor_display_loop_changed), NULL);
+    g_signal_connect(thing, "selection_changed",
+		       G_CALLBACK(sample_editor_display_selection_changed), NULL);
+    g_signal_connect(thing, "window_changed",
+		       G_CALLBACK(sample_editor_display_window_changed), NULL);
     sampledisplay = SAMPLE_DISPLAY(thing);
     sample_display_enable_zero_line(SAMPLE_DISPLAY(thing), TRUE);
 
@@ -311,14 +312,14 @@
     gtk_box_pack_start(GTK_BOX(box2), thing, FALSE, TRUE, 0);
 
     thing = gtk_button_new_with_label(_("None"));
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(sample_editor_select_none_clicked), NULL);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(sample_editor_select_none_clicked), NULL);
     gtk_box_pack_start(GTK_BOX(box2), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
 
     thing = gtk_button_new_with_label(_("All"));
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(sample_editor_select_all_clicked), NULL);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(sample_editor_select_all_clicked), NULL);
     gtk_box_pack_start(GTK_BOX(box2), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
 
@@ -354,8 +355,8 @@
     add_empty_vbox(vbox);
 
     thing = gtk_button_new_with_label(_("Set as loop"));
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC( sample_editor_selection_to_loop_clicked), NULL);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(sample_editor_selection_to_loop_clicked), NULL);
     gtk_box_pack_start(GTK_BOX(vbox), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
 
@@ -381,8 +382,8 @@
 #endif
 
     thing = gtk_button_new_with_label(_("Load Sample"));
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(fileops_open_dialog), (void*)DIALOG_LOAD_SAMPLE);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(fileops_open_dialog), (void*)DIALOG_LOAD_SAMPLE);
     gtk_box_pack_start(GTK_BOX(vbox), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
 #if USE_SNDFILE == 0 && defined (NO_AUDIOFILE)
@@ -390,8 +391,8 @@
 #endif
 
     thing = gtk_button_new_with_label(_("Save WAV"));
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(fileops_open_dialog), (void*)DIALOG_SAVE_SAMPLE);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(fileops_open_dialog), (void*)DIALOG_SAVE_SAMPLE);
     gtk_box_pack_start(GTK_BOX(vbox), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
     savebutton = thing;
@@ -400,8 +401,8 @@
 #endif
 
     thing = gtk_button_new_with_label(_("Save Region"));
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(fileops_open_dialog), (void*)DIALOG_SAVE_RGN_SAMPLE);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(fileops_open_dialog), (void*)DIALOG_SAVE_RGN_SAMPLE);
     gtk_box_pack_start(GTK_BOX(vbox), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
     savebutton_rgn = thing;
@@ -411,20 +412,20 @@
 
     
     thing = gtk_button_new_with_label(_("Monitor"));
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(sample_editor_monitor_clicked), NULL);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(sample_editor_monitor_clicked), NULL);
     gtk_box_pack_start(GTK_BOX(vbox), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
 
     thing = gtk_button_new_with_label(_("Volume Ramp"));
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(sample_editor_open_volume_ramp_dialog), NULL);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(sample_editor_open_volume_ramp_dialog), NULL);
     gtk_box_pack_start(GTK_BOX(vbox), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
 
     thing = gtk_button_new_with_label(_("Trim"));
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(sample_editor_trim_dialog), NULL);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(sample_editor_trim_dialog), NULL);
     gtk_box_pack_start(GTK_BOX(vbox), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
 
@@ -434,32 +435,32 @@
     gtk_box_pack_start(GTK_BOX(hbox), vbox, TRUE, TRUE, 0);
 
     thing = gtk_button_new_with_label(_("Zoom to selection"));
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(sample_editor_zoom_to_selection_clicked), NULL);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(sample_editor_zoom_to_selection_clicked), NULL);
     gtk_box_pack_start(GTK_BOX(vbox), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
 
     thing = gtk_button_new_with_label(_("Show all"));
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(sample_editor_show_all_clicked), NULL);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(sample_editor_show_all_clicked), NULL);
     gtk_box_pack_start(GTK_BOX(vbox), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
 
     thing = gtk_button_new_with_label(_("Zoom in (+50%)"));
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(sample_editor_zoom_in_clicked), NULL);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(sample_editor_zoom_in_clicked), NULL);
     gtk_box_pack_start(GTK_BOX(vbox), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
 
     thing = gtk_button_new_with_label(_("Zoom out (-50%)"));
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(sample_editor_zoom_out_clicked), NULL);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(sample_editor_zoom_out_clicked), NULL);
     gtk_box_pack_start(GTK_BOX(vbox), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
 
     thing = gtk_button_new_with_label(_("Reverse"));
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(sample_editor_reverse_clicked), NULL);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(sample_editor_reverse_clicked), NULL);
     gtk_box_pack_start(GTK_BOX(vbox), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
 
@@ -468,38 +469,38 @@
     gtk_box_pack_start(GTK_BOX(hbox), vbox, TRUE, TRUE, 0);
 
     thing = gtk_button_new_with_label(_("Cut"));
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(sample_editor_cut_clicked), NULL);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(sample_editor_cut_clicked), NULL);
     gtk_box_pack_start(GTK_BOX(vbox), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
 
     thing = gtk_button_new_with_label(_("Remove"));
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(sample_editor_remove_clicked), NULL);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(sample_editor_remove_clicked), NULL);
     gtk_box_pack_start(GTK_BOX(vbox), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
 
     thing = gtk_button_new_with_label(_("Copy"));
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(sample_editor_copy_clicked), NULL);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(sample_editor_copy_clicked), NULL);
     gtk_box_pack_start(GTK_BOX(vbox), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
 
     thing = gtk_button_new_with_label(_("Paste"));
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(sample_editor_paste_clicked), NULL);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(sample_editor_paste_clicked), NULL);
     gtk_box_pack_start(GTK_BOX(vbox), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
 
     thing = gtk_button_new_with_label(_("Clear Sample"));
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(sample_editor_clear_clicked), NULL);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(sample_editor_clear_clicked), NULL);
     gtk_box_pack_start(GTK_BOX(vbox), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
 
     thing = gtk_button_new_with_label(_("Crop"));
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(sample_editor_crop_clicked), NULL);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(sample_editor_crop_clicked), NULL);
     gtk_box_pack_start(GTK_BOX(vbox), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
 
@@ -523,12 +524,17 @@
 static void
 sample_editor_block_loop_spins (int block)
 {
-    void (*func) (GtkObject*, GtkSignalFunc, gpointer);
-
-    func = block ? gtk_signal_handler_block_by_func : gtk_signal_handler_unblock_by_func;
-
-    func(GTK_OBJECT(spin_loopstart), sample_editor_loop_changed, NULL);
-    func(GTK_OBJECT(spin_loopend), sample_editor_loop_changed, NULL);
+	if(block){
+		g_signal_handlers_block_by_func(G_OBJECT(spin_loopstart),
+				sample_editor_loop_changed, NULL);
+		g_signal_handlers_block_by_func(G_OBJECT(spin_loopend),
+				sample_editor_loop_changed, NULL);
+	} else {
+		g_signal_handlers_unblock_by_func(G_OBJECT(spin_loopstart),
+				sample_editor_loop_changed, NULL);
+		g_signal_handlers_unblock_by_func(G_OBJECT(spin_loopend),
+				sample_editor_loop_changed, NULL);
+	}
 }
 
 static void
@@ -558,11 +564,11 @@
     STSample *sts = current_sample;
 
     if(start > -1) {
-	sprintf(se->label_selection_new_text, ("%d - %d"), start, end);
-	sprintf(se->label_length_new_text, ("%d"), end-start);
+	g_sprintf(se->label_selection_new_text, ("%d - %d"), start, end);
+	g_sprintf(se->label_length_new_text, ("%d"), end-start);
     } else {
 	strcpy(se->label_selection_new_text, _("(no selection)"));
-	sprintf(se->label_length_new_text, ("%d"), sts->sample.length);
+	g_sprintf(se->label_length_new_text, ("%d"), sts->sample.length);
     }
 
     /* Somewhere on the way to gtk+-1.2.10, gtk_label_set_text() has
@@ -622,7 +628,7 @@
 
     s = &sts->sample;
 
-    sprintf(buf, ("%d"), s->length);
+    g_sprintf(buf, ("%d"), s->length);
     gtk_label_set(GTK_LABEL(se->label_length), buf);
 
     sample_editor_block_loop_spins(1);
@@ -1465,12 +1471,12 @@
     GtkWidget *separator;
     GtkWidget *label;
          
-    window = gtk_window_new (GTK_WINDOW_DIALOG);
+    window = gtk_dialog_new ();
    
     wavload_dialog=window;
 
-    gtk_signal_connect (GTK_OBJECT (window), "delete_event",
-			GTK_SIGNAL_FUNC (sample_editor_wavload_dialog_hide), NULL); 
+    g_signal_connect(window, "delete_event",
+			G_CALLBACK(sample_editor_wavload_dialog_hide), NULL); 
 
     gtk_window_set_position (GTK_WINDOW(window), GTK_WIN_POS_CENTER);
     gtk_window_set_title (GTK_WINDOW(window), _("Load stereo sample"));
@@ -1493,20 +1499,20 @@
     box2 = gtk_hbox_new(TRUE, 4);
     
     button = gtk_button_new_with_label (_("Left"));
-    gtk_signal_connect (GTK_OBJECT (button), "clicked", 
-			GTK_SIGNAL_FUNC (sample_editor_wavload_dialog_left), NULL);
+    g_signal_connect(button, "clicked", 
+			G_CALLBACK(sample_editor_wavload_dialog_left), NULL);
     gtk_box_pack_start (GTK_BOX (box2), button, TRUE, TRUE, 0);
     gtk_widget_show (button);
  
     button = gtk_button_new_with_label (_("Mix"));
-    gtk_signal_connect (GTK_OBJECT (button), "clicked", 
-			GTK_SIGNAL_FUNC (sample_editor_wavload_dialog_mix), NULL);
+    g_signal_connect(button, "clicked", 
+			G_CALLBACK(sample_editor_wavload_dialog_mix), NULL);
     gtk_box_pack_start (GTK_BOX (box2), button, TRUE, TRUE, 0);
     gtk_widget_show (button);
  
     button = gtk_button_new_with_label (_("Right"));
-    gtk_signal_connect (GTK_OBJECT (button), "clicked", 
-			GTK_SIGNAL_FUNC (sample_editor_wavload_dialog_right), NULL);
+    g_signal_connect(button, "clicked", 
+			G_CALLBACK(sample_editor_wavload_dialog_right), NULL);
     gtk_box_pack_start (GTK_BOX (box2), button, TRUE, TRUE, 0);
     gtk_widget_show (button);
 
@@ -1518,8 +1524,8 @@
     gtk_widget_show (separator);
      
     button = gtk_button_new_with_label (_("Cancel"));
-    gtk_signal_connect (GTK_OBJECT (button), "clicked", 
-			GTK_SIGNAL_FUNC (sample_editor_wavload_dialog_hide), NULL);   
+    g_signal_connect(button, "clicked", 
+			G_CALLBACK(sample_editor_wavload_dialog_hide), NULL);   
     gtk_box_pack_start (GTK_BOX (box1), button, FALSE, FALSE, 0);
     gtk_widget_show (button);
     
@@ -1578,12 +1584,12 @@
 
     wavload_filename = filename; // store for later usage
 
-    window = gtk_window_new (GTK_WINDOW_DIALOG);
+    window = gtk_dialog_new ();
    
     wavload_dialog = window;
 
-    gtk_signal_connect (GTK_OBJECT (window), "delete_event",
-			GTK_SIGNAL_FUNC (sample_editor_raw_sample_dialog_hide), NULL); 
+    g_signal_connect(window, "delete_event",
+			G_CALLBACK(sample_editor_raw_sample_dialog_hide), NULL); 
 
     gtk_window_set_position (GTK_WINDOW(window), GTK_WIN_POS_CENTER);
     gtk_window_set_title (GTK_WINDOW(window), _("Load raw sample"));
@@ -1687,14 +1693,14 @@
     gtk_widget_show (separator);
      
     button = gtk_button_new_with_label (_("OK"));
-    gtk_signal_connect (GTK_OBJECT (button), "clicked", 
-			GTK_SIGNAL_FUNC (sample_editor_raw_sample_dialog_ok), NULL);
+    g_signal_connect(button, "clicked", 
+			G_CALLBACK(sample_editor_raw_sample_dialog_ok), NULL);
     gtk_box_pack_start (GTK_BOX (box1), button, FALSE, FALSE, 0);
     gtk_widget_show (button);
     
     button = gtk_button_new_with_label (_("Cancel"));
-    gtk_signal_connect (GTK_OBJECT (button), "clicked", 
-			GTK_SIGNAL_FUNC (sample_editor_raw_sample_dialog_hide), NULL);
+    g_signal_connect(button, "clicked", 
+			G_CALLBACK(sample_editor_raw_sample_dialog_hide), NULL);
     gtk_box_pack_start (GTK_BOX (box1), button, FALSE, FALSE, 0);
     gtk_widget_show (button);
     
@@ -1707,7 +1713,8 @@
 static void
 sample_editor_load_wav (void)
 {
-    const gchar *fn = gtk_file_selection_get_filename(GTK_FILE_SELECTION(fileops_dialogs[DIALOG_LOAD_SAMPLE]));
+    gchar *fn = gtk_file_selection_get_filename(GTK_FILE_SELECTION(fileops_dialogs[DIALOG_LOAD_SAMPLE]));
+
 #if USE_SNDFILE != 1
     int sampleFormat;
 #endif
@@ -2002,23 +2009,23 @@
     gtk_widget_show(box2);
 
     thing = gtk_button_new_with_label(_("OK"));
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(sample_editor_ok_clicked), NULL);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(sample_editor_ok_clicked), NULL);
     gtk_box_pack_start(GTK_BOX(box2), thing, TRUE, TRUE, 0);
     gtk_widget_set_sensitive(thing, 0);
     gtk_widget_show(thing);
     okbutton = thing;
 
     thing = gtk_button_new_with_label(_("Start sampling"));
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(sample_editor_start_sampling_clicked), NULL);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(sample_editor_start_sampling_clicked), NULL);
     gtk_box_pack_start(GTK_BOX(box2), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
     startsamplingbutton = thing;
 
     thing = gtk_button_new_with_label(_("Cancel"));
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(sample_editor_stop_sampling), NULL);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(sample_editor_stop_sampling), NULL);
     gtk_box_pack_start(GTK_BOX(box2), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
     cancelbutton = thing;
@@ -2054,8 +2061,8 @@
     samplingwindow = gtk_window_new(GTK_WINDOW_TOPLEVEL);
     gtk_window_set_title(GTK_WINDOW(samplingwindow), _("Sampling Window"));
 #endif
-    gtk_signal_connect (GTK_OBJECT (samplingwindow), "delete_event",
-			GTK_SIGNAL_FUNC (sample_editor_stop_sampling), NULL);
+    g_signal_connect(samplingwindow, "delete_event",
+			G_CALLBACK(sample_editor_stop_sampling), NULL);
 
     mainbox = gtk_vbox_new(FALSE, 2);
     gtk_container_border_width(GTK_CONTAINER(mainbox), 4);
@@ -2252,8 +2259,8 @@
     volrampwindow = gtk_window_new(GTK_WINDOW_TOPLEVEL);
     gtk_window_set_title(GTK_WINDOW(volrampwindow), _("Volume Ramping"));
 #endif
-    gtk_signal_connect (GTK_OBJECT (volrampwindow), "delete_event",
-			GTK_SIGNAL_FUNC (sample_editor_close_volume_ramp_dialog), NULL);
+    g_signal_connect(volrampwindow, "delete_event",
+			G_CALLBACK(sample_editor_close_volume_ramp_dialog), NULL);
 
     gtk_window_set_transient_for(GTK_WINDOW(volrampwindow), GTK_WINDOW(mainwindow));
 
@@ -2284,14 +2291,14 @@
     thing = gtk_button_new_with_label(_("H"));
     gtk_widget_show(thing);
     gtk_box_pack_start(GTK_BOX(box1), thing, FALSE, TRUE, 0);
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-                       GTK_SIGNAL_FUNC(sample_editor_lrvol), (gpointer)0);
+    g_signal_connect(thing, "clicked",
+                       G_CALLBACK(sample_editor_lrvol), (gpointer)0);
 
     thing = gtk_button_new_with_label(_("D"));
     gtk_widget_show(thing);
     gtk_box_pack_start(GTK_BOX(box1), thing, FALSE, TRUE, 0);
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-                       GTK_SIGNAL_FUNC(sample_editor_lrvol), (gpointer)4);
+    g_signal_connect(thing, "clicked",
+                       G_CALLBACK(sample_editor_lrvol), (gpointer)4);
 
     add_empty_hbox(box1);
 
@@ -2301,14 +2308,14 @@
     thing = gtk_button_new_with_label(_("H"));
     gtk_widget_show(thing);
     gtk_box_pack_start(GTK_BOX(box1), thing, FALSE, TRUE, 0);
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-                       GTK_SIGNAL_FUNC(sample_editor_lrvol), (gpointer)2);
+    g_signal_connect(thing, "clicked",
+                       G_CALLBACK(sample_editor_lrvol), (gpointer)2);
 
     thing = gtk_button_new_with_label(_("D"));
     gtk_widget_show(thing);
     gtk_box_pack_start(GTK_BOX(box1), thing, FALSE, TRUE, 0);
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-                       GTK_SIGNAL_FUNC(sample_editor_lrvol), (gpointer)8);
+    g_signal_connect(thing, "clicked",
+                       G_CALLBACK(sample_editor_lrvol), (gpointer)8);
 
     thing = gtk_hseparator_new();
     gtk_widget_show(thing);
@@ -2323,8 +2330,8 @@
 	thing = gtk_button_new_with_label(labels1[i]);
 	gtk_widget_show(thing);
 	gtk_box_pack_start(GTK_BOX(box1), thing, TRUE, TRUE, 0);
-	gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-			   GTK_SIGNAL_FUNC(sample_editor_perform_ramp),
+	g_signal_connect(thing, "clicked",
+			   G_CALLBACK(sample_editor_perform_ramp),
 			   GINT_TO_POINTER(i));
     }
 
diff -Naur soundtracker-0.6.8/app/sample-editor.h soundtracker-0.6.8-gtk2/app/sample-editor.h
--- soundtracker-0.6.8/app/sample-editor.h	2004-01-11 16:19:55.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/sample-editor.h	2010-09-23 11:11:35.000000000 +0200
@@ -26,6 +26,11 @@
 #include "xm.h"
 #include "driver-in.h"
 
+/* by Rexy: */
+#ifndef GTK_WINDOW_DIALOG
+# define GTK_WINDOW_DIALOG GTK_WINDOW_TOPLEVEL
+#endif
+
 void         sample_editor_page_create               (GtkNotebook *nb);
 
 gboolean     sample_editor_handle_keys               (int shift,
diff -Naur soundtracker-0.6.8/app/scalablepic.c soundtracker-0.6.8-gtk2/app/scalablepic.c
--- soundtracker-0.6.8/app/scalablepic.c	2003-03-02 14:54:05.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/scalablepic.c	2010-09-23 11:11:35.000000000 +0200
@@ -58,7 +58,7 @@
 {
     ScalablePic *sp;
     
-    GtkWidget *widget = GTK_WIDGET (gtk_type_new (scalable_pic_get_type ()));
+    GtkWidget *widget = GTK_WIDGET (g_object_new (scalable_pic_get_type (), NULL));
     sp = SCALABLE_PIC (widget);
 
     sp->pic = pic;
@@ -80,7 +80,6 @@
     object_class = (GtkObjectClass *)klass;
     
     widget_class->realize = scalable_pic_realize;
-    widget_class->draw = scalable_pic_draw;
     widget_class->event = scalable_pic_event;
     widget_class->size_request = scalable_pic_size_request;
     widget_class->size_allocate = scalable_pic_size_allocate;
diff -Naur soundtracker-0.6.8/app/scope-group.c soundtracker-0.6.8-gtk2/app/scope-group.c
--- soundtracker-0.6.8/app/scope-group.c	2003-05-17 13:16:36.000000000 +0200
+++ soundtracker-0.6.8-gtk2/app/scope-group.c	2010-09-23 11:11:35.000000000 +0200
@@ -29,6 +29,7 @@
 #include <string.h>
 
 #include <glib.h>
+#include <glib/gprintf.h>
 #include <gtk/gtkprivate.h>
 
 #ifndef NO_GDK_PIXBUF
@@ -268,7 +269,7 @@
     gint i;
     char buf[5];
 
-    s = gtk_type_new(scope_group_get_type());
+    s = g_object_new(scope_group_get_type(), NULL);
     GTK_BOX(s)->spacing = 2;
     GTK_BOX(s)->homogeneous = FALSE;
     s->scopes_on = 0;
@@ -284,10 +285,10 @@
     for(i = 0; i < 32; i++) {
 	button = gtk_toggle_button_new();
 	s->scopebuttons[i] = button;
-	gtk_signal_connect(GTK_OBJECT(button), "event",
-			   GTK_SIGNAL_FUNC(scope_group_scope_event), s);
-	gtk_signal_connect(GTK_OBJECT(button), "toggled",
-			   GTK_SIGNAL_FUNC(button_toggled), GINT_TO_POINTER(i));
+	g_signal_connect(button, "event",
+			   G_CALLBACK(scope_group_scope_event), s);
+	g_signal_connect(button, "toggled",
+			   G_CALLBACK(button_toggled), GINT_TO_POINTER(i));
 	gtk_widget_show(button);
 	gtk_widget_ref(button);
 
@@ -307,7 +308,7 @@
 	gtk_box_pack_start(GTK_BOX(box), thing, TRUE, TRUE, 0);
 	s->scopes[i] = SAMPLE_DISPLAY(thing);
 
-	sprintf(buf, "%02d", i+1);
+	g_sprintf(buf, "%02d", i+1);
 	thing = gtk_label_new(buf);
 	gtk_widget_show(thing);
 	gtk_box_pack_start(GTK_BOX(box), thing, FALSE, TRUE, 0);
@@ -327,18 +328,21 @@
     static guint scope_group_type = 0;
     
     if (!scope_group_type) {
-	GtkTypeInfo scope_group_info =
+	GTypeInfo scope_group_info =
 	{
-	    "ScopeGroup",
-	    sizeof(ScopeGroup),
 	    sizeof(ScopeGroupClass),
-	    (GtkClassInitFunc) NULL,
-	    (GtkObjectInitFunc) NULL,
-	    (GtkArgSetFunc) NULL,
-	    (GtkArgGetFunc) NULL,
+	    (GBaseInitFunc) NULL,
+		(GBaseFinalizeFunc) NULL,
+	    (GClassInitFunc) NULL,
+	    (GClassFinalizeFunc) NULL,
+	    NULL,
+	    sizeof(ScopeGroup),
+	    0,
+	    (GInstanceInitFunc) NULL,
 	};
 	
-	scope_group_type = gtk_type_unique(gtk_hbox_get_type (), &scope_group_info);
+	scope_group_type = g_type_register_static(gtk_hbox_get_type (),
+	    "ScopeGroup", &scope_group_info,  (GTypeFlags)0);
     }
     
     return scope_group_type;
diff -Naur soundtracker-0.6.8/app/tips-dialog.c soundtracker-0.6.8-gtk2/app/tips-dialog.c
--- soundtracker-0.6.8/app/tips-dialog.c	2002-06-17 15:09:31.000000000 +0200
+++ soundtracker-0.6.8-gtk2/app/tips-dialog.c	2010-09-23 11:11:35.000000000 +0200
@@ -36,6 +36,7 @@
 static int  tips_dialog_hide (GtkWidget *widget, gpointer data);
 static int  tips_show_next (GtkWidget *widget, gpointer data);
 static void tips_toggle_update (GtkWidget *widget, gpointer data);
+static GtkWidget * tips_dialog_message (GtkWidget *lvbox);
 
 static GtkWidget *tips_dialog_vbox = NULL;
 static GtkWidget *tips_dialog = NULL;
@@ -76,14 +77,13 @@
     GtkWidget *thing;
 
     if(!tips_dialog) {
-	tips_dialog = gtk_window_new (GTK_WINDOW_DIALOG);
+	tips_dialog = gtk_dialog_new ();
 	gtk_window_set_wmclass (GTK_WINDOW (tips_dialog), "tip_of_the_day", "SoundTracker");
 	gtk_window_set_title (GTK_WINDOW (tips_dialog), (_("SoundTracker Tip of the day")));
-	gtk_signal_connect (GTK_OBJECT (tips_dialog), "delete_event",
-			    GTK_SIGNAL_FUNC (tips_dialog_hide), NULL);
+	g_signal_connect(tips_dialog, "delete_event",
+			 G_CALLBACK(tips_dialog_hide), NULL);
 	
-	thing = tips_dialog_get_vbox();
-	gtk_container_add(GTK_CONTAINER (tips_dialog), thing);
+	thing = tips_dialog_message(GTK_DIALOG (tips_dialog)->vbox);
 	gtk_widget_show(thing);
     }
 
@@ -100,9 +100,22 @@
     tips_dialog_vbox = NULL;
 }
 
+
 GtkWidget *
 tips_dialog_get_vbox (void)
 {
+
+    if(tips_dialog_vbox) {
+	g_error("tips_dialog_get_vbox() called twice.\n");
+	return NULL;
+    }
+
+    return tips_dialog_message( GTK_WIDGET(gtk_vbox_new (FALSE, 0)) );
+}
+
+GtkWidget *
+tips_dialog_message (GtkWidget *lvbox)
+{
     GtkWidget *vbox;
     GtkWidget *hbox1;
     GtkWidget *hbox2;
@@ -114,15 +127,10 @@
     GtkWidget *vbox_check;
     GtkWidget *button_check;
 
-    if(tips_dialog_vbox) {
-	g_error("tips_dialog_get_vbox() called twice.\n");
-	return NULL;
-    }
-
-    tips_dialog_vbox = vbox = gtk_vbox_new (FALSE, 0);
+    tips_dialog_vbox = vbox = lvbox;
 
-    gtk_signal_connect(GTK_OBJECT(tips_dialog_vbox), "destroy",
-		       GTK_SIGNAL_FUNC(tips_dialog_vbox_destroy), NULL);
+    g_signal_connect(tips_dialog_vbox, "destroy",
+		       G_CALLBACK(tips_dialog_vbox_destroy), NULL);
 
     hbox1 = gtk_hbox_new (FALSE, 5);
     gtk_container_set_border_width (GTK_CONTAINER (hbox1), 10);
@@ -153,16 +161,16 @@
 
     button_prev = gtk_button_new_with_label ((_("Previous Tip")));
     GTK_WIDGET_UNSET_FLAGS (button_prev, GTK_RECEIVES_DEFAULT);
-    gtk_signal_connect (GTK_OBJECT (button_prev), "clicked",
-			GTK_SIGNAL_FUNC (tips_show_next),
+    g_signal_connect(button_prev, "clicked",
+			G_CALLBACK(tips_show_next),
 			(gpointer) "prev");
     gtk_container_add (GTK_CONTAINER (bbox2), button_prev);
     gtk_widget_show (button_prev);
 
     button_next = gtk_button_new_with_label ((_("Next Tip")));
     GTK_WIDGET_UNSET_FLAGS (button_next, GTK_RECEIVES_DEFAULT);
-    gtk_signal_connect (GTK_OBJECT (button_next), "clicked",
-			GTK_SIGNAL_FUNC (tips_show_next),
+    g_signal_connect(button_next, "clicked",
+			G_CALLBACK(tips_show_next),
 			(gpointer) "next");
     gtk_container_add (GTK_CONTAINER (bbox2), button_next);
     gtk_widget_show (button_next);
@@ -174,8 +182,8 @@
     button_check = gtk_check_button_new_with_label ((_("Show tip next time")));
     gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (button_check),
 				  tips_dialog_show_tips);
-    gtk_signal_connect (GTK_OBJECT (button_check), "toggled",
-			GTK_SIGNAL_FUNC (tips_toggle_update),
+    g_signal_connect(button_check, "toggled",
+			G_CALLBACK(tips_toggle_update),
 			(gpointer) &tips_dialog_show_tips);
     gtk_box_pack_start (GTK_BOX (vbox_check), button_check, TRUE, FALSE, 0);
     gtk_widget_show (button_check);
diff -Naur soundtracker-0.6.8/app/track-editor.c soundtracker-0.6.8-gtk2/app/track-editor.c
--- soundtracker-0.6.8/app/track-editor.c	2006-02-25 13:30:54.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/track-editor.c	2010-09-23 11:11:35.000000000 +0200
@@ -24,6 +24,8 @@
 #include <ctype.h>
 
 #include <gdk/gdkkeysyms.h>
+#include <glib.h>
+#include <glib/gprintf.h>
 
 #include "i18n.h"
 #include "track-editor.h"
@@ -186,7 +188,7 @@
         N_("square"),                    /* 2 */
     };
 
-    sprintf(track_editor_editmode_status_ed_buf, "[Chnn: %02d] [Pos: %03d] [Instr: %03d] ", t->cursor_ch+1,
+    g_sprintf(track_editor_editmode_status_ed_buf, "[Chnn: %02d] [Pos: %03d] [Instr: %03d] ", t->cursor_ch+1,
                                                                t->patpos,
                                                                note->instrument);
 
@@ -202,7 +204,7 @@
         break;
     default:
         if(note->volume>0xf) {
-            sprintf(tmp_buf,"%s", _(vol_fx_commands[((note->volume&0xf0)-0x60)>>4]));
+            g_sprintf(tmp_buf,"%s", _(vol_fx_commands[((note->volume&0xf0)-0x60)>>4]));
             strcat(track_editor_editmode_status_ed_buf, tmp_buf);
         } else
             strcat(track_editor_editmode_status_ed_buf, _("None"));
@@ -211,11 +213,11 @@
 
     if(note->volume&0xf0) {
         if(note->volume>=0x10 && note->volume<=0x50)
-            sprintf(tmp_buf, " => %02d ] ", note->volume-0x10);
+            g_sprintf(tmp_buf, " => %02d ] ", note->volume-0x10);
         else
-            sprintf(tmp_buf, " => %02d ] ", note->volume&0xf);
+            g_sprintf(tmp_buf, " => %02d ] ", note->volume&0xf);
     } else
-         sprintf(tmp_buf, " ] ");
+         g_sprintf(tmp_buf, " ] ");
     strcat(track_editor_editmode_status_ed_buf, tmp_buf);
         
     memset(tmp_buf, 0, strlen(tmp_buf));
@@ -226,18 +228,18 @@
     {
     case 0:
         if(note->fxparam)
-            sprintf(tmp_buf, "%s", _(fx_commands[note->fxtype]));
+            g_sprintf(tmp_buf, "%s", _(fx_commands[note->fxtype]));
         else
-            sprintf(tmp_buf, _("None ]"));
+            g_sprintf(tmp_buf, _("None ]"));
         break;
     case 14:
         switch((note->fxparam&0xf0)>>4)
         {
         case 0: case 8: case 15:
-            sprintf(tmp_buf, _("None ]"));
+            g_sprintf(tmp_buf, _("None ]"));
             break;
         default:
-            sprintf(tmp_buf, "%s", _(e_fx_commands[(note->fxparam&0xf0)>>4]));
+            g_sprintf(tmp_buf, "%s", _(e_fx_commands[(note->fxparam&0xf0)>>4]));
             break;
         }
         break;
@@ -245,23 +247,23 @@
         switch((note->fxparam&0xf0)>>4)
         {
         case 1:
-            sprintf(tmp_buf, "Extra fine porta up");
+            g_sprintf(tmp_buf, "Extra fine porta up");
             break;
         case 2:
-            sprintf(tmp_buf, "Extra fine porta down");
+            g_sprintf(tmp_buf, "Extra fine porta down");
             break;
         default:
-            sprintf(tmp_buf, _("None ]"));
+            g_sprintf(tmp_buf, _("None ]"));
             break;
         }
         break;
     case 18: case 19: case 22: case 23: case 24:
     case 28: case 30: case 31: case 32: case 34:
-        sprintf(tmp_buf, _("None ]"));
+        g_sprintf(tmp_buf, _("None ]"));
         break;
 
     default:
-        sprintf(tmp_buf, "%s", _(fx_commands[note->fxtype]));
+        g_sprintf(tmp_buf, "%s", _(fx_commands[note->fxtype]));
         break;
     }
     strcat(track_editor_editmode_status_ed_buf, tmp_buf);
@@ -276,39 +278,39 @@
     {
     case 0:
         if(note->fxparam)
-            sprintf(tmp_buf, " => %02d %02d ]", cmd_p1, cmd_p2);
+            g_sprintf(tmp_buf, " => %02d %02d ]", cmd_p1, cmd_p2);
         break;
     case 4:  case 7: case 10: case 17: case 25: case 27: case 29:
-        sprintf(tmp_buf, " => %02d %02d ]", cmd_p1, cmd_p2);
+        g_sprintf(tmp_buf, " => %02d %02d ]", cmd_p1, cmd_p2);
         break;
     case 1: case 2: case 3: case 5: case 6: case 8: case 9:
     case 11: case 12: case 13: case 15: case 16: case 21: case 26: case 35:
 
         if(note->fxtype==15)
             if (note->fxparam<32)
-                sprintf(tmp_buf, " => tempo: %02d ]", note->fxparam);
+                g_sprintf(tmp_buf, " => tempo: %02d ]", note->fxparam);
             else
-                sprintf(tmp_buf, " => BPM: %03d ]", note->fxparam);
+                g_sprintf(tmp_buf, " => BPM: %03d ]", note->fxparam);
         else if(note->fxtype==9)
-                sprintf(tmp_buf, " => offset: %d ]", note->fxparam<<8);
+                g_sprintf(tmp_buf, " => offset: %d ]", note->fxparam<<8);
              else
-                sprintf(tmp_buf, " => %03d ]", note->fxparam);
+                g_sprintf(tmp_buf, " => %03d ]", note->fxparam);
 
         break;
     case 14:
         if(cmd_p1!=0 && cmd_p1!=8 && cmd_p1!=15) {
             if((cmd_p1==4 || cmd_p1==7) && (cmd_p2<3))
-                sprintf(tmp_buf, " => %02d (%s) ]", cmd_p2, e47_fx_forms[cmd_p2]);
+                g_sprintf(tmp_buf, " => %02d (%s) ]", cmd_p2, e47_fx_forms[cmd_p2]);
             else
-                sprintf(tmp_buf, " => %02d ]", cmd_p2);
+                g_sprintf(tmp_buf, " => %02d ]", cmd_p2);
         }
         break;
     case 33:
         if (cmd_p1==1 || cmd_p1==2)
-            sprintf(tmp_buf, " => %02d ]", cmd_p2);
+            g_sprintf(tmp_buf, " => %02d ]", cmd_p2);
         break;
     default:
-        sprintf(tmp_buf, "]");
+        g_sprintf(tmp_buf, "]");
         break;
     }
     strcat(track_editor_editmode_status_ed_buf, tmp_buf);
@@ -367,7 +369,7 @@
 
     for(i = 0; i < 32; i++) {
 	char buf[10];
-	sprintf(buf, "%02d", i+1);
+	g_sprintf(buf, "%02d", i+1);
 	thing = gtk_toggle_button_new_with_label(buf);
 	jazztoggles[i] = GTK_TOGGLE_BUTTON(thing);
 	gtk_widget_show(thing);
@@ -380,9 +382,9 @@
     thing = tracker_new();
     gtk_table_attach_defaults(GTK_TABLE(table), thing, 0, 1, 0, 1);
     gtk_widget_show(thing);
-    gtk_signal_connect(GTK_OBJECT(thing), "patpos", GTK_SIGNAL_FUNC(update_vscrollbar), NULL);
-    gtk_signal_connect(GTK_OBJECT(thing), "xpanning", GTK_SIGNAL_FUNC(update_hscrollbar), NULL);
-    gtk_signal_connect(GTK_OBJECT(thing), "mainmenu_blockmark_set", GTK_SIGNAL_FUNC(update_mainmenu_blockmark), NULL);
+    g_signal_connect(thing, "patpos", G_CALLBACK(update_vscrollbar), NULL);
+    g_signal_connect(thing, "xpanning", G_CALLBACK(update_hscrollbar), NULL);
+    g_signal_connect(thing, "mainmenu_blockmark_set", G_CALLBACK(update_mainmenu_blockmark), NULL);
     tracker = TRACKER(thing);
 
     tracker_set_update_freq(gui_settings.tracker_update_freq);
@@ -582,7 +584,7 @@
     int c, i, m, tip;
     Tracker *t = tracker;
     gboolean handled = FALSE;
-    
+
     m = i = keys_get_key_meaning(keyval, ENCODE_MODIFIERS(shift, ctrl, alt));
     tip = KEYS_MEANING_TYPE(i);
 
@@ -1258,7 +1260,7 @@
 static void
 track_editor_handle_semidec_column_input (Tracker *t,
 					  int exp,
-					  gint8 *modpt,
+					  guint8 *modpt,
 					  int n)
 {
     switch(exp) {
@@ -1285,7 +1287,7 @@
 static void
 track_editor_handle_hex_column_input (Tracker *t,
 				      int exp,
-				      gint8 *modpt,
+				      guint8 *modpt,
 				      int n)
 {
     int s;
@@ -1426,7 +1428,7 @@
     f = prefs_open_read("jazz");
     if(f) {
 	for(i = 0; i < 32; i++) {
-	    sprintf(buf, "jazz-toggle-%d", i);
+	    g_sprintf(buf, "jazz-toggle-%d", i);
 	    prefs_get_int(f, buf, &j);
 	    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(jazztoggles[i]), j);
 	}
@@ -1451,7 +1453,7 @@
 	return;
 
     for(i = 0; i < 32; i++) {
-	sprintf(buf, "jazz-toggle-%d", i);
+	g_sprintf(buf, "jazz-toggle-%d", i);
 	prefs_put_int(f, buf, GTK_TOGGLE_BUTTON(jazztoggles[i])->active);
     }
 
diff -Naur soundtracker-0.6.8/app/tracker.c soundtracker-0.6.8-gtk2/app/tracker.c
--- soundtracker-0.6.8/app/tracker.c	2006-02-25 13:30:54.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/tracker.c	2010-09-23 11:11:35.000000000 +0200
@@ -3,6 +3,7 @@
  * The Real SoundTracker - GTK+ Tracker widget
  *
  * Copyright (C) 1998-2001 Michael Krause
+ * Copyright (C) 2006 Yury Aliaev (GTK+-2 porting)
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -25,6 +26,7 @@
 #include <gtk/gtk.h>
 #include <gtk/gtksignal.h>
 #include <gtk/gtkmain.h>
+#include <glib/gprintf.h>
 
 #include "tracker.h"
 #include "main.h"
@@ -575,24 +577,26 @@
     }
 
     /* -- Draw the actual row contents -- */
-    y += t->font->ascent + t->baselineskip;
+    y += t->baselineskip;
 
     /* The row number */
     if(gui_settings.tracker_hexmode) {
-	if(gui_settings.tracker_upcase) sprintf(buf, "%02X", row);
-        else sprintf(buf, "%02x", row);
+	if(gui_settings.tracker_upcase) g_sprintf(buf, "%02X", row);
+        else g_sprintf(buf, "%02x", row);
     } else {
-	sprintf(buf, "%03d", row);
+	g_sprintf(buf, "%03d", row);
     }
 
-    gdk_draw_string(win, t->font, t->notes_gc, 5, y, buf);
+    pango_layout_set_text(t->layout, buf, -1);
+    gdk_draw_layout(win, t->notes_gc, 5, y, t->layout);
     
     /* The notes */
     for(numch += ch, bufpt = buf; ch < numch; ch++, bufpt += 14) {
 	note2string(&t->curpattern->channels[ch][row], bufpt);
     }	
 
-    gdk_draw_string(win, t->font, t->notes_gc, t->disp_startx, y, buf);
+    pango_layout_set_text(t->layout, buf, -1);
+    gdk_draw_layout(win, t->notes_gc, t->disp_startx, y, t->layout);
 }
 
 static void
@@ -638,7 +642,8 @@
     /* Draw the separation bars */
     gdk_gc_set_foreground(t->misc_gc, &t->colors[TRACKERCOL_BARS]);
     x1 = t->disp_startx - 2;
-    y1 = t->disp_starty + n1 * t->fonth - t->fonth;
+//    y1 = t->disp_starty + n1 * t->fonth - t->fonth;
+    y1 = t->disp_starty + n1 * t->fonth;
     h = (n2 - n1 + 2) * t->fonth;
     for(i = 0; i <= t->disp_numchans; i++, x1 += t->disp_chanwidth) {
 	gdk_draw_line(win, t->misc_gc, x1, y1, x1, y1+h);
@@ -660,13 +665,14 @@
     gdk_gc_set_foreground(t->misc_gc, &t->colors[TRACKERCOL_CHANNUMS]);
 
     x = t->disp_startx + (t->disp_chanwidth - (2 * t->fontw)) / 2; 
-    y = t->disp_starty + t->font->ascent + t->baselineskip - t->fonth;
+    y = t->disp_starty + t->baselineskip - t->fonth;
+    gdk_draw_rectangle(win, t->bg_gc, TRUE, 0, t->disp_starty - t->fonth - 1, widget->allocation.width, t->fonth + 1);
     for(i = 1; i <= t->disp_numchans; i++, x += t->disp_chanwidth) {
-	sprintf(buf, "%2d", i + t->leftchan);
+	g_sprintf(buf, "%2d", i + t->leftchan);
 	if(gui_settings.permanent_channels & (1 << (i + t->leftchan - 1)))
 	    strcat(buf, "*");
-	gdk_draw_rectangle(win, t->bg_gc, TRUE, x, t->disp_starty - t->fonth, 3*t->fontw, t->fonth);
-	gdk_draw_string(win, t->font, t->misc_gc, x, y, buf);
+	pango_layout_set_text(t->layout, buf, -1);
+	gdk_draw_layout(win, t->misc_gc, x, y, t->layout);
     }
 }
 
@@ -768,10 +774,9 @@
 	if(dist > 0) {
 	    /* go down in pattern -- scroll up */
 	    redrawcnt = absdist;
-	    gdk_window_copy_area(win, t->bg_gc,
-				 0, y, win,
-				 0, y + (absdist * fonth),
-				 widget->allocation.width, (t->disp_rows - absdist) * fonth);
+	    gdk_draw_drawable(win, t->bg_gc, win,
+			      0, y + (absdist * fonth), 0, y,
+			      widget->allocation.width, (t->disp_rows - absdist) * fonth);
 	    y += (t->disp_rows - absdist) * fonth;
 	} else if(dist < 0) {
 	    /* go up in pattern -- scroll down */
@@ -782,9 +787,9 @@
 				     widget->allocation.width, fonth, t->oldpos - dist);
 	    }
 	    redrawcnt = absdist;
-	    gdk_window_copy_area(win, t->bg_gc,
-				 0, y + (absdist * fonth), win, 0, y,
-				 widget->allocation.width, (t->disp_rows - absdist) * fonth);
+	    gdk_draw_drawable(win, t->bg_gc, win,
+			      0, y, 0, y + (absdist * fonth),
+			      widget->allocation.width, (t->disp_rows - absdist) * fonth);
 	}
     }
 
@@ -800,7 +805,7 @@
     print_cursor(widget, win);
 
     if(t->enable_backing_store) {
-	gdk_draw_pixmap(widget->window, t->bg_gc, t->pixmap,
+	gdk_draw_drawable(widget->window, t->bg_gc, t->pixmap,
 			area->x, area->y,
 			area->x, area->y,
 			area->width, area->height);
@@ -817,13 +822,6 @@
     tracker_draw_clever(widget, area);
 }
 
-static void
-tracker_draw (GtkWidget *widget,
-	      GdkRectangle *area)
-{
-    tracker_draw_stupid(widget, area);
-}
-
 static gint
 tracker_expose (GtkWidget *widget,
 		GdkEventExpose *event)
@@ -876,7 +874,6 @@
     t->disp_starty = (height - t->fonth * t->disp_rows) / 2 + t->fonth;
 	t->disp_rows--;
 
-    t->disp_chanwidth = 14 * t->fontw;
     u = width - line_numbers_space - 10;
     t->disp_numchans = u / t->disp_chanwidth;
     
@@ -942,20 +939,32 @@
     }
 }
 
-static void
-init_colors (GtkWidget *widget)
+void
+tracker_init_colors (Tracker *t)
 {
     int n;
     const int *p;
     GdkColor *c;
 
-    for (n = 0, p = default_colors, c = TRACKER(widget)->colors; n < TRACKERCOL_LAST; n++, c++) {
+    for (n = 0, p = default_colors, c = t->colors; n < TRACKERCOL_LAST; n++, c++) {
 	c->red = *p++ * 65535 / 255;
 	c->green = *p++ * 65535 / 255;
 	c->blue = *p++ * 65535 / 255;
         c->pixel = (gulong)((c->red & 0xff00)*256 + (c->green & 0xff00) + (c->blue & 0xff00)/256);
-        gdk_color_alloc(gtk_widget_get_colormap(widget), c);
+        gdk_color_alloc(gtk_widget_get_colormap(GTK_WIDGET(t)), c);
     }
+
+    tracker_apply_colors(t);
+}
+
+void
+tracker_apply_colors (Tracker *t)
+{
+    gdk_gc_set_foreground(t->bg_gc, &t->colors[TRACKERCOL_BG]);
+    gdk_gc_set_foreground(t->bg_cursor_gc, &t->colors[TRACKERCOL_BG_CURSOR]);
+    gdk_gc_set_foreground(t->bg_majhigh_gc, &t->colors[TRACKERCOL_BG_MAJHIGH]);
+    gdk_gc_set_foreground(t->bg_minhigh_gc, &t->colors[TRACKERCOL_BG_MINHIGH]);
+    gdk_gc_set_foreground(t->notes_gc, &t->colors[TRACKERCOL_NOTES]);
 }
 
 static void
@@ -989,19 +998,21 @@
 
     widget->style = gtk_style_attach (widget->style, widget->window);
 
-    init_colors(widget);
-
     t->bg_gc = gdk_gc_new(widget->window);
     t->bg_cursor_gc = gdk_gc_new(widget->window);
     t->bg_majhigh_gc = gdk_gc_new(widget->window);
     t->bg_minhigh_gc = gdk_gc_new(widget->window);
     t->notes_gc = gdk_gc_new(widget->window);
     t->misc_gc = gdk_gc_new(widget->window);
-    gdk_gc_set_foreground(t->bg_gc, &t->colors[TRACKERCOL_BG]);
-    gdk_gc_set_foreground(t->bg_cursor_gc, &t->colors[TRACKERCOL_BG_CURSOR]);
-    gdk_gc_set_foreground(t->bg_majhigh_gc, &t->colors[TRACKERCOL_BG_MAJHIGH]);
-    gdk_gc_set_foreground(t->bg_minhigh_gc, &t->colors[TRACKERCOL_BG_MINHIGH]);
-    gdk_gc_set_foreground(t->notes_gc, &t->colors[TRACKERCOL_NOTES]);
+    if(gui_settings_colors.ok) {
+	guint i;
+
+	memcpy(&t->colors[0], &gui_settings_colors.val[0], sizeof(GdkColor) * TRACKERCOL_LAST);
+	for(i = 0; i < TRACKERCOL_LAST; i++)
+	    gdk_color_alloc(gtk_widget_get_colormap(widget), &t->colors[i]);
+	tracker_apply_colors(t);
+    } else
+	tracker_init_colors(t);
 
     if(!t->enable_backing_store)
 	gdk_gc_set_exposures (t->bg_gc, 1); /* man XCopyArea, grep exposures */
@@ -1016,19 +1027,24 @@
 tracker_set_font (Tracker *t,
 		  const gchar *fontname)
 {
-    GdkFont *font;
-    int fonth, fontw;
+    int fonth, fontw, chanwidth;
+    PangoFontDescription *desc;
 
-    if((font = gdk_font_load(fontname))) {
-	fonth = font->ascent + font->descent + t->baselineskip;
-	fontw = gdk_string_width(font, "X"); /* let's just hope this is a non-proportional font */
+    desc = pango_font_description_from_string(fontname);
+    pango_layout_set_font_description(t->layout, desc);
+    pango_font_description_free(desc);
+						    
+    if(desc) {
+    pango_layout_set_text(t->layout, "--- 00 00 000 ", -1);
+    pango_layout_get_pixel_size(t->layout, &chanwidth, &fonth);
+    fontw = chanwidth / 14;// Assume we have monospace font :-)
+    fonth += t->baselineskip;
 
 	/* Some fonts have width 0, for example 'clearlyu' */
 	if(fonth >= 1 && fontw >= 1) {
-	    gdk_font_unref(t->font);
-	    t->font = font;
 	    t->fontw = fontw;
 	    t->fonth = fonth;
+	    t->disp_chanwidth = chanwidth;
 	    tracker_reset(t);
 	    return TRUE;
 	}
@@ -1037,30 +1053,68 @@
     return FALSE;
 }
 
+typedef void  (*___Sig1) (Tracker *, gint , gint , gint , gpointer);
+
 static void
-my_3ints_marshal (GtkObject *object,
-		  GtkSignalFunc func,
-		  gpointer func_data,
-		  GtkArg *args)
-{
-    typedef void (*my_3ints_marshal_func)(Tracker *, int, int, int);
-    my_3ints_marshal_func rfunc = (my_3ints_marshal_func) func;
-    (*rfunc) (TRACKER(object),
-	      GTK_VALUE_INT(args[0]),
-	      GTK_VALUE_INT(args[1]),
-	      GTK_VALUE_INT(args[2]));
+___marshal_Sig1 (GClosure *closure,
+	GValue *return_value,
+	guint n_param_values,
+	const GValue *param_values,
+	gpointer invocation_hint,
+	gpointer marshal_data)
+{
+	register ___Sig1 callback;
+	register GCClosure *cc = (GCClosure*) closure;
+	register gpointer data1, data2;
+
+	g_return_if_fail (n_param_values == 4);
+
+	if (G_CCLOSURE_SWAP_DATA (closure)) {
+		data1 = closure->data;
+		data2 = g_value_peek_pointer (param_values + 0);
+	} else {
+		data1 = g_value_peek_pointer (param_values + 0);
+		data2 = closure->data;
+	}
+
+	callback = (___Sig1) (marshal_data != NULL ? marshal_data : cc->callback);
+
+	callback ((Tracker *)data1,
+		(gint ) g_value_get_int (param_values + 1),
+		(gint ) g_value_get_int (param_values + 2),
+		(gint ) g_value_get_int (param_values + 3),
+		data2);
 }
 
+typedef void  (*___Sig2) (Tracker *, gint , gpointer);
+
 static void
-my_1int_marshal(GtkObject *object,
-		  GtkSignalFunc func,
-		  gpointer func_data,
-		  GtkArg *args)
-{
-    typedef void (*my_1ints_marshal_func)(Tracker *, int);
-    my_1ints_marshal_func rfunc = (my_1ints_marshal_func) func;
-    (*rfunc) (TRACKER(object),
-	      GTK_VALUE_INT(args[0]));
+___marshal_Sig2 (GClosure *closure,
+	GValue *return_value,
+	guint n_param_values,
+	const GValue *param_values,
+	gpointer invocation_hint,
+	gpointer marshal_data)
+{
+	register ___Sig2 callback;
+	register GCClosure *cc = (GCClosure*) closure;
+	register gpointer data1, data2;
+
+	g_return_if_fail (n_param_values == 2);
+
+	if (G_CCLOSURE_SWAP_DATA (closure)) {
+		data1 = closure->data;
+		data2 = g_value_peek_pointer (param_values + 0);
+	} else {
+		data1 = g_value_peek_pointer (param_values + 0);
+		data2 = closure->data;
+	}
+
+	callback = (___Sig2) (marshal_data != NULL ? marshal_data : cc->callback);
+
+	callback ((Tracker *)data1,
+		(gint ) g_value_get_int (param_values + 1),
+		data2);
 }
 
 /* If selecting, mouse is used to select in pattern */
@@ -1129,6 +1183,38 @@
 	*patpos = t->curpattern->length - 1;
 }
 
+static gboolean
+tracker_scroll (GtkWidget      *widget,
+		GdkEventScroll *event)
+{
+    Tracker	*t;
+    t = TRACKER(widget);
+
+    switch(event->direction) {
+    case GDK_SCROLL_UP:
+	if(event->state & GDK_SHIFT_MASK) {
+	    if(t->leftchan > 0) tracker_set_xpanning(t, t->leftchan - 1);
+	} else
+	    if(t->patpos > 0) tracker_step_cursor_row(t, -1);
+	return TRUE;
+    case GDK_SCROLL_DOWN:
+	if(event->state & GDK_SHIFT_MASK) {
+	    if(t->leftchan + t->disp_numchans < t->num_channels) tracker_set_xpanning(t, t->leftchan + 1);
+	} else
+	    if(t->patpos < t->curpattern->length - 1) tracker_step_cursor_row(t, 1);
+	return TRUE;
+    case GDK_SCROLL_LEFT:/* For happy folks with 2-scroller mice :-) */
+	if(t->leftchan > 0) tracker_set_xpanning(t, t->leftchan - 1);
+	return TRUE;
+    case GDK_SCROLL_RIGHT:
+	if(t->patpos < t->curpattern->length - 1) tracker_step_cursor_row(t, 1);
+	return TRUE;
+    default:
+	break;
+    }
+    return FALSE;
+}
+
 static gint
 tracker_button_press (GtkWidget      *widget,
 		      GdkEventButton *event)
@@ -1268,49 +1354,51 @@
 static void
 tracker_class_init (TrackerClass *class)
 {
-    GtkObjectClass *object_class;
+    GObjectClass *object_class;
     GtkWidgetClass *widget_class;
 
-    object_class = (GtkObjectClass*) class;
+    object_class = (GObjectClass*) class;
     widget_class = (GtkWidgetClass*) class;
     
     widget_class->realize = tracker_realize;
     widget_class->expose_event = tracker_expose;
-    widget_class->draw = tracker_draw;
     widget_class->size_request = tracker_size_request;
     widget_class->size_allocate = tracker_size_allocate;
     widget_class->button_press_event = tracker_button_press;
     widget_class->button_release_event = tracker_button_release;
     widget_class->motion_notify_event = tracker_motion_notify;
+    widget_class->scroll_event = tracker_scroll;
 
 
-    tracker_signals[SIG_PATPOS] = gtk_signal_new ("patpos",
-						  GTK_RUN_FIRST,
-						  object_class->type,
-						  GTK_SIGNAL_OFFSET(TrackerClass, patpos),
-						  my_3ints_marshal,
-						  GTK_TYPE_NONE, 3,
-						  GTK_TYPE_INT,
-						  GTK_TYPE_INT,
-						  GTK_TYPE_INT);
-    tracker_signals[SIG_XPANNING] = gtk_signal_new ("xpanning",
-						    GTK_RUN_FIRST,
-						    object_class->type,
-						    GTK_SIGNAL_OFFSET(TrackerClass, xpanning),
-						    my_3ints_marshal,
-						    GTK_TYPE_NONE, 3,
-						    GTK_TYPE_INT,
-						    GTK_TYPE_INT,
-						    GTK_TYPE_INT);
-    tracker_signals[SIG_MAINMENU_BLOCKMARK_SET] = gtk_signal_new("mainmenu_blockmark_set",
-								 GTK_RUN_FIRST,
-								 object_class->type,
-								 GTK_SIGNAL_OFFSET(TrackerClass, mainmenu_blockmark_set),
-								 my_1int_marshal,
-								 GTK_TYPE_NONE, 1,
-								 GTK_TYPE_INT);
+    tracker_signals[SIG_PATPOS] =
+	   		g_signal_new ("patpos",
+			G_TYPE_FROM_CLASS (object_class),
+			(GSignalFlags)(G_SIGNAL_RUN_FIRST | G_SIGNAL_ACTION),
+			G_STRUCT_OFFSET (TrackerClass, patpos),
+			NULL, NULL,
+			___marshal_Sig1,
+			G_TYPE_NONE, 3,
+			G_TYPE_INT,
+			G_TYPE_INT,
+			G_TYPE_INT);
+
+    tracker_signals[SIG_XPANNING] = g_signal_new ("xpanning",
+		    	G_TYPE_FROM_CLASS (object_class),
+			(GSignalFlags)G_SIGNAL_RUN_FIRST,
+			G_STRUCT_OFFSET(TrackerClass, xpanning),
+			NULL, NULL,
+			___marshal_Sig1,
+			G_TYPE_NONE, 3,
+			G_TYPE_INT, G_TYPE_INT, G_TYPE_INT);
+    tracker_signals[SIG_MAINMENU_BLOCKMARK_SET] = g_signal_new(
+		    "mainmenu_blockmark_set",
+		    	G_TYPE_FROM_CLASS (object_class),
+			(GSignalFlags)G_SIGNAL_RUN_FIRST,
+			G_STRUCT_OFFSET(TrackerClass, mainmenu_blockmark_set),
+			NULL, NULL,
+			___marshal_Sig2,
+			G_TYPE_NONE, 1, G_TYPE_INT);
 
-    gtk_object_class_add_signals(object_class, tracker_signals, LAST_SIGNAL);
     
     class->patpos = NULL;
     class->xpanning = NULL;
@@ -1320,10 +1408,22 @@
 static void
 tracker_init (Tracker *t)
 {
+    PangoFontDescription *desc;
+    GtkWidget *widget = GTK_WIDGET(t);
+
+    t->context = gtk_widget_create_pango_context(widget);
+    t->layout = pango_layout_new(t->context);
+
+    desc = pango_font_description_from_string("Fixed 10");
+    pango_layout_set_font_description(t->layout, desc);
+    pango_font_description_free(desc);
+						    
     t->baselineskip = 0;
-    t->font = gdk_font_load("fixed");
-    t->fonth = t->font->ascent + t->font->descent + t->baselineskip;
-    t->fontw = gdk_string_width(t->font, "X"); /* let's just hope this is a non-proportional font */
+    pango_layout_set_text(t->layout, "--- 00 00 000 ", -1);
+    pango_layout_get_pixel_size(t->layout, &(t->disp_chanwidth), &(t->fonth));
+    t->fonth += t->baselineskip;
+    t->fontw = t->disp_chanwidth / 14;// Assume we have monospace font :-)
+
     t->oldpos = -1;
     t->curpattern = NULL;
     t->enable_backing_store = 0;
@@ -1344,18 +1444,21 @@
     static guint tracker_type = 0;
     
     if (!tracker_type) {
-	GtkTypeInfo tracker_info =
+	GTypeInfo tracker_info =
 	{
-	    "Tracker",
-	    sizeof(Tracker),
 	    sizeof(TrackerClass),
-	    (GtkClassInitFunc) tracker_class_init,
-	    (GtkObjectInitFunc) tracker_init,
-	    (GtkArgSetFunc) NULL,
-	    (GtkArgGetFunc) NULL,
+	    (GBaseInitFunc) NULL,
+	    (GBaseFinalizeFunc) NULL,
+	    (GClassInitFunc) tracker_class_init,
+	    (GClassFinalizeFunc) NULL,
+	    NULL,
+	    sizeof(Tracker),
+	    0,
+	    (GInstanceInitFunc) tracker_init,
 	};
 	
-	tracker_type = gtk_type_unique (gtk_widget_get_type (), &tracker_info);
+	tracker_type = g_type_register_static(gtk_widget_get_type (),
+	    "Tracker", &tracker_info, (GTypeFlags)0);
     }
     
     return tracker_type;
@@ -1364,5 +1467,5 @@
 GtkWidget*
 tracker_new (void)
 {
-    return GTK_WIDGET(gtk_type_new(tracker_get_type()));
+    return GTK_WIDGET(g_object_new(tracker_get_type(), NULL));
 }
diff -Naur soundtracker-0.6.8/app/tracker.h soundtracker-0.6.8-gtk2/app/tracker.h
--- soundtracker-0.6.8/app/tracker.h	2003-05-24 13:58:34.000000000 +0200
+++ soundtracker-0.6.8-gtk2/app/tracker.h	2010-09-23 11:11:35.000000000 +0200
@@ -3,6 +3,7 @@
  * The Real SoundTracker - GTK+ Tracker widget (header)
  *
  * Copyright (C) 1998-2001 Michael Krause
+ * Copyright (C) 2006 Yury Aliaev (GTK+-2 porting)
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -59,9 +60,10 @@
     int disp_chanwidth;
     int disp_cursor;
 
-    GdkFont *font;
     int fonth, fontw;
     int baselineskip;
+    PangoLayout *layout;
+    PangoContext *context;
 
     GdkGC *bg_gc, *bg_cursor_gc, *bg_majhigh_gc, *bg_minhigh_gc, *notes_gc, *misc_gc;
     GdkColor colors[TRACKERCOL_LAST];
@@ -103,6 +105,8 @@
 
 void           	tracker_set_backing_store   (Tracker *t, int on);
 gboolean       	tracker_set_font            (Tracker *t, const gchar *fontname);
+void		tracker_init_colors	    (Tracker *t);
+void		tracker_apply_colors	    (Tracker *t);
 
 void           	tracker_reset               (Tracker *t);
 void           	tracker_redraw              (Tracker *t);
diff -Naur soundtracker-0.6.8/app/tracker-settings.c soundtracker-0.6.8-gtk2/app/tracker-settings.c
--- soundtracker-0.6.8/app/tracker-settings.c	2002-08-17 18:04:40.000000000 +0200
+++ soundtracker-0.6.8-gtk2/app/tracker-settings.c	2010-09-23 11:11:35.000000000 +0200
@@ -3,6 +3,7 @@
  * The Real SoundTracker - GTK+ Tracker widget settings
  *
  * Copyright (C) 2001 Michael Krause
+ * Copyright (C) 2005 Yury Aliaev
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -41,25 +42,32 @@
 			      gchar *fontname,
 			      int position)
 {
-    gchar *insertbuf[1];
+    gchar *insertbuf;
+    GtkListStore *list_store;
+    GtkTreeIter iter;
 
     trackersettings_fontlist = g_list_insert(trackersettings_fontlist, fontname, position);
 
-    insertbuf[0] = fontname;
+    insertbuf = fontname;
     
-    gtk_clist_insert(GTK_CLIST(ts->clist), position, insertbuf);
+    list_store = GUI_GET_LIST_STORE(ts->list);
+    gtk_list_store_insert(list_store, &iter, position);
+    gtk_list_store_set(list_store, &iter, 0, insertbuf,  -1);
 }
 
 static void
 trackersettings_gui_delete_font (TrackerSettings *ts,
 				 int position)
 {
+    GtkTreeIter iter;
+    GtkListStore *list_store;
     GList *ll = g_list_nth(trackersettings_fontlist, position);
 
     g_free(ll->data);
     trackersettings_fontlist = g_list_remove_link(trackersettings_fontlist, ll);
-
-    gtk_clist_remove(GTK_CLIST(ts->clist), position);
+    if(!gui_list_get_iter(position, list_store = GUI_GET_LIST_STORE(ts->list), &iter))
+	return; /* Not found, sorry :-\ */
+    gtk_list_store_remove(list_store, &iter);
     ts->clist_selected_row = -1;
 }
 
@@ -68,30 +76,48 @@
 				   int p1,
 				   int p2)
 {
-    gtk_clist_swap_rows(GTK_CLIST(ts->clist), p1, p2);
-    gtk_clist_select_row(GTK_CLIST(ts->clist), p2, 0);
+    GtkTreeIter iter1, iter2;
+    GtkListStore *list_store = GUI_GET_LIST_STORE(ts->list);
+    GtkTreeSelection *sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(ts->list));
+
+    if(!gui_list_get_iter(p1, list_store, &iter1) ||
+       !gui_list_get_iter(p2, list_store, &iter2))
+       return;
+
+    gtk_list_store_swap(list_store, &iter1, &iter2);
+    gtk_tree_selection_select_iter(sel, &iter1);// Minor bug with selection determining is here...
 }
 
 static void
 trackersettings_gui_populate_clist (TrackerSettings *ts)
 {
-    gchar *insertbuf[1];
+    gchar *insertbuf;
     GList *l;
+    GtkListStore *list_store;
+    GtkTreeIter iter;
 
+    list_store = GUI_GET_LIST_STORE(ts->list);
     for(l = trackersettings_fontlist; l != NULL; l = l->next) {
-	insertbuf[0] = (gchar*)l->data;
-        gtk_clist_append(GTK_CLIST(ts->clist), insertbuf);
+	insertbuf = (gchar*)l->data;
+	gtk_list_store_append(list_store, &iter);
+	gtk_list_store_set(list_store, &iter, 0, insertbuf,  -1);
     }
 }
 
 static void
-trackersettings_clist_selected (GtkCList *clist,
-				gint row,
-				gint column,
-				GdkEvent *event,
+trackersettings_clist_selected (GtkTreeSelection *sel,
 				TrackerSettings *ts)
 {
-    ts->clist_selected_row = row;
+    GtkTreeModel *mdl;
+    GtkTreeIter iter;
+    gchar *str;
+    gint row;
+    
+    if(gtk_tree_selection_get_selected(sel, &mdl, &iter)) {
+	row = atoi(str = gtk_tree_model_get_string_from_iter(mdl, &iter));
+	g_free(str);
+	ts->clist_selected_row = row;
+    }
 }
 
 static void
@@ -109,15 +135,15 @@
 
     gtk_widget_hide(ts->fontsel_dialog);
 
-    if(gtk_font_selection_dialog_get_font(GTK_FONT_SELECTION_DIALOG(ts->fontsel_dialog))) {
+    if(gtk_font_selection_dialog_get_font_name(GTK_FONT_SELECTION_DIALOG(ts->fontsel_dialog))) {
 	row = ts->clist_selected_row;
 	if(row == -1) {
 	    row = 0;
 	}
 
 	trackersettings_gui_add_font(ts,
-				       gtk_font_selection_dialog_get_font_name(GTK_FONT_SELECTION_DIALOG(ts->fontsel_dialog)),
-				       row);
+				     gtk_font_selection_dialog_get_font_name(GTK_FONT_SELECTION_DIALOG(ts->fontsel_dialog)),
+				     row);
     }
 }
 
@@ -235,16 +261,16 @@
     gchar *clisttitles[] = { _("Font list") };
     GtkWidget *hbox1, *thing;
 
-    ts = gtk_type_new(trackersettings_get_type());
+    ts = g_object_new(trackersettings_get_type(), NULL);
     GTK_BOX(ts)->spacing = 2;
     GTK_BOX(ts)->homogeneous = FALSE;
 
     ts->clist_selected_row = -1;
     ts->current_font = 0;
 
-    ts->clist = gui_clist_in_scrolled_window(1, clisttitles, GTK_WIDGET(ts));
-    gtk_signal_connect (GTK_OBJECT (ts->clist), "select_row",
-			GTK_SIGNAL_FUNC (trackersettings_clist_selected), ts);
+    ts->list = gui_stringlist_in_scrolled_window(1, clisttitles, GTK_WIDGET(ts));
+    gui_list_handle_selection(ts->list, 
+			      G_CALLBACK(trackersettings_clist_selected), ts);
 
     trackersettings_gui_populate_clist(ts);
 
@@ -255,42 +281,37 @@
     thing = ts->add_button = gtk_button_new_with_label(_("Add font"));
     gtk_box_pack_start(GTK_BOX(hbox1), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect (GTK_OBJECT (thing), "clicked",
-			GTK_SIGNAL_FUNC (trackersettings_add_font), ts);
+    g_signal_connect(thing, "clicked",
+			G_CALLBACK(trackersettings_add_font), ts);
 
     thing = ts->delete_button = gtk_button_new_with_label(_("Delete font"));
     gtk_box_pack_start(GTK_BOX(hbox1), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect (GTK_OBJECT (thing), "clicked",
-			GTK_SIGNAL_FUNC (trackersettings_delete_font), ts);
+    g_signal_connect(thing, "clicked",
+			G_CALLBACK(trackersettings_delete_font), ts);
 
     thing = ts->apply_button = gtk_button_new_with_label(_("Apply font"));
     gtk_box_pack_start(GTK_BOX(hbox1), thing, TRUE, TRUE, 0);
     gtk_widget_show(thing);
-    gtk_signal_connect (GTK_OBJECT (thing), "clicked",
-			GTK_SIGNAL_FUNC (trackersettings_apply_font), ts);
+    g_signal_connect(thing, "clicked",
+			G_CALLBACK(trackersettings_apply_font), ts);
 
     hbox1 = gtk_hbox_new(TRUE, 4);
     gtk_box_pack_start(GTK_BOX(ts), hbox1, FALSE, TRUE, 0);
     gtk_widget_show(hbox1);
 
-#ifndef USE_GNOME
-#define GNOME_STOCK_BUTTON_UP 0
-#define GNOME_STOCK_BUTTON_DOWN 0
-#endif
-    
-    ts->up_button = gui_button(GTK_WIDGET(ts), GNOME_STOCK_BUTTON_UP, _("Up"),
+    ts->up_button = gui_button(GTK_WIDGET(ts), GTK_STOCK_GO_UP,
 			       trackersettings_font_up, ts, hbox1);
 
-    ts->down_button = gui_button(GTK_WIDGET(ts), GNOME_STOCK_BUTTON_DOWN, _("Down"),
+    ts->down_button = gui_button(GTK_WIDGET(ts), GTK_STOCK_GO_DOWN,
 				 trackersettings_font_down, ts, hbox1);
 
     ts->fontsel_dialog = gtk_font_selection_dialog_new(_("Select font..."));
     gtk_window_set_modal(GTK_WINDOW(ts->fontsel_dialog), TRUE);
-    gtk_signal_connect (GTK_OBJECT (GTK_FONT_SELECTION_DIALOG(ts->fontsel_dialog)->ok_button), "clicked",
-			GTK_SIGNAL_FUNC (trackersettings_add_font_ok), ts);
-    gtk_signal_connect (GTK_OBJECT (GTK_FONT_SELECTION_DIALOG(ts->fontsel_dialog)->cancel_button), "clicked",
-			GTK_SIGNAL_FUNC (trackersettings_add_font_cancel), ts);
+    g_signal_connect(GTK_FONT_SELECTION_DIALOG(ts->fontsel_dialog)->ok_button, "clicked",
+			G_CALLBACK(trackersettings_add_font_ok), ts);
+    g_signal_connect(GTK_FONT_SELECTION_DIALOG(ts->fontsel_dialog)->cancel_button, "clicked",
+			G_CALLBACK(trackersettings_add_font_cancel), ts);
 
     return GTK_WIDGET(ts);
 }
@@ -329,7 +350,7 @@
     }
 
     if(g_list_length(trackersettings_fontlist) == 0) {
-	trackersettings_fontlist = g_list_append(trackersettings_fontlist, "fixed");
+	trackersettings_fontlist = g_list_append(trackersettings_fontlist, "Monospace");
     }
 }
 
@@ -366,18 +387,21 @@
     static guint trackersettings_type = 0;
     
     if (!trackersettings_type) {
-	GtkTypeInfo trackersettings_info =
+	GTypeInfo trackersettings_info =
 	{
-	    "TrackerSettings",
-	    sizeof(TrackerSettings),
 	    sizeof(TrackerSettingsClass),
-	    (GtkClassInitFunc) NULL,
-	    (GtkObjectInitFunc) trackersettings_class_init,
-	    (GtkArgSetFunc) NULL,
-	    (GtkArgGetFunc) NULL,
+	    (GBaseInitFunc) NULL,
+		(GBaseFinalizeFunc) NULL,
+	    (GClassInitFunc) NULL,
+	    (GClassFinalizeFunc) NULL,
+	    NULL,
+	    sizeof(TrackerSettings),
+	    0,
+	    (GInstanceInitFunc) trackersettings_class_init,
 	};
 	
-	trackersettings_type = gtk_type_unique (gtk_vbox_get_type (), &trackersettings_info);
+	trackersettings_type = g_type_register_static(gtk_vbox_get_type (),
+	    "TrackerSettings", &trackersettings_info, (GTypeFlags)0);
     }
     
     return trackersettings_type;
diff -Naur soundtracker-0.6.8/app/tracker-settings.h soundtracker-0.6.8-gtk2/app/tracker-settings.h
--- soundtracker-0.6.8/app/tracker-settings.h	2003-03-02 12:34:22.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/tracker-settings.h	2010-09-23 11:11:35.000000000 +0200
@@ -40,7 +40,7 @@
     Tracker *tracker;
     int current_font;
 
-    GtkWidget *clist;
+    GtkWidget *list;
     GtkWidget *add_button, *delete_button, *apply_button;
     GtkWidget *up_button, *down_button;
     GtkWidget *fontsel_dialog;
diff -Naur soundtracker-0.6.8/app/transposition.c soundtracker-0.6.8-gtk2/app/transposition.c
--- soundtracker-0.6.8/app/transposition.c	2002-08-17 18:04:42.000000000 +0200
+++ soundtracker-0.6.8-gtk2/app/transposition.c	2010-09-23 11:11:35.000000000 +0200
@@ -228,8 +228,8 @@
     transposition_window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
     gtk_window_set_title(GTK_WINDOW(transposition_window), _("Transposition Tools"));
 #endif
-    gtk_signal_connect (GTK_OBJECT (transposition_window), "delete_event",
-			GTK_SIGNAL_FUNC (transposition_close_requested), NULL);
+    g_signal_connect(transposition_window, "delete_event",
+			G_CALLBACK(transposition_close_requested), NULL);
 
     gtk_window_set_transient_for(GTK_WINDOW(transposition_window), GTK_WINDOW(mainwindow));
     gtk_window_set_policy(GTK_WINDOW(transposition_window), FALSE, FALSE, FALSE);
@@ -279,8 +279,8 @@
 	thing = gtk_button_new_with_label(labels3[i]);
 	gtk_widget_show(thing);
 	gtk_box_pack_start(GTK_BOX(box1), thing, TRUE, TRUE, 0);
-	gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-			   GTK_SIGNAL_FUNC(transposition_transpose_notes),
+	g_signal_connect(thing, "clicked",
+			   G_CALLBACK(transposition_transpose_notes),
 			   GINT_TO_POINTER(i));
     }
 
@@ -305,8 +305,8 @@
     thing = gtk_button_new_with_label(_("Current instrument"));
     gtk_widget_show(thing);
     gtk_box_pack_start(GTK_BOX(box1), thing, FALSE, TRUE, 0);
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(transposition_current_instrument_clicked), (gpointer)0);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(transposition_current_instrument_clicked), (gpointer)0);
 
     add_empty_hbox(box1);
 
@@ -315,8 +315,8 @@
     thing = gtk_button_new_with_label(_("Current instrument"));
     gtk_widget_show(thing);
     gtk_box_pack_start(GTK_BOX(box1), thing, FALSE, TRUE, 0);
-    gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-		       GTK_SIGNAL_FUNC(transposition_current_instrument_clicked), (gpointer)1);
+    g_signal_connect(thing, "clicked",
+		       G_CALLBACK(transposition_current_instrument_clicked), (gpointer)1);
 
     add_empty_hbox(box1);
 
@@ -328,8 +328,8 @@
 	thing = gtk_button_new_with_label(labels4[i]);
 	gtk_widget_show(thing);
 	gtk_box_pack_start(GTK_BOX(box1), thing, TRUE, TRUE, 0);
-	gtk_signal_connect(GTK_OBJECT(thing), "clicked",
-			   GTK_SIGNAL_FUNC(transposition_change_instruments),
+	g_signal_connect(thing, "clicked",
+			   G_CALLBACK(transposition_change_instruments),
 			   GINT_TO_POINTER(i));
     }
 
@@ -341,15 +341,11 @@
 			FALSE, FALSE, 0);
     gtk_widget_show (hbox);
 
-#ifdef USE_GNOME
-    thing = gnome_stock_button (GNOME_STOCK_BUTTON_CLOSE);
-#else
-    thing = gtk_button_new_with_label (_ ("Close"));
-#endif
+    thing = gtk_button_new_from_stock (GTK_STOCK_CLOSE);
     GTK_WIDGET_SET_FLAGS(thing, GTK_CAN_DEFAULT);
     gtk_window_set_default(GTK_WINDOW(transposition_window), thing);
-    gtk_signal_connect (GTK_OBJECT (thing), "clicked",
-			GTK_SIGNAL_FUNC (transposition_close_requested), NULL);
+    g_signal_connect(thing, "clicked",
+			G_CALLBACK(transposition_close_requested), NULL);
     gtk_box_pack_start (GTK_BOX (hbox), thing, FALSE, FALSE, 0);
     gtk_widget_show (thing);
 
diff -Naur soundtracker-0.6.8/app/xm.c soundtracker-0.6.8-gtk2/app/xm.c
--- soundtracker-0.6.8/app/xm.c	2006-02-25 13:49:05.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/xm.c	2010-09-23 11:11:35.000000000 +0200
@@ -36,6 +36,7 @@
 #include <time.h>
 
 #include <glib.h>
+#include <glib/gprintf.h>
 
 #include "i18n.h"
 #include "gui-settings.h"
@@ -193,7 +194,7 @@
     len = get_le_16(ph + 5);
     if(len > 256) {
 	char buf[128];
-	sprintf(buf, _("Pattern length out of range: %d.\n"), len);
+	g_sprintf(buf, _("Pattern length out of range: %d.\n"), len);
 	error_error(buf);
 	return 0;
     }
@@ -289,7 +290,7 @@
     gint16 *d16;
     gint8 *d8;
 
-    g_assert(num_samples <= 16);
+    g_assert(num_samples <= 128);
 
     for(i = 0; i < num_samples; i++) {
 	s = &samples[i];
@@ -302,7 +303,7 @@
 	s->sample.looptype = sh[14];
 	s->panning = sh[15];
 	s->relnote = sh[16];
-	strncpy(s->name, sh + 18, 22);
+	strncpy(s->name, (char*)sh + 18, 22);
 	s->name[22] = '\0';
 	recode_ibmpc_to_latin1(s->name, 22);
     }
@@ -384,8 +385,8 @@
 	sh[15] = s->panning;
 	sh[16] = s->relnote;
 	sh[17] = 0;
-	strncpy(sh + 18, s->name, 22);
-	recode_latin1_to_ibmpc(sh + 18, 22);
+	strncpy((char*)sh + 18, s->name, 22);
+	recode_latin1_to_ibmpc((char*) sh + 18, 22);
 	fwrite(sh, 1, sizeof(sh), f);
     }
     
@@ -461,7 +462,7 @@
 
     fread(a, 1, sizeof(a), f);
     iheader_size = get_le_32(a);
-    strncpy(instr->name, a + 4, 22);
+    strncpy(instr->name, (char*)a + 4, 22);
     recode_ibmpc_to_latin1(instr->name, 22);
 
     if(iheader_size <= 29) {
@@ -469,8 +470,8 @@
     }
 
     num_samples = get_le_16(a + 27);
-    if(num_samples > 16) {
-	error_error("XM Load Error: Number of samples in instrument > 16.\n");
+   if(num_samples > 128) {
+	error_error("XM Load Error: Number of samples in instrument > 128.\n");
 	return 0;
     }
 
@@ -508,7 +509,7 @@
 	if(instr->vibtype >= 4) {
 	    char buf[128];
 	    instr->vibtype = 0;
-	    sprintf(buf, "XM Load Warning: Invalid vibtype %d, using Sine.\n", instr->vibtype);
+	    g_sprintf(buf, "XM Load Warning: Invalid vibtype %d, using Sine.\n", instr->vibtype);
 	    error_warning(buf);
 	}
 	instr->vibrate = b[13];
@@ -543,19 +544,19 @@
 
     fread(a, 1, 21, f);
     a[21] = 0;
-    if(strcmp(a, "Extended Instrument: ")) {
+    if(strcmp((char*)a, "Extended Instrument: ")) {
 	error_error(_("File is no XI instrument."));
 	return 0;
     }
 
     fread(a, 1, 22, f);
-    strncpy(instr->name, a, 22);
+    strncpy(instr->name, (char*)a, 22);
     recode_ibmpc_to_latin1(instr->name, 22);
 
     fread(a, 1, 23, f);
     if(get_le_16(a + 21) != 0x0102) {
-	sprintf(b, _("Unknown XI version 0x%x\n"), get_le_16(a+21));
-	error_error(b);
+	g_sprintf((char*)b, _("Unknown XI version 0x%x\n"), get_le_16(a+21));
+	error_error((char*)b);
 	return 0;
     }
 
@@ -584,7 +585,7 @@
     if(instr->vibtype >= 4) {
 	char buf[128];
 	instr->vibtype = 0;
-	sprintf(buf, _("Invalid vibtype %d, using Sine.\n"), instr->vibtype);
+	g_sprintf(buf, _("Invalid vibtype %d, using Sine.\n"), instr->vibtype);
 	error_warning(buf);
     }
     instr->vibrate = b[13];
@@ -611,8 +612,8 @@
 
     fwrite("Extended Instrument: ", 1, 21, f);
 
-    strncpy(a, instr->name, 22);
-    recode_latin1_to_ibmpc(a, 22);
+    strncpy((char*)a, instr->name, 22);
+    recode_latin1_to_ibmpc((char*)a, 22);
     fwrite(a, 1, 22, f);
 
     a[0] = 0x1a;
@@ -665,8 +666,8 @@
     num_samples = st_instrument_num_save_samples(instr);
 
     memset(h, 0, sizeof(h));
-    strncpy(h + 4, instr->name, 22);
-    recode_latin1_to_ibmpc(h + 4, 22);
+    strncpy((char*)h + 4, instr->name, 22);
+    recode_latin1_to_ibmpc((char*)h + 4, 22);
 
     if(mode==FALSE)
 	num_samples = 0;
@@ -883,7 +884,7 @@
 		s->sample.looptype = 0;
 	    } else if(s->sample.loopstart > s->sample.loopend) {
 		char buf[128];
-		sprintf(buf, "%d: Wrong loop start parameter. Don't know how to handle this. %04x %04x %04x\n", i, get_be_16(sh[i] + 0), get_be_16(sh[i] + 4), get_be_16(sh[i] + 6));
+		g_sprintf(buf, "%d: Wrong loop start parameter. Don't know how to handle this. %04x %04x %04x\n", i, get_be_16(sh[i] + 0), get_be_16(sh[i] + 4), get_be_16(sh[i] + 6));
 		error_warning(buf);
 		s->sample.loopstart = 0;
 		s->sample.loopend = 1;
@@ -931,7 +932,7 @@
     memset(xh, 0, sizeof(xh));
 
     if(fread(xh + 0, 1, sizeof(xh), f) != sizeof(xh)
-       || strncmp(xh + 0, "Extended Module: ", 17) != 0
+       || strncmp((char*)xh + 0, "Extended Module: ", 17) != 0
        || xh[37] != 0x1a) {
 	fseek(f, 0, SEEK_SET);
 	return xm_load_mod(f,status);
@@ -954,7 +955,7 @@
 	goto fileerr;
     xm_init_locks(xm);
 
-    strncpy(xm->name, xh + 17, 20);
+    strncpy(xm->name, (char*) xh + 17, 20);
     recode_ibmpc_to_latin1(xm->name, 20);
     xm->song_length = get_le_16(xh + 64);
     xm->restart_position = get_le_16(xh + 66);
@@ -998,7 +999,7 @@
 	for(j = 0; j < (sizeof(instr->samples) / sizeof(instr->samples[0])); j++) {
 	    if(instr->samples[j].sample.length > mixer->max_sample_length) {
 		char buf[128];
-		sprintf(buf, _("Module contains sample(s) that are too long for the current mixer.\nMaximum sample length is %d."), mixer->max_sample_length);
+		g_sprintf(buf, _("Module contains sample(s) that are too long for the current mixer.\nMaximum sample length is %d."), mixer->max_sample_length);
 		error_warning(buf);
 		goto weiter;
 	    }
@@ -1040,7 +1041,7 @@
 
     memcpy(xh + 0, "Extended Module: ", 17);
     memcpy(xh + 17, xm->name, 20);
-    recode_latin1_to_ibmpc(xh + 17, 20);
+    recode_latin1_to_ibmpc((char*)xh + 17, 20);
     xh[37] = 0x1a;
     memcpy(xh + 38, "rst's SoundTracker  ", 20);
     put_le_16(xh + 58, 0x104);
@@ -1156,7 +1157,7 @@
 
     strcpy (tname, prefs_get_prefsdir());
     strcat (tname, "/tmp/");
-    sprintf (tfname, "st%d", getpid());
+    g_sprintf (tfname, "st%d", getpid());
     strcat (tname, tfname);
 
     for(i=0; i < 16; i++)
diff -Naur soundtracker-0.6.8/app/xm.h soundtracker-0.6.8-gtk2/app/xm.h
--- soundtracker-0.6.8/app/xm.h	2003-03-02 12:01:48.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/xm.h	2010-09-23 11:11:35.000000000 +0200
@@ -108,7 +108,7 @@
     guint16 volfade;
 
     gint8 samplemap[96];
-    STSample samples[16];
+    STSample samples[128];
 } STInstrument;
 
 /* That the following structure is called 'XM' is a relic from old
diff -Naur soundtracker-0.6.8/app/xm-player.c soundtracker-0.6.8-gtk2/app/xm-player.c
--- soundtracker-0.6.8/app/xm-player.c	2006-02-25 13:30:54.000000000 +0100
+++ soundtracker-0.6.8-gtk2/app/xm-player.c	2010-09-23 11:11:35.000000000 +0200
@@ -1443,7 +1443,7 @@
 
     ninst = 128;
     nord = xm->song_length;
-    nsamp = 16;
+    nsamp = 128;
     ismod = xm->flags & XM_FLAGS_IS_MOD;
     linearfreq = !(xm->flags & XM_FLAGS_AMIGA_FREQ);
     nchan = xm->num_channels;
@@ -1480,8 +1480,7 @@
 
 gboolean
 xmplayer_init_play_song (int songpos,
-			 int patpos,
-			 gboolean init_all)
+			 int patpos, gboolean init_all)
 {
     jumptorow = patpos;
     currow = patpos;
diff -Naur soundtracker-0.6.8/configure.in soundtracker-0.6.8-gtk2/configure.in
--- soundtracker-0.6.8/configure.in	2006-02-25 14:36:07.000000000 +0100
+++ soundtracker-0.6.8-gtk2/configure.in	2010-09-23 11:11:35.000000000 +0200
@@ -23,18 +23,22 @@
 dnl Test for GAS
 dnl -----------------------------------------------------------------------
 
-AC_ARG_ENABLE(asm,
-[  --enable-asm            Enable i386 assembly optimizations (default = off)],
-asm_support=yes,
-asm_support=no)
+dnl AC_ARG_ENABLE(asm,
+dnl [  --enable-asm            Enable i386 assembly optimizations (default = off)],
+dnl asm_support=yes,
+dnl asm_support=no)
+
+dnl AM_CONDITIONAL(NO_ASM, true)
+
+dnl if test x$asm_support != xno; then
+dnl  AM_PROG_AS
+dnl  AC_DEFINE([NO_ASM], 1, [Set if no assembler support is wanted])
+dnl else
+dnl   AC_DEFINE([NO_ASM], 1, [Set if no assembler support is wanted])
+dnl fi
 
-AM_CONDITIONAL(NO_ASM, test x$asm_support = xno)
+AC_DEFINE([NO_ASM], 1, [Set if no assembler support is wanted])
 
-if test x$asm_support != xno; then
-  AM_PROG_AS
-else
-  AC_DEFINE([NO_ASM], 1, [Set if no assembler support is wanted])
-fi
 
 dnl -----------------------------------------------------------------------
 dnl Test for poll()
@@ -56,11 +60,15 @@
 dnl -----------------------------------------------------------------------
 dnl Test for GTK+ / GNOME
 dnl -----------------------------------------------------------------------
-
-AM_PATH_GTK(1.2.2,
-	    ,
-            AC_MSG_ERROR(Cannot find GTK: Is gtk-config in path?),
-	    "gthread")
+SND_MODULES="gtk+-2.0 >= 2.2"
+dnl AM_PATH_GTK(1.2.2,
+dnl	    ,
+dnl            AC_MSG_ERROR(Cannot find GTK: Is gtk-config in path?),
+dnl	    "gthread")
+
+PKG_CHECK_MODULES(GTK, $SND_MODULES)
+AC_SUBST(GTK_CFLAGS)
+AC_SUBST(GTK_LIBS)
 
 gnome=yes
 AC_ARG_ENABLE(gnome,
@@ -68,15 +76,19 @@
         gnome=$enableval, gnome=yes)
 
 if test "$gnome" = yes; then
-  AC_PATH_PROG(gnomepath, gnome-config)
+dnl  AC_PATH_PROG(gnomepath, gnome-config)
   AC_MSG_CHECKING(for Gnome compile flags)
-  GNOME_CFLAGS=`$gnomepath gnomeui --cflags 2>/dev/null`
+dnl  GNOME_CFLAGS=`$gnomepath gnomeui --cflags 2>/dev/null`
+SND_MODULES="libgnomeui-2.0 >= 2.2"
+  PKG_CHECK_MODULES(GNOME, $SND_MODULES)
   if test "_$GNOME_CFLAGS" = _ ; then
     gnome=no
     AC_MSG_RESULT([Gnome not found, building without it.])
   else
     AC_MSG_RESULT(ok)
-    LIBS="$LIBS `$gnomepath gnomeui --libs 2>/dev/null`"
+	AC_SUBST(GNOME_CFLAGS)
+	AC_SUBST(GNOME_LIBS)
+    LIBS="$LIBS $GNOME_LIBS"
     CFLAGS="$CFLAGS $GNOME_CFLAGS"
     AC_DEFINE([USE_GNOME], 1, [Set if GNOME support is compiled in])
   fi
@@ -97,11 +109,18 @@
 
 no_gdkpixbuf=1;
 if test x$gdkpixbuf_support != xno; then
-  AM_PATH_GDK_PIXBUF(0.8.0,
-		     [CFLAGS="$CFLAGS $GDK_PIXBUF_CFLAGS"
-		      LIBS="$LIBS $GDK_PIXBUF_LIBS"
-		      no_gdkpixbuf=0],
-		     [AC_MSG_RESULT([---> Building without GDK_PIXBUF (ignore error above).])])
+SND_MODULES="gdk-pixbuf-2.0 >= 0.15.0"
+  PKG_CHECK_MODULES(GDK_PIXBUF, $SND_MODULES)
+  AC_SUBST(GDK_PIXBUF)
+  AC_SUBST(GDK_PIXBUF)
+  LIBS="$LIBS $GDK_PIXBUF_LIBS"
+  CFLAGS="$CFLAGS $GDK_PIXBUF_CFLAGS"
+dnl  AM_PATH_GDK_PIXBUF(0.8.0,
+dnl		     [CFLAGS="$CFLAGS $GDK_PIXBUF_CFLAGS"
+dnl		      LIBS="$LIBS $GDK_PIXBUF_LIBS"
+dnl		      no_gdkpixbuf=0],
+dnl		     [AC_MSG_RESULT([---> Building without GDK_PIXBUF (ignore error above).])])
+  no_gdkpixbuf=0;
 fi
 
 if test "x${no_gdkpixbuf}" = "x1"; then
